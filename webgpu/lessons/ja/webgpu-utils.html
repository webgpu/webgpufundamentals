<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-utils.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPUç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨æ•°å­¦">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-utils_ja.jpg">

<meta property="og:title" content="WebGPU Utilsã¨wgpu-matrix">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-utils_ja.jpg">
<meta property="og:description" content="WebGPUç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨æ•°å­¦">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Utilsã¨wgpu-matrix">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html">
<meta name="twitter:description" content="WebGPUç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨æ•°å­¦">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-utils_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-utils_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html",
      "inLanguage":"ja",
      "name":"WebGPU Utilsã¨wgpu-matrix",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-utils.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Utilsã¨wgpu-matrix</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-utils.html">English
    </option><option value="/webgpu/lessons/es/webgpu-utils.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-utils.html" selected="">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-utils.html">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-utils.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-utils.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-utils.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-utils.html">ç®€ä½“ä¸­æ–‡
</option></select>


    <a href="#toc">ç›®æ¬¡</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Utilsã¨wgpu-matrix</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">ã“ã®è¨˜äº‹ã¯Gemini Code Assistã«ã‚ˆã£ã¦è‡ªå‹•ç¿»è¨³ã•ã‚Œã¾ã—ãŸã€‚ç¿»è¨³ã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€ãŠæ‰‹æ•°ã§ã™ãŒ<a href="https://github.com/webgpu/webgpufundamentals/pulls">ã“ã¡ã‚‰</a>ã‹ã‚‰Pull Requestã‚’é€ä¿¡ã—ã¦ãã ã•ã„ã€‚</div>
<blockquote>
<h2 id="ã“ã®è¨˜äº‹ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ã¹ãã“ã¨">ã“ã®è¨˜äº‹ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ã¹ãã“ã¨</h2>
<p>WebGPUã®ä½¿ç”¨ã¯éå¸¸ã«å†—é•·ã§ã™ã€‚éå¸¸ã«å†—é•·ãªã®ã§ã€ã„ãã¤ã‹ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚ˆã‚Šé«˜ã„ãƒ¬ãƒ™ãƒ«ã®æ¦‚å¿µã«é›†ä¸­ã§ãã‚‹ãŸã‚ã€ç†è§£ã—ã‚„ã™ããªã‚Šã¾ã™ã€‚</p>
<p>ãŸã¨ãˆã°ã€æ•°å­¦ã‚’å­¦ã‚“ã§ã„ã‚‹ã¨ã—ã¾ã™ã€‚å…ˆç”Ÿã¯ã€Œå¹³å‡ã€ã¨ã¯ä½•ã‹ã€ãã—ã¦ã„ãã¤ã‹ã®æ•°å€¤ã®ã‚»ãƒƒãƒˆã®å¹³å‡ã‚’è¨ˆç®—ã™ã‚‹æ–¹æ³•ã‚’æ•™ãˆã¾ã™ã€‚ãã‚Œã‚’æ•™ãˆãŸå¾Œã€å½¼ã‚‰ã¯ä»–ã®ã“ã¨ã«ç§»ã‚Šã€ã€Œã“ã“ã§å¹³å‡ã‚’è¨ˆç®—ã—ã¾ã™ã€ã¨è¨€ã†ã ã‘ã§ã™ã€‚ãŸã¨ãˆã°ã€</p>
<blockquote>
<p>æ¨™æº–åå·®ã‚’è¨ˆç®—ã™ã‚‹ã«ã¯</p>
<ul>
<li>ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã®å¹³å‡ã‚’è¨ˆç®—ã—ã¾ã™</li>
<li>ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®å„æ•°å€¤ã«ã¤ã„ã¦ã€ãã®æ•°å€¤ã¨å¹³å‡ã®å·®ã‚’è¨ˆç®—ã—ã¾ã™ã€‚</li>
<li>å„å·®ã‚’è¦‹ã¤ã‘ãŸã‚‰ã€ãã‚Œã‚’2ä¹—ã—ã¾ã™ã€‚</li>
<li>2ä¹—å·®ã®å¹³å‡ã®å¹³æ–¹æ ¹ã‚’å–ã‚Šã¾ã™</li>
</ul>
</blockquote>
<p>å½¼ã‚‰ã¯å¹³å‡ã®è¨ˆç®—æ–¹æ³•ã‚’å†èª¬æ˜ã—ã¾ã›ã‚“ã€‚ã‚ãªãŸã¯ã™ã§ã«ãã‚Œã‚’å­¦ã‚“ã§ãŠã‚Šã€å½¼ã‚‰ã¯ã‚ãªãŸãŒã™ã§ã«å­¦ã‚“ã ã“ã¨ã‚’å‚ç…§ã™ã‚‹ã ã‘ã§ã™ã€‚</p>
<p>åŒæ§˜ã«ã€WebGPUã§ã¯ã€WGSLã§ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ç”¨ã®æ§‹é€ ä½“ã‚’ä½œæˆã™ã‚‹ã¨ã„ã†æ¦‚å¿µãŒã‚ã‚Šã¾ã™ã€‚æ¬¡ã«ã€1ã¤ä»¥ä¸Šã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã€ãã‚Œã‚‰ã®ãƒãƒƒãƒ•ã‚¡ã«<code class="notranslate" translate="no">TypedArrays</code>ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã—ã¾ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã€ã“ã®ã‚µã‚¤ãƒˆã®æœ€åˆã®20ã€œ30ã®è¨˜äº‹ã¨<a href="webgpu-memory-layout.html">ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§è©³ã—ãèª¬æ˜ã—ã¾ã—ãŸã€‚</p>
<p>ã—ã‹ã—ã€ã‚ã‚‹æ™‚ç‚¹ã§ã€ã€Œãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¨­å®šã™ã‚‹ã€ã¨è¨€ã†ã ã‘ã§ã€ã“ã‚Œã‚‰ã®è©³ç´°ã‚’æ‰±ã†ã‚³ãƒ¼ãƒ‰ã‚’ç†è§£ã™ã‚‹ã®ãŒé›£ã—ããªã‚Šã¾ã™ã€‚ãã—ã¦ã€ã‚ãªãŸã¯ä»¥å‰ã«ã€Œãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¨­å®šã™ã‚‹ã€ã¨ã¯ã€ã€Œã•ã¾ã–ã¾ãªãƒ‡ãƒ¼ã‚¿ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ã—ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®šã§ãã‚‹ã‚ˆã†ã«å‹ä»˜ãé…åˆ—ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ã€‚ãã—ã¦å¾Œã§ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹å‰ã«ã€ãã‚Œã‚’è¨­å®šã—ã¦GPUã«å€¤ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã€ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã“ã¨ã‚’å­¦ã³ã¾ã—ãŸã€‚</p>
<p>ãã®ãŸã‚ã€ã“ã®ã‚µã‚¤ãƒˆã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æã‚Œãªã„ã§ãã ã•ã„ã€‚ãã®æ©Ÿèƒ½ã®ã»ã¨ã‚“ã©ã™ã¹ã¦ã¯ã€ã‚µã‚¤ãƒˆã®æœ€åˆã®è¨˜äº‹ã§è©³ã—ãèª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã«ã„ãã¤ã‹ã®è©³ç´°ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<p>ã“ã®ã‚µã‚¤ãƒˆã®å¤šãã®ä¾‹ã§ã¯ã€2ã¤ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</p>
<h2 id="wgpu-matrix">wgpu-matrix</h2>
<p>1ã¤ç›®ã¯<a href="https://github.com/greggman/wgpu-matrix">wgpu-matrix</a>ã§ã™ã€‚wgpu-matrixã¯ã€<a href="webgpu-matrix-math.html">è¡Œåˆ—æ¼”ç®—ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã‹ã‚‰<a href="webgpu-perspective-projection.html">é è¿‘æŠ•å½±ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã€ãŠã‚ˆã³<a href="webgpu-lighting-directional.html">ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§è¨˜è¿°ã—ãŸã®ã¨åŒã˜é–¢æ•°ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
<p>ã“ã“ã§ã¯ç‰¹åˆ¥ãªã“ã¨ã¯ä½•ã‚‚èµ·ã“ã£ã¦ã„ã¾ã›ã‚“ã€‚æ•°å­¦é–¢æ•°ã®ã„ãšã‚Œã‹ãŒã©ã®ã‚ˆã†ã«æ©Ÿèƒ½ã™ã‚‹ã‹ã‚’çŸ¥ã‚ŠãŸã„å ´åˆã¯ã€ä¸Šè¨˜ã®è¨˜äº‹ã‚’èª­ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
<h2 id="webgpu-utils">webgpu-utils</h2>
<p>2ã¤ç›®ã¯<a href="https://github.com/greggman/webgpu-utils">webgpu-utils</a>ã§ã™ã€‚</p>
<p>WebGPU Utilsã¯ã€ã•ã¾ã–ã¾ãªè¨˜äº‹ã§è¨˜è¿°ã—ãŸä»–ã®ä¾¿åˆ©ãªé–¢æ•°ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚ãŸã¨ãˆã°ã€é–¢æ•°</p>
<ul>
<li><code class="notranslate" translate="no">numMipLevels</code></li>
<li><code class="notranslate" translate="no">loadImageBitmap</code></li>
<li><code class="notranslate" translate="no">copySourceToTexture</code></li>
<li><code class="notranslate" translate="no">createTextureFromSource</code></li>
<li><code class="notranslate" translate="no">createTextureFromImage</code></li>
<li><code class="notranslate" translate="no">generateMips</code></li>
</ul>
<p>ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ã€<a href="webgpu-importing-textures.html">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã®ç”»åƒã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§ä½œæˆã—ã¾ã—ãŸã€‚</p>
<p>ã¾ãŸã€</p>
<ul>
<li><code class="notranslate" translate="no">copySourcesToTexture</code></li>
<li><code class="notranslate" translate="no">createTextureFromSources</code></li>
<li><code class="notranslate" translate="no">generateMips</code></li>
</ul>
<p><a href="webgpu-cubemaps.html">ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã‹ã‚‰ã€‚ãã®è¨˜äº‹ã§ã¯ã€è¤‡æ•°ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‡¦ç†ã™ã‚‹ã‚ˆã†ã«<code class="notranslate" translate="no">generateMips</code>ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚</p>
<p>ãã—ã¦ã€<a href="webgpu-transparency.html">é€æ˜åº¦ã¨ãƒ–ãƒ¬ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§<code class="notranslate" translate="no">premultipliedAlpha</code>ã®ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ãŸæ–¹æ³•ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚</p>
<p>ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€</p>
<ul>
<li><code class="notranslate" translate="no">createTextureFromImages</code></li>
</ul>
<p><a href="webgpu-environment-maps.html">ç’°å¢ƒãƒãƒƒãƒ—ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã‹ã‚‰ã€‚</p>
<h3 id="makeshaderdatadefinitionsã¨makestructuredview"><code class="notranslate" translate="no">makeShaderDataDefinitions</code>ã¨<code class="notranslate" translate="no">makeStructuredView</code></h3>
<p>ã“ã‚Œã‚‰ã®2ã¤ã®é–¢æ•°ã¯ã€<a href="webgpu-memory-layout.html">ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§ç°¡å˜ã«è§¦ã‚Œã¾ã—ãŸã€‚</p>
<p><a href="webgpu-fundamentals.html">åŸºæœ¬çš„ãªè¨˜äº‹</a>ã®ã™ã¹ã¦ã€ãŠã‚ˆã³<a href="webgpu-matrix-math.html">è¡Œåˆ—æ¼”ç®—ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã¨<a href="webgpu-lighting-direction.html">ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§è¦‹ãŸã‚ˆã†ã«ã€WGSLã§æ§‹é€ ä½“ã‚’ä½œæˆã™ã‚‹å ´åˆã€é€šå¸¸ã€ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã¾ãŸã¯ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã€ä½•ã‚‰ã‹ã®æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<p>ç‰¹ã«ã€ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã«é–¢ã™ã‚‹è¨˜äº‹ã§ã“ã‚Œã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æ§‹é€ ä½“ãŒã‚ã‚Šã¾ã—ãŸã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  matrix: mat4x4f,
  color: vec4f,
  lightDirection: vec3f,
};
</pre>
<p>æ¬¡ã«ã€ã“ã‚Œã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  world: mat4x4f,
  worldViewProjection: mat4x4f,
  color: vec4f,
  lightDirection: vec3f,
};
</pre>
<p>æ¬¡ã«ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  color: vec4f,
  lightDirection: vec3f,
};
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightPosition: vec3f,
};
</pre>
<p>ã“ã‚Œã«ç¶šã„ã¦</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
};
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
  shininess: f32,
};
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
  shininess: f32,
  lightDirection: vec3f,
  limit: f32,
};
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
  shininess: f32,
  lightDirection: vec3f,
  innerLimit: f32,
  outerLimit: f32,
};
</pre>
<p>ã“ã‚Œã‚‰ã®å¤‰æ›´ã‚’è¡Œã†ãŸã³ã«ã€ãƒ“ãƒ¥ãƒ¼ã‚’è¨­å®šã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«å…¥ã‚Šã€éå¸¸ã«å¤šãã®ã‚‚ã®ã‚’ç·¨é›†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚ä½•ã‚’ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã‹ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€é€²è¡ŒçŠ¶æ³ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚</p>
<p><a href="webgpu-lighting-directional.html">æŒ‡å‘æ€§ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§ã“ã“ã‹ã‚‰å§‹ã‚ã¾ã—ãŸã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // è¡Œåˆ— + è‰² + å…‰ã®æ–¹å‘
  const uniformBufferSize = (16 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const kMatrixOffset = 0;
  const kColorOffset = 16;
  const kLightDirectionOffset = 20;

  const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightDirectionValue =
      uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
</pre>
<p>æ¬¡ã«ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (16 + 4 + 4) * 4;
+  const uniformBufferSize = (16 + 16 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
-  const kMatrixOffset = 0;
-  const kColorOffset = 16;
-  const kLightDirectionOffset = 20;
+  const kWorldOffset = 0;
+  const kWorldViewProjectionOffset = 16;
+  const kColorOffset = 32;
+  const kLightDirectionOffset = 36;

-  const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);
+  const worldValue = uniformValues.subarray(kWorldOffset, kWorldOffset + 16);
+  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightDirectionValue =
      uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
</pre>
<p>æ¬¡ã«ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (16 + 16 + 4 + 4) * 4;
+  const uniformBufferSize = (12 + 16 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
-  const kWorldOffset = 0;
-  const kWorldViewProjectionOffset = 16;
-  const kColorOffset = 32;
-  const kLightDirectionOffset = 36;
+  const kNormalMatrixOffset = 0;
+  const kWorldViewProjectionOffset = 12;
+  const kColorOffset = 28;
+  const kLightDirectionOffset = 32;

-  const worldValue = uniformValues.subarray(kWorldOffset, kWorldOffset + 16);
+  const normalMatrixValue = uniformValues.subarray(
+      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightDirectionValue =
      uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (12 + 16 + 4 + 4) * 4;
+  const uniformBufferSize = (12 + 16 + 16 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const kNormalMatrixOffset = 0;
  const kWorldViewProjectionOffset = 12;
-  const kColorOffset = 28;
-  const kLightDirectionOffset = 32;
+  const kWorldOffset = 28;
+  const kColorOffset = 44;
+  const kLightPositionOffset = 48;

  const normalMatrixValue = uniformValues.subarray(
      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
+  const worldValue = uniformValues.subarray(
+      kWorldOffset, kWorldOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
-  const lightDirectionValue =
-      uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
+  const lightPositionValue =
+      uniformValues.subarray(kLightPositionOffset, kLightPositionOffset + 3);
</pre>
<p>ã“ã‚Œã«ç¶šã„ã¦</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (12 + 16 + 16 + 4 + 4) * 4;
+  const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const kNormalMatrixOffset = 0;
  const kWorldViewProjectionOffset = 12;
  const kWorldOffset = 28;
  const kColorOffset = 44;
  const kLightPositionOffset = 48;
+  const kViewWorldPositionOffset = 52;

  const normalMatrixValue = uniformValues.subarray(
      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const worldValue = uniformValues.subarray(
      kWorldOffset, kWorldOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightPositionValue = uniformValues.subarray(
      kLightPositionOffset, kLightPositionOffset + 3);
+  const viewWorldPositionValue = uniformValues.subarray(
+      kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNormalMatrixOffset = 0;
  const kWorldViewProjectionOffset = 12;
  const kWorldOffset = 28;
  const kColorOffset = 44;
  const kLightWorldPositionOffset = 48;
  const kViewWorldPositionOffset = 52;
+  const kShininessOffset = 55;

  const normalMatrixValue = uniformValues.subarray(
      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const worldValue = uniformValues.subarray(
      kWorldOffset, kWorldOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightWorldPositionValue = uniformValues.subarray(
      kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
  const viewWorldPositionValue = uniformValues.subarray(
      kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
+  const shininessValue = uniformValues.subarray(
+      kShininessOffset, kShininessOffset + 1);
</pre>
<p>ãã—ã¦ã“ã‚Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4) * 4;
+  const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const kNormalMatrixOffset = 0;
  const kWorldViewProjectionOffset = 12;
  const kWorldOffset = 28;
  const kColorOffset = 44;
  const kLightWorldPositionOffset = 48;
  const kViewWorldPositionOffset = 52;
  const kShininessOffset = 55;
+  const kLightDirectionOffset = 56;
+  const kLimitOffset = 59;

  const normalMatrixValue = uniformValues.subarray(
      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const worldValue = uniformValues.subarray(
      kWorldOffset, kWorldOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightWorldPositionValue = uniformValues.subarray(
      kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
  const viewWorldPositionValue = uniformValues.subarray(
      kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
  const shininessValue = uniformValues.subarray(
      kShininessOffset, kShininessOffset + 1);
+  const lightDirectionValue = uniformValues.subarray(
+      kLightDirectionOffset, kLightDirectionOffset + 3);
+  const limitValue = uniformValues.subarray(
+      kLimitOffset, kLimitOffset + 1);
</pre>
<p>ãã—ã¦æœ€å¾Œã«ã€<a href="webgpu-lighting-spot.html">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã«é–¢ã™ã‚‹è¨˜äº‹</a>ã®æœ€å¾Œã‹ã‚‰ã“ã‚Œã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4 + 4) * 4;
+  const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4 + 4 + 4) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const kNormalMatrixOffset = 0;
  const kWorldViewProjectionOffset = 12;
  const kWorldOffset = 28;
  const kColorOffset = 44;
  const kLightWorldPositionOffset = 48;
  const kViewWorldPositionOffset = 52;
  const kShininessOffset = 55;
  const kLightDirectionOffset = 56;
-  const kLimitOffset = 59;
+  const kInnerLimitOffset = 59;
+  const kOuterLimitOffset = 60;

  const normalMatrixValue = uniformValues.subarray(
      kNormalMatrixOffset, kNormalMatrixOffset + 12);
  const worldViewProjectionValue = uniformValues.subarray(
      kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
  const worldValue = uniformValues.subarray(
      kWorldOffset, kWorldOffset + 16);
  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
  const lightWorldPositionValue = uniformValues.subarray(
      kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
  const viewWorldPositionValue = uniformValues.subarray(
      kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
  const shininessValue = uniformValues.subarray(
      kShininessOffset, kShininessOffset + 1);
  const lightDirectionValue = uniformValues.subarray(
      kLightDirectionOffset, kLightDirectionOffset + 3);
-  const limitValue = uniformValues.subarray(
-      kLimitOffset, kLimitOffset + 1);
+  const innerLimitValue = uniformValues.subarray(
+      kInnerLimitOffset, kInnerLimitOffset + 1);
+  const outerLimitValue = uniformValues.subarray(
+      kOuterLimitOffset, kOuterLimitOffset + 1);
</pre>
<p><strong>ã“ã®å†—é•·æ€§ã¯ã€è¨˜äº‹ã®è¦ç‚¹ã‹ã‚‰æ³¨æ„ã‚’ãã‚‰ã—ã¦ã„ã‚‹</strong>ã“ã¨ã‚’é¡˜ã£ã¦ã„ã¾ã™ï¼ç§ãŸã¡ãŒæœ¬å½“ã«è¨€ã„ãŸã‹ã£ãŸã®ã¯ã€ã€ŒWGSLæ§‹é€ ä½“ã‚’ã“ã‚Œã«å¤‰æ›´ã—ã€æç”»ã™ã‚‹å‰ã«å€¤ã‚’è¨­å®šã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã ã‘ã§ã™ãŒã€ä»£ã‚ã‚Šã«ã€<strong>ä¾‹ã”ã¨ã«</strong>40è¡Œä»¥ä¸Šã®ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</p>
<p><code class="notranslate" translate="no">makeShaderDataDefinitions</code>ã¨<code class="notranslate" translate="no">makeStructuredView</code>ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä¸Šè¨˜ã®ã™ã¹ã¦ã®JavaScriptã‚’ã“ã‚Œã‚‰ã®7è¡Œã«å¤‰æ›´ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const defs = makeShaderDataDefinitions(code);
const uni = makeStructuredView(defs.uniforms.uni);

const uniformBuffer = device.createBuffer({
  size: uni.arrayBuffer.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
</pre>
<p>ä»¥ä¸Šã§ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«é–“ã§ã€å¿…è¦ã«å¿œã˜ã¦æ§‹é€ ä½“ã‚’å¤‰æ›´ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®2ã¤ã®é–¢æ•°ã¯ã€ã“ã‚Œã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ãƒ“ãƒ¥ãƒ¼ã‚’ã™ã¹ã¦ä½œæˆã—ã¾ã™ã€‚</p>
<p>æœ€å¾Œã®ä¾‹ã®æ§‹é€ ä½“ã‚’å–ã‚‹ã¨ã€</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  worldViewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
  shininess: f32,
  lightDirection: vec3f,
  innerLimit: f32,
  outerLimit: f32,
};

*@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;
</pre>
<p>ã“ã‚Œã‚‰ã®2è¡Œ</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const defs = makeShaderDataDefinitions(code);
const uni = makeStructuredView(defs.uniforms.uni);
</pre>
<p><code class="notranslate" translate="no">WGSL</code>ã§å®šç¾©ã—ãŸãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã§ã‚ã‚‹<code class="notranslate" translate="no">uni</code>ã®ã€Œæ§‹é€ åŒ–ãƒ“ãƒ¥ãƒ¼ã€ã‚’ä½œæˆã—ã¾ã™ã€‚</p>
<p>äº‹å®Ÿä¸Šã€ã“ã‚Œã‚‰ã®è¡Œã¯ã“ã‚Œã‚’ä½œæˆã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const arrayBuffer = new ArrayBuffer(256);
const uni = {
  arrayBuffer,
  set: function(data) { /* helper */ },
  views: {
    normalMatrix: new Float32Array(arrayBuffer, 0, 12),
    worldViewProjection: new Float32Array(arrayBuffer, 48, 16),
    world: new Float32Array(arrayBuffer, 112, 16),
    color: new Float32Array(arrayBuffer, 176, 4),
    lightWorldPosition: new Float32Array(arrayBuffer, 192, 3),
    viewWorldPosition: new Float32Array(arrayBuffer, 208, 3),
    shininess: new Float32Array(arrayBuffer, 220, 1),
    lightDirection: new Float32Array(arrayBuffer, 224, 3),
    innerLimit: new Float32Array(arrayBuffer, 236, 1),
    outerLimit: new Float32Array(arrayBuffer, 240, 1),
  },
};
</pre>
<p><code class="notranslate" translate="no">makeShaderDataDefinitions</code>ãŒå®Ÿéš›ã«WGSLã‚’è§£æã—ã¦ã€ã“ã‚Œã‚‰ã®ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ã®ã«ååˆ†ãªãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã™ã‚‹ã¨ã„ã†äº‹å®Ÿã‚’é™¤ã„ã¦ã€ã“ã“ã«é­”æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
<p>ä¸Šè¨˜ã®è¨˜äº‹ã§ã¯ã€å€¤ã‚’è¨­å®šã™ã‚‹ãŸã‚ã«æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã—ãŸã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        degToRad(60),
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    const eye = [100, 150, 200];
    const target = [0, 35, 0];
    const up = [0, 1, 0];

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
    const viewMatrix = mat4.lookAt(eye, target, up);

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨å°„å½±è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
    const world = mat4.rotationY(settings.rotation, worldValue);

    // ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ã¨ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
    mat4.multiply(viewProjectionMatrix, world, worldViewProjectionValue);

    // é€†è¡Œåˆ—ã¨è»¢ç½®è¡Œåˆ—ã‚’normalMatrixå€¤ã«å¤‰æ›ã—ã¾ã™
    mat3.fromMat4(mat4.transpose(mat4.inverse(world)), normalMatrixValue);

    colorValue.set([0.2, 1, 0.2, 1]);  // green
    lightWorldPositionValue.set([-10, 30, 100]);
    viewWorldPositionValue.set(eye);
    shininessValue[0] = settings.shininess;
    innerLimitValue[0] = Math.cos(settings.innerLimit);
    outerLimitValue[0] = Math.cos(settings.outerLimit);

    // ã»ã¨ã‚“ã©ã®ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ä¾‹ã®ã‚ˆã†ã«å¹³é¢ãŒãªã„ã®ã§ã€
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã‚’Fã«å‘ã‘ã¾ã—ã‚‡ã†
    {
        const mat = mat4.aim(
            lightWorldPositionValue,
            [
              target[0] + settings.aimOffsetX,
              target[1] + settings.aimOffsetY,
              0,
            ],
            up);
        // è¡Œåˆ—ã‹ã‚‰zAxisã‚’å–å¾—ã—ã¾ã™
        // lookAtã¯-Zè»¸ã‚’è¦‹ä¸‹ã‚ã™ãŸã‚ã€ãã‚Œã‚’å¦å®šã—ã¾ã™
        lightDirectionValue.set(mat.slice(8, 11));
    }

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<p>ãã®ã‚³ãƒ¼ãƒ‰ã¯ã“ã‚Œã«å¤‰æ›´ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    // åŒã˜æ—¢å­˜ã®åå‰ã‚’ä½¿ç”¨ã—ã¦ãƒ“ãƒ¥ãƒ¼ã‚’ãƒ—ãƒ«ã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
+    const {
+      world: worldValue,
+      worldViewProjection: worldViewProjectionValue,
+      normalMatrix: normalMatrixValue,
+      color: colorValue,
+      lightWorldPosition: lightWorldPositionValue,
+      lightDirection: lightDirectionValue,
+      viewWorldPosition: viewWorldPositionValue,
+      shininess: shininessValue,
+      innerLimit: innerLimitValue,
+      outerLimit: outerLimitValue,
+    } = uni.views;

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        degToRad(60),
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    const eye = [100, 150, 200];
    const target = [0, 35, 0];
    const up = [0, 1, 0];

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
    const viewMatrix = mat4.lookAt(eye, target, up);

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨å°„å½±è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
    const world = mat4.rotationY(settings.rotation, worldValue);

    // ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ã¨ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
    mat4.multiply(viewProjectionMatrix, world, worldViewProjectionValue);

    // é€†è¡Œåˆ—ã¨è»¢ç½®è¡Œåˆ—ã‚’normalMatrixå€¤ã«å¤‰æ›ã—ã¾ã™
    mat3.fromMat4(mat4.transpose(mat4.inverse(world)), normalMatrixValue);

    colorValue.set([0.2, 1, 0.2, 1]);  // green
    lightWorldPositionValue.set([-10, 30, 100]);
    viewWorldPositionValue.set(eye);
    shininessValue[0] = settings.shininess;
    innerLimitValue[0] = Math.cos(settings.innerLimit);
    outerLimitValue[0] = Math.cos(settings.outerLimit);

    // ã»ã¨ã‚“ã©ã®ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ä¾‹ã®ã‚ˆã†ã«å¹³é¢ãŒãªã„ã®ã§ã€
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã‚’Fã«å‘ã‘ã¾ã—ã‚‡ã†
    {
        const mat = mat4.aim(
            lightWorldPositionValue,
            [
              target[0] + settings.aimOffsetX,
              target[1] + settings.aimOffsetY,
              0,
            ],
            up);
        // è¡Œåˆ—ã‹ã‚‰zAxisã‚’å–å¾—ã—ã¾ã™
        // lookAtã¯-Zè»¸ã‚’è¦‹ä¸‹ã‚ã™ãŸã‚ã€ãã‚Œã‚’å¦å®šã—ã¾ã™
        lightDirectionValue.set(mat.slice(8, 11));
    }

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™
-    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
+    device.queue.writeBuffer(uniformBuffer, 0, uni.arrayBuffer);
</pre>
<p>ã¾ãŸã¯ã€ãƒ“ãƒ¥ãƒ¼ã‚’ç›´æ¥ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    // åŒã˜æ—¢å­˜ã®åå‰ã‚’ä½¿ç”¨ã—ã¦ãƒ“ãƒ¥ãƒ¼ã‚’ãƒ—ãƒ«ã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
-    const {
-      world: worldValue,
-      worldViewProjection: worldViewProjectionValue,
-      normalMatrix: normalMatrixValue,
-      color: colorValue,
-      lightWorldPosition: lightWorldPositionValue,
-      lightDirection: lightDirectionValue,
-      viewWorldPosition: viewWorldPositionValue,
-      shininess: shininessValue,
-      innerLimit: innerLimitValue,
-      outerLimit: outerLimitValue,
-    } = uni.views;
+   const { views } = uni;

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        degToRad(60),
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    const eye = [100, 150, 200];
    const target = [0, 35, 0];
    const up = [0, 1, 0];

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
    const viewMatrix = mat4.lookAt(eye, target, up);

    // ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨å°„å½±è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¾ã™
-    const world = mat4.rotationY(settings.rotation, worldValue);
+    const world = mat4.rotationY(settings.rotation, views.world);

    // ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ã¨ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’çµ„ã¿åˆã‚ã›ã¾ã™
-    mat4.multiply(viewProjectionMatrix, world, worldViewProjectionValue);
+    mat4.multiply(viewProjectionMatrix, world, views.worldViewProjection);

    // é€†è¡Œåˆ—ã¨è»¢ç½®è¡Œåˆ—ã‚’normalMatrixå€¤ã«å¤‰æ›ã—ã¾ã™
-    mat3.fromMat4(mat4.transpose(mat4.inverse(world)), normalMatrixValue);
+    mat3.fromMat4(mat4.transpose(mat4.inverse(world)), views.normalMatrix);

-    views.color.set([0.2, 1, 0.2, 1]);  // green
-    views.lightWorldPosition.set([-10, 30, 100]);
-    views.viewWorldPosition.set(eye);
-    views.shininess[0] = settings.shininess;
-    views.innerLimit[0] = Math.cos(settings.innerLimit);
-    views.outerLimit[0] = Math.cos(settings.outerLimit);
+    uni.set({
+      color: [0.2, 1, 0.2, 1],  // green
+      lightWorldPosition: [-10, 30, 100],
+      viewWorldPosition: eye,
+      shininess: settings.shininess,
+      innerLimit: settings.innerLimit,
+      outerLimit: settings.outerLimit,
+    });

    // ã»ã¨ã‚“ã©ã®ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ä¾‹ã®ã‚ˆã†ã«å¹³é¢ãŒãªã„ã®ã§ã€
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã‚’Fã«å‘ã‘ã¾ã—ã‚‡ã†
    {
        const mat = mat4.aim(
-            lightWorldPositionValue,
+            views.lightWorldPosition,
            [
              target[0] + settings.aimOffsetX,
              target[1] + settings.aimOffsetY,
              0,
            ],
            up);
        // è¡Œåˆ—ã‹ã‚‰zAxisã‚’å–å¾—ã—ã¾ã™
        // lookAtã¯-Zè»¸ã‚’è¦‹ä¸‹ã‚ã™ãŸã‚ã€ãã‚Œã‚’å¦å®šã—ã¾ã™
-        views.lightDirection.set(mat.slice(8, 11));
+        uni.set({ lightDirectionValue: mat.slice(8, 11) });
    }

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™
    device.queue.writeBuffer(uniformBuffer, 0, uni.arrayBuffer);
</pre>
<p><code class="notranslate" translate="no">set</code>é–¢æ•°ã¯ã€ä¸Šè¨˜ã§ç¤ºã—ãŸãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã§ã¯ã€ã‹ãªã‚Šå˜ç´”ã§ã‚ã‚‹ã¨æƒ³åƒã§ãã¾ã™ã€‚</p>
<p>ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const arrayBuffer = new ArrayBuffer(256);
const views = {
  normalMatrix: new Float32Array(arrayBuffer, 0, 12),
  worldViewProjection: new Float32Array(arrayBuffer, 48, 16),
  world: new Float32Array(arrayBuffer, 112, 16),
  color: new Float32Array(arrayBuffer, 176, 4),
  lightWorldPosition: new Float32Array(arrayBuffer, 192, 3),
  viewWorldPosition: new Float32Array(arrayBuffer, 208, 3),
  shininess: new Float32Array(arrayBuffer, 220, 1),
  lightDirection: new Float32Array(arrayBuffer, 224, 3),
  innerLimit: new Float32Array(arrayBuffer, 236, 1),
  outerLimit: new Float32Array(arrayBuffer, 240, 1),
};
const uni = {
  arrayBuffer,
  set: function(data) {
    // éåº¦ã«å˜ç´”åŒ–
    for (const [key, value] of Object.entries(data)) {
      const view = views[key];
      if (view) {
        view.set(typeof value === 'number' ? [value] : value);
      }
    }
  },
};
</pre>
<p>å®Ÿéš›ã®<code class="notranslate" translate="no">set</code>ã®å®Ÿè£…ã¯ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸæ§‹é€ ä½“ã¨é…åˆ—ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€ã‚ãšã‹ã«è¤‡é›‘ã§ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã‚½ãƒ¼ã‚¹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
ã“ã‚ŒãŒã€Œsetã€ã®ã‚³ãƒ¼ãƒ‰ã§ã™ï¼š<a href="https://github.com/greggman/webgpu-utils/blob/cb61348691718e22f877e0011673f84d456927b6/src/buffer-views.ts#L291">ãƒªãƒ³ã‚¯</a>
ãã—ã¦ã€ã“ã‚ŒãŒå‘¼ã³å‡ºã™é–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ã§ã™ï¼š<a href="https://github.com/greggman/webgpu-utils/blob/cb61348691718e22f877e0011673f84d456927b6/src/buffer-views.ts#L386">ãƒªãƒ³ã‚¯</a></p>
<p>ä¸Šè¨˜ã®ä¾‹ãŒã€ãã‚ŒãŒé­”æ³•ã§ã¯ãªã„ã“ã¨ã‚’æ˜ç¢ºã«ã™ã‚‹ã“ã¨ã‚’é¡˜ã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å˜ç´”ãªé–¢æ•°ã¯ã€WebGPUã®ä½¿ç”¨ã‚’ã¯ã‚‹ã‹ã«é¢å€’ã§ãªãã—ã€ç‰©äº‹ã‚’ã¯ã‚‹ã‹ã«å˜ç´”ã«èª¬æ˜ã§ãã¾ã™ã€‚ã€Œãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’è¨­å®šã™ã‚‹ã€ã¨è¨€ã†ã ã‘ã§ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆã®è¨ˆç®—ã€ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆãªã©ã®é¢å€’ãªä½œæ¥­ã‚’150å›ç›®ã«è¦‹ã›ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
<h2 id="é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¨å±æ€§">é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¨å±æ€§</h2>
<p>ã‚‚ã†1ã¤ã€é¢å€’ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒã§ãã‚‹å ´æ‰€ã¯ã€é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¨å±æ€§ã®è¨­å®šã§ã™ã€‚å•é¡Œã¯é€šå¸¸ã€é ‚ç‚¹ä½ç½®ã€é ‚ç‚¹æ³•ç·šã€é ‚ç‚¹ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãªã©ã®ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ãªã“ã¨ã§ã™ã€‚ãã‚Œã‚‰ã‚’åˆ¥ã€…ã®é…åˆ—ã§ä½œæˆã§ãã¾ã™ã€‚ã“ã‚Œã¯ç°¡å˜ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const positions = [];
const normals = [];
const texcoords = [];

for(each vertex) {
  ...
  position.push(x, y, z);
  normals.push(nx, ny, nz);
  texcoord.push(u, v);
}
</pre>
<p>ã“ã‚Œã§ã€3ã¤ã®ãƒãƒƒãƒ•ã‚¡ã¨3ã¤ã®å±æ€§ã‚»ãƒƒãƒˆãŒå¿…è¦ã«ãªã‚‹ã¨ã„ã†è¿½åŠ ã®è¤‡é›‘ã•ãŒç”Ÿã˜ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    vertex: {
      module: shaderModule,
*      buffers: [
*        // position
*        {
*          arrayStride: 3 * 4, // 3 floats, 4 bytes each
*          attributes: [
*            {shaderLocation: 0, offset: 0, format: 'float32x3'},
*          ],
*        },
*        // normals
*        {
*          arrayStride: 3 * 4, // 3 floats, 4 bytes each
*          attributes: [
*            {shaderLocation: 1, offset: 0, format: 'float32x3'},
*          ],
*        },
*        // texcoords
*        {
*          arrayStride: 2 * 4, // 2 floats, 4 bytes each
*          attributes: [
*            {shaderLocation: 2, offset: 0, format: 'float32x2',},
*          ],
*        },
*      ],
    },

...

  function createBuffer(device, values, usage) {
    const data = new Float32Array(values);
    const buffer = device.createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
    });
    const dst = new data.constructor(buffer.getMappedRange());
    dst.set(data);
    buffer.unmap();
    return buffer;
  }

  const positionBuffer = createBuffer(device, positions, GPUBufferUsage.VERTEX);
  const normalBuffer = createBuffer(device, normals, GPUBufferUsage.VERTEX);
  const texcoordBuffer = createBuffer(device, texcoords, GPUBufferUsage.VERTEX);

</pre>
<p>ã‚‚ã£ã¨é¢å€’ã§ã™ã€‚ğŸ˜®â€ğŸ’¨</p>
<p>ã¾ãŸã¯ã€ãã‚Œã‚‰ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã‚Œã¯ç°¡å˜ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ãã†ã§ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã™ã¹ã¦ãŒåŒã˜å‹ã€ãŸã¨ãˆã°ã™ã¹ã¦32ãƒ“ãƒƒãƒˆæµ®å‹•å°æ•°ç‚¹å€¤ã§ã‚ã‚‹å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ãªã“ã¨ãŒã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vertexData = [];

for (each vertex) {
  ...
  vertexData.push(
      x, y, z,
      nx, ny, nz,
      u, v);
}
</pre>
<p>ã—ã‹ã—ã€8ãƒ“ãƒƒãƒˆã®è‰²ãªã©ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã—ãŸã„ã¨æ€ã†ã¨ã€ã™ãã«é¢å€’ã«ãªã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const numVertices = ...;
const npmFloatsPerVertex = 3 + 3 + 2 + 1; // pos + nrm + uv + color()
const f32Data = new Float32Array(numFloatsPerVertex * numVertices);
const u8Data = new Uint8Array(f32Data.buffer);
const colorOffset = (3 + 3 + 2) * 4;

for (let i = 0; i &lt; numVertices; ++i) {
   const floatOffset = numFloatsPerVertex * i;
   f32Data.set(
      [
        x, y, z,
        nx, ny, nz,
        u, v,
      ],
      floatOffset);
   const u8Offset =numFloatsPerVertex * i * 4 + colorOffset;
   u8Data.set(
      [ r, g, b, a ],
      u8Offset;
   );
}
</pre>
<p>ãã—ã¦ã€ã¾ã çµ‚ã‚ã£ã¦ã„ã¾ã›ã‚“ã€‚ãã®ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«å…¥ã‚ŒãŸã¨ä»®å®šã™ã‚‹ã¨ã€ã¾ã ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    vertex: {
      module: shaderModule,
*      buffers: [
*        // position
*        {
*          arrayStride: (3 + 3 + 2 + 1) * 4,
*          attributes: [
*            {shaderLocation: 0, offset: 0,  format: 'float32x3'},
*            {shaderLocation: 1, offset: 12, format: 'float32x3'},
*            {shaderLocation: 2, offset: 24, format: 'float32x2'},
*            {shaderLocation: 3, offset: 32, format: 'unorm8x4'},
*          ],
*        },
*      ],
    ...
</pre>
<p>ã—ãŸãŒã£ã¦ã€ã„ãã¤ã‹ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ä½œæˆã™ã‚‹ã¨ã€ã“ã®é¢å€’ã•ã‚’å–ã‚Šé™¤ãã“ã¨ãŒã§ãã¾ã™ã€‚</p>
<p>ã“ã‚Œã‚’æ¸¡ã™é–¢æ•°ã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const positions = [];
const normals = [];
const texcoords = [];

const data = {
  positions,
  normals,
  texcoords,
};
</pre>
<p>ãã—ã¦ã€ãã‚Œã¯ç§ãŸã¡ã®ãŸã‚ã«ã™ã¹ã¦ã‚’ä½œæˆã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã—ã€ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®<code class="notranslate" translate="no">buffers</code>éƒ¨åˆ†ã‚’è¿”ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const {
  bufferLayouts,
  buffers,
  numElements
} = createBuffersAndAttributesFromArrays(device, data);
</pre>
<p>ã“ã‚Œã§ã€ãƒãƒƒãƒ•ã‚¡ã¯ã™ã§ã«ä½œæˆã•ã‚Œã¦ãŠã‚Šã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯1ã¤ã—ã‹ãªãã€ãƒ‡ãƒ¼ã‚¿ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãƒãƒƒãƒ•ã‚¡ã¯<code class="notranslate" translate="no">buffer[0]</code>ã§ã™ã€‚ã¾ãŸã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ãƒãƒƒãƒ•ã‚¡ã¨å‘¼ã°ã‚Œã‚‹éƒ¨åˆ†ã§ã‚ã‚‹<code class="notranslate" translate="no">bufferLayout</code>ã‚‚è¿”ã—ã¾ã—ãŸã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    vertex: {
      module: shaderModule,
*      buffers: bufferLayout
    },
    ...
</pre>
<p>ãã—ã¦ã€<code class="notranslate" translate="no">buffers</code>ãŒé…åˆ—ã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ã€å¿…è¦ã«å¿œã˜ã¦ã€æ¬¡ã®ã‚ˆã†ãªãƒãƒƒãƒ•ã‚¡ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜è¿°ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const pass = encoder.beginRenderPass(renderPassDescriptor);
    buffers.forEach((buffer, i) =&gt; pass.setVertexBuffer(i, buffer));
    ...
</pre>
<p>æ¬¡ã«ã€ãƒãƒƒãƒ•ã‚¡ãŒã•ã‚‰ã«ã‚ã‚‹ã‹ã©ã†ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
<p>TBD: ä¾‹ãŒå¿…è¦ã§ã™ã€‚æ—¢å­˜ã®ä¾‹ã«ã¯ã€å˜ç´”ã§ã‚ã‚ŠãªãŒã‚‰èˆˆå‘³æ·±ã„é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ãŒååˆ†ã«ã‚ã‚Šã¾ã›ã‚“ã€‚<a href="../../webgpu-cube.html">webgpu-cube</a>ã‚’é™¤ã„ã¦ã€ã“ã‚Œã¯WebGLã‹ã‚‰ã®WebGPUã«é–¢ã™ã‚‹è¨˜äº‹ã®ä¸€éƒ¨ã§ã‚ã‚Šã€ä¸é©åˆ‡ã«æ€ãˆã¾ã™ã€‚</p>
<p>ãŸã ã—ã€ã‹ãªã‚Šè‰¯ã„æ¯”è¼ƒã§ã™ã€‚</p>
<div class="webgpu_center compare">
  <div>
    <div>Raw WebGPU</div>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">  function createBuffer(device, data, usage) {
    const buffer = device.createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
    });
    const dst = new data.constructor(buffer.getMappedRange());
    dst.set(data);
    buffer.unmap();
    return buffer;
  }

  const positions = new Float32Array([1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]);
  const normals   = new Float32Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
  const texcoords = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
  const indices   = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);

  const positionBuffer = createBuffer(device, positions, GPUBufferUsage.VERTEX);
  const normalBuffer = createBuffer(device, normals, GPUBufferUsage.VERTEX);
  const texcoordBuffer = createBuffer(device, texcoords, GPUBufferUsage.VERTEX);
  const indicesBuffer = createBuffer(device, indices, GPUBufferUsage.INDEX);

  const pipeline = device.createRenderPipeline({
    label: 'fake lighting',
    layout: 'auto',
    vertex: {
      module: shaderModule,
      buffers: [
        // position
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},
          ],
        },
        // normals
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [
            {shaderLocation: 1, offset: 0, format: 'float32x3'},
          ],
        },
        // texcoords
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [
            {shaderLocation: 2, offset: 0, format: 'float32x2',},
          ],
        },
      ],
    },
    fragment: {
      module: shaderModule,
      targets: [
        {format: presentationFormat},
      ],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
    ...(canvasInfo.sampleCount &gt; 1 &amp;&amp; {
        multisample: {
          count: canvasInfo.sampleCount,
        },
    }),
  });

  ...

    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.setVertexBuffer(0, positionBuffer);
    passEncoder.setVertexBuffer(1, normalBuffer);
    passEncoder.setVertexBuffer(2, texcoordBuffer);
    passEncoder.setIndexBuffer(indicesBuffer, 'uint16');
    passEncoder.drawIndexed(indices.length);
    passEncoder.end();
    device.queue.submit([commandEncoder.finish()]);
</pre>
  </div>
  <div>
    <div>WebGPU Utils</div>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">  const {
    buffers: [vertexBuffer],
    bufferLayouts,
    indexBuffer,
    indexFormat,
    numElements,
  } = createBuffersAndAttributesFromArrays(
    device, {
      positions: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],
      normals: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
      texcoords: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],
    });

  const pipeline = device.createRenderPipeline({
    label: 'fake lighting',
    layout: 'auto',
    vertex: {
      module: shaderModule,
      buffers: bufferLayouts,
    },
    fragment: {
      module: shaderModule,
      targets: [
        {format: presentationFormat},
      ],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
    ...(canvasInfo.sampleCount &gt; 1 &amp;&amp; {
        multisample: {
          count: canvasInfo.sampleCount,
        },
    }),
  });

...

    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.setVertexBuffer(0, vertexBuffer);
    passEncoder.setIndexBuffer(indexBuffer, indexFormat);
    passEncoder.drawIndexed(numElements);
    passEncoder.end();
    device.queue.submit([commandEncoder.finish()]);
</pre>
  </div>
</div>
<p><a href="../webgpu-vertex-buffers.html#a-normalized-attributes">é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã®8ãƒ“ãƒƒãƒˆã®è‰²ã‚’ä½¿ç”¨ã™ã‚‹ä¾‹ã®ã‚ˆã†ãªã€ã‚ˆã‚Šè¤‡é›‘ãªä¾‹ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ã€‚3ã¤ã®ãƒãƒƒãƒ•ã‚¡ãŒã‚ã‚Šã¾ã—ãŸã€‚1ã¤ã¯ä½ç½®ã¨é ‚ç‚¹ã”ã¨ã®è‰²ç”¨ã§ã™ã€‚1ã¤ã¯å††ã”ã¨ã®è‰²ã¨å††ã”ã¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆç”¨ã§ã€æœ€å¾Œã®1ã¤ã¯ã‚¹ã‚±ãƒ¼ãƒ«ç”¨ã§ã™ã€‚</p>
<p><code class="notranslate" translate="no">createBuffersAndAttributesFromArrays</code>ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚</p>
<p>ã¾ãšã€å††ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
-  // 1ã¤ã®ã‚µãƒ–ãƒ‡ã‚£ãƒ“ã‚¸ãƒ§ãƒ³ã‚ãŸã‚Š2ã¤ã®ä¸‰è§’å½¢ã€1ã¤ã®ä¸‰è§’å½¢ã‚ãŸã‚Š3ã¤ã®é ‚ç‚¹
-  const numVertices = numSubdivisions * 3 * 2;
-  // ä½ç½®ï¼ˆxyï¼‰ã«2ã¤ã®32ãƒ“ãƒƒãƒˆå€¤ã€è‰²ï¼ˆrgb_ï¼‰ã«1ã¤ã®32ãƒ“ãƒƒãƒˆå€¤
-  // 32ãƒ“ãƒƒãƒˆã®è‰²å€¤ã¯ã€4ã¤ã®8ãƒ“ãƒƒãƒˆå€¤ã¨ã—ã¦æ›¸ãè¾¼ã¿/èª­ã¿å–ã‚Šã•ã‚Œã¾ã™
-  const vertexData = new Float32Array(numVertices * (2 + 1));
-  const colorData = new Uint8Array(vertexData.buffer);

+  const positions = [];
+  const colors = [];

-  let offset = 0;
-  let colorOffset = 8;
  const addVertex = (x, y, r, g, b) =&gt; {
-    vertexData[offset++] = x;
-    vertexData[offset++] = y;
-    offset += 1;  // è‰²ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™
-    colorData[colorOffset++] = r * 255;
-    colorData[colorOffset++] = g * 255;
-    colorData[colorOffset++] = b * 255;
-    colorOffset += 9;  // ä½™åˆ†ãªãƒã‚¤ãƒˆã¨ä½ç½®ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™
+    positions.push(x, y);
+    colors.push(r, g, b, 1);
  };

  const innerColor = [1, 1, 1];
  const outerColor = [0.1, 0.1, 0.1];

  // 1ã¤ã®ã‚µãƒ–ãƒ‡ã‚£ãƒ“ã‚¸ãƒ§ãƒ³ã‚ãŸã‚Š2ã¤ã®é ‚ç‚¹
  //
  // 0--1 4
  // | / /|
  // |/ / |
  // 2 3--5
  for (let i = 0; i &lt; numSubdivisions; ++i) {
    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;

    const c1 = Math.cos(angle1);
    const s1 = Math.sin(angle1);
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);

    // æœ€åˆã®ä¸‰è§’å½¢
    addVertex(c1 * radius, s1 * radius, ...outerColor);
    addVertex(c2 * radius, s2 * radius, ...outerColor);
    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);

    // 2ç•ªç›®ã®ä¸‰è§’å½¢
    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
    addVertex(c2 * radius, s2 * radius, ...outerColor);
    addVertex(c2 * innerRadius, s2 * innerRadius, ...innerColor);
  }

  return {
-    vertexData,
-    numVertices,
+    positions: { data: positions, numComponents: 2 },
+    colors,
  };
}
</pre>
<p>ãã‚Œã§ã€ãã‚Œã¯ã‚ˆã‚Šå˜ç´”ã«ãªã‚Šã¾ã—ãŸã€‚</p>
<p>é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®šã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">  const kNumObjects = 100;
  const objectInfos = [];

-  // 2ã¤ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¾ã™
-  const staticUnitSize =
-    4 +     // colorã¯4ãƒã‚¤ãƒˆã§ã™
-    2 * 4;  // offsetã¯2ã¤ã®32ãƒ“ãƒƒãƒˆæµ®å‹•å°æ•°ç‚¹æ•°ï¼ˆå„4ãƒã‚¤ãƒˆï¼‰ã§ã™
-  const changingUnitSize =
-    2 * 4;  // scaleã¯2ã¤ã®32ãƒ“ãƒƒãƒˆæµ®å‹•å°æ•°ç‚¹æ•°ï¼ˆå„4ãƒã‚¤ãƒˆï¼‰ã§ã™
-  const staticVertexBufferSize = staticUnitSize * kNumObjects;
-  const changingVertexBufferSize = changingUnitSize * kNumObjects;
-
-  const staticVertexBuffer = device.createBuffer({
-    label: 'static vertex for objects',
-    size: staticVertexBufferSize,
-    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
-  });
-
-  const changingVertexBuffer = device.createBuffer({
-    label: 'changing storage for objects',
-    size: changingVertexBufferSize,
-    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
-  });
-
-  // float32ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã•ã¾ã–ã¾ãªãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
-  const kColorOffset = 0;
-  const kOffsetOffset = 1;

  const kScaleOffset = 0;

-  {
-    const staticVertexValuesU8 = new Uint8Array(staticVertexBufferSize);
-    const staticVertexValuesF32 = new Float32Array(staticVertexValuesU8.buffer);
+  const staticColors = [];
+  const staticOffsets = [];

    for (let i = 0; i &lt; kNumObjects; ++i) {
-      const staticOffsetU8 = i * staticUnitSize;
-      const staticOffsetF32 = staticOffsetU8 / 4;
-
-      // ã“ã‚Œã‚‰ã¯ä¸€åº¦ã ã‘è¨­å®šã•ã‚Œã‚‹ã®ã§ã€ä»Šã™ãè¨­å®šã—ã¾ã™
-      staticVertexValuesU8.set(        // è‰²ã‚’è¨­å®šã—ã¾ã™
-          [rand() * 255, rand() * 255, rand() * 255, 255],
-          staticOffsetU8 + kColorOffset);
-
-      staticVertexValuesF32.set(      // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®šã—ã¾ã™
-          [rand(-0.9, 0.9), rand(-0.9, 0.9)],
-          staticOffsetF32 + kOffsetOffset);
+      staticColors.push(rand() * 255, rand() * 255, rand() * 255, 255);
+      staticOffsets.push(rand(-0.9, 0.9), rand(-0.9, 0.9));

      objectInfos.push({
        scale: rand(0.2, 0.5),
      });
    }
-    device.queue.writeBuffer(staticVertexBuffer, 0, staticVertexValuesF32);
-  }

  const {
    buffers: [staticVertexBuffer],
    bufferLayouts: [staticVertexBufferLayout],
  } = createBuffersAndAttributesFromArrays(device, {
    staticOffsets: { data: staticOffsets, numComponents: 2 },
    staticColors: new Uint8Array(staticColors),
  }, {stepMode: 'instance', shaderLocation: 2});

  const {
    buffers: [changingVertexBuffer],
    bufferLayouts: [changingVertexBufferLayout],
  } = createBuffersAndAttributesFromArrays(device, {
    scale: { data: kNumObjects * 2, numComponents: 2 },
  }, { stepMode: 'instance', shaderLocation: 4, usage: GPUBufferUsage.COPY_DST });

+  const vertexValues = new Float32Array(changingVertexBuffer.size / 4);
+  const changingUnitSize = 8;

-  // changingStorageBufferã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹å‹ä»˜ãé…åˆ—
-  const vertexValues = new Float32Array(changingVertexBufferSize / 4);
-
-  const { vertexData, numVertices } = createCircleVertices({
-    radius: 0.5,
-    innerRadius: 0.25,
-  });
-  const vertexBuffer = device.createBuffer({
-    label: 'vertex buffer vertices',
-    size: vertexData.byteLength,
-    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
-  });
-  device.queue.writeBuffer(vertexBuffer, 0, vertexData);

+  const vertexArrays = createCircleVertices({
+    radius: 0.5,
+    innerRadius: 0.25,
+  });
+  const {
+    buffers: [vertexBuffer],
+    numElements,
+    bufferLayouts: [vertexBufferLayout],
+  } = createBuffersAndAttributesFromArrays(device, vertexArrays);
</pre>
<p>ãã‚Œã¯ã¯ã‚‹ã‹ã«å°ã•ããªã‚Šã¾ã—ãŸã€‚</p>
<p>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’è¨­å®šã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'per vertex color',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
-        {
-          arrayStride: 2 * 4 + 4, // 2 floats, 4 bytes each + 4 bytes
-          attributes: [
-            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
-            {shaderLocation: 4, offset: 8, format: 'unorm8x4'},   // perVertexColor
-          ],
-        },
-        {
-          arrayStride: 4 + 2 * 4, // 4 bytes + 2 floats, 4 bytes each
-          stepMode: 'instance',
-          attributes: [
-            {shaderLocation: 1, offset: 0, format: 'unorm8x4'},   // color
-            {shaderLocation: 2, offset: 4, format: 'float32x2'},  // offset
-          ],
-        },
-        {
-          arrayStride: 2 * 4, // 2 floats, 4 bytes each
-          stepMode: 'instance',
-          attributes: [
-            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
-          ],
-        },
+        vertexBufferLayout,
+        staticVertexBufferLayout,
+        changingVertexBufferLayout,
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>ãã‚Œã§ã€ãã‚Œã¯ã‚ˆã‚Šå˜ç´”ã§ã™ã€‚</p>
<p>ãã‚Œã¯å‹åˆ©ã§ã™ã‹ï¼Ÿã‚ãªãŸãŒæ±ºã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<p>ãŸã ã—ã€ä»Šå¾Œã¯ã€ä¸€éƒ¨ã®ä¾‹ã§ã¯ã€è¨˜äº‹ãŒæœ¬å½“ã«ä½•ã«ã¤ã„ã¦ã§ã‚ã‚‹ã‹ã«é›†ä¸­ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’ä½¿ç”¨ã—å§‹ã‚ã¾ã™ã€‚ã“ã‚Œã‚‰ã®è©³ç´°ã§é›‘è‰ã«è¿·ã†ã®ã§ã¯ãªãã€‚ã“ã®è¨˜äº‹ãŒã€ã“ã‚Œã‚‰ã®é–¢æ•°ãŒä½•ã‚’ã™ã‚‹ã®ã‹ã‚’ã‚ˆã‚Šæ˜ç¢ºã«ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã“ã¨ã‚’é¡˜ã£ã¦ã„ã¾ã™ã€‚ãã‚Œã‚‰ã¯ã€ã™ã§ã«èª¬æ˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ä»¥å¤–ã¯ä½•ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã‚’è¦‹ãŸã¨ãã€</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const sphereData = createBuffersAndAttributesFromArrays(
   device,
   createSphereVertices(radius),
);
</pre>
<p>ã“ã®ã‚µã‚¤ãƒˆã«ã¯ã€<code class="notranslate" translate="no">createBuffersAndAttributesFromArrays</code>ãŒä½•ã‚’æ„å‘³ã™ã‚‹ã®ã‹ã‚’èª¬æ˜ã™ã‚‹30ã€œ40ã®è¨˜äº‹ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã«ã¤ã„ã¦æ€–ã„ã“ã¨ã‚„ç†è§£ã—ã«ãã„ã“ã¨ã¯ä½•ã‚‚ãªã„ã“ã¨ã‚’é¡˜ã£ã¦ã„ã¾ã™ã€‚æ¦‚å¿µã‚’èª¬æ˜ã—ã€ãã‚Œã«åå‰ã‚’ä»˜ã‘ã€åå‰ã§å‚ç…§ã™ã‚‹ã ã‘ã¨ã„ã†ã®ã¯ã€å­¦ç¿’ã®æ¨™æº–ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ˆã‚Šé«˜ã„ãƒ¬ãƒ™ãƒ«ã®æ¦‚å¿µã‚’ã‚ˆã‚Šç°¡å˜ã«æ§‹ç¯‰ã§ãã¾ã™ã€‚</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-utils.html">English
    </option><option value="/webgpu/lessons/es/webgpu-utils.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-utils.html" selected="">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-utils.html">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-utils.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-utils.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-utils.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-utils.html">ç®€ä½“ä¸­æ–‡
</option></select>


        <div id="toc">
          <ul>  <li>åŸºæœ¬</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">åŸºæœ¬</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stageå¤‰æ•°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ </a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒƒãƒ•ã‚¡</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡</a></li>
  <li>ãƒ†ã‚¯ã‚¹ãƒãƒ£</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">ãƒ†ã‚¯ã‚¹ãƒãƒ£</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">ç”»åƒã®èª­ã¿è¾¼ã¿</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ãƒ“ãƒ‡ã‚ªã®ä½¿ç”¨</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ†ã‚¯ã‚¹ãƒãƒ£</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">å®šæ•°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">æ§‹é€ ä½“ã¨ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">é€æ˜åº¦ã¨ãƒ–ãƒ¬ãƒ³ãƒ‡ã‚£ãƒ³ã‚°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã¨åˆ¶é™</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">ä»•çµ„ã¿</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">äº’æ›ãƒ¢ãƒ¼ãƒ‰</a></li>
        </ul>
  <li>3Dã®æ•°å­¦</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">å¹³è¡Œç§»å‹•</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">å›è»¢</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">ã‚¹ã‚±ãƒ¼ãƒ«</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">è¡Œåˆ—æ¼”ç®—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">æ­£å°„å½±</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">é€è¦–æŠ•å½±</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">ã‚«ãƒ¡ãƒ©</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">è¡Œåˆ—ã‚¹ã‚¿ãƒƒã‚¯</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">ã‚·ãƒ¼ãƒ³ã‚°ãƒ©ãƒ•</a></li>
        </ul>
  <li>ãƒ©ã‚¤ãƒˆ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">æŒ‡å‘æ€§ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">ç‚¹å…‰æº</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ</a></li>
        </ul>
  <li>ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">å¤§ããªã‚¯ãƒªãƒƒãƒ—ç©ºé–“ã®ä¸‰è§’å½¢</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">ç’°å¢ƒãƒãƒƒãƒ—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹</a></li>
        </ul>
  <li>ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">åŸºæœ¬çš„ãªCRTã‚¨ãƒ•ã‚§ã‚¯ãƒˆ</a></li>
        </ul>
        </ul>
  <li>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆã‚·ã‚§ãƒ¼ãƒ€</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®åŸºæœ¬</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">ç”»åƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">ç”»åƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ  ãƒ‘ãƒ¼ãƒˆ2</a></li>
        </ul>
  <li>ãã®ä»–ã®ãƒˆãƒ”ãƒƒã‚¯</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">è¤‡æ•°ã®ã‚­ãƒ£ãƒ³ãƒã‚¹</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ãƒã‚¤ãƒ³ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLã‹ã‚‰WebGPUã¸</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">é€Ÿåº¦ã¨æœ€é©åŒ–</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">ãƒ‡ãƒãƒƒã‚°ã¨ã‚¨ãƒ©ãƒ¼</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">ãƒªã‚½ãƒ¼ã‚¹ / å‚è€ƒæ–‡çŒ®</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL é–¢æ•°ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—æ©Ÿ</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>å•é¡Œç‚¹/ãƒã‚°? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubã§issueã‚’ä½œæˆ</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Utilsã¨wgpu-matrix`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>