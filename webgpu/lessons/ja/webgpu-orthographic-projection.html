<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-orthographic-projection.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="正射影（遠近法なし）">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-orthographic-projection_ja.jpg">

<meta property="og:title" content="WebGPU 正射影">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-orthographic-projection_ja.jpg">
<meta property="og:description" content="正射影（遠近法なし）">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 正射影">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html">
<meta name="twitter:description" content="正射影（遠近法なし）">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-orthographic-projection_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-orthographic-projection_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html",
      "inLanguage":"ja",
      "name":"WebGPU 正射影",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-orthographic-projection.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 正射影</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-orthographic-projection.html">English
    </option><option value="/webgpu/lessons/es/webgpu-orthographic-projection.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-orthographic-projection.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-orthographic-projection.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-orthographic-projection.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-orthographic-projection.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-orthographic-projection.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 正射影</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>この記事は、3D数学について学ぶことを目的とした一連の記事の5番目です。各記事は前のレッスンを基にしているので、順番に読むと最も理解しやすいかもしれません。</p>
<ol>
<li><a href="webgpu-translation.html">平行移動</a></li>
<li><a href="webgpu-rotation.html">回転</a></li>
<li><a href="webgpu-scale.html">スケーリング</a></li>
<li><a href="webgpu-matrix-math.html">行列演算</a></li>
<li><a href="webgpu-orthographic-projection.html">正射影</a> ⬅ ここです</li>
<li><a href="webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="webgpu-cameras.html">カメラ</a></li>
<li><a href="webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="webgpu-scene-graphs.html">シーングラフ</a></li>
</ol>
<p>前回の投稿では、行列がどのように機能するかについて説明しました。平行移動、回転、スケーリング、さらにはピクセルからクリップ空間への射影まで、すべて1つの行列といくつかの魔法の行列演算で実行できることについて話しました。3Dを行うには、そこからほんの少しのステップです。</p>
<p>前の2Dの例では、3x3行列で乗算した2D点（x、y）がありました。3Dを行うには、3D点（x、y、z）と4x4行列が必要です。</p>
<p>最後の例を取り上げて、3Dに変更しましょう。もう一度Fを使用しますが、今回は3Dの「F」です。</p>
<p>最初に行う必要があるのは、頂点シェーダーを3Dを処理するように変更することです。これが古い頂点シェーダーです。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  color: vec4f,
-  matrix: mat3x3f,
+  matrix: mat4x4f,
};

struct Vertex {
-  @location(0) position: vec2f,
+  @location(0) position: vec4f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(vert: Vertex) -&gt; VSOutput {
  var vsOut: VSOutput;
-
-  let clipSpace = (uni.matrix * vec3f(vert.position, 1)).xy;
-  vsOut.position = vec4f(clipSpace, 0.0, 1.0);
  vsOut.position = uni.matrix * vert.position;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return uni.color;
}
</pre>
<p>さらに単純になりました！2Dで<code class="notranslate" translate="no">x</code>と<code class="notranslate" translate="no">y</code>を指定し、<code class="notranslate" translate="no">z</code>を1に設定したように、3Dでは<code class="notranslate" translate="no">x</code>、<code class="notranslate" translate="no">y</code>、<code class="notranslate" translate="no">z</code>を指定し、<code class="notranslate" translate="no">w</code>が1である必要がありますが、属性の<code class="notranslate" translate="no">w</code>がデフォルトで1であるという事実を利用できます。</p>
<p>次に、3Dデータを提供する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createFVertices() {
  const vertexData = new Float32Array([
    // 左列
*    0, 0, 0,
*    30, 0, 0,
*    0, 150, 0,
*    30, 150, 0,

    // 上の横木
*    30, 0, 0,
*    100, 0, 0,
*    30, 30, 0,
*    100, 30, 0,

    // 中間の横木
*    30, 60, 0,
*    70, 60, 0,
*    30, 90, 0,
*    70, 90, 0,
  ]);

  const indexData = new Uint32Array([
    0,  1,  2,    2,  1,  3,  // 左列
    4,  5,  6,    6,  5,  7,  // 上の横木
    8,  9, 10,   10,  9, 11,  // 中間の横木
  ]);

  return {
    vertexData,
    indexData,
    numVertices: indexData.length,
  };
}
</pre>
<p>上記では、各行の末尾に<code class="notranslate" translate="no"> 0,</code>を追加しただけです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: (2) * 4, // (2) floats, 4 bytes each
+          arrayStride: (3) * 4, // (3) floats, 4 bytes each
          attributes: [
-            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
+            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>次に、すべての行列演算を2Dから3Dに変更する必要があります。</p>
<div class="webgpu_center compare" style="align-items: end;">
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">1</td>
          <td class="m12">0</td>
          <td class="m13">tx</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">1</td>
          <td class="m23">ty</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>2D平行移動行列</div>
  </div>
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">1</td>
          <td class="m12">0</td>
          <td class="m13">0</td>
          <td class="m14">tx</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">1</td>
          <td class="m23">0</td>
          <td class="m24">ty</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">1</td>
          <td class="m34">tz</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>3D平行移動行列</div>
  </div>
</div>
<div class="webgpu_center compare" style="align-items: end;">
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">c</td>
          <td class="m12">-s</td>
          <td class="m13">0</td>
        </tr>
        <tr>
          <td class="m21">s</td>
          <td class="m22">c</td>
          <td class="m23">0</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>2D回転行列</div>
  </div>
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">c</td>
          <td class="m12">-s</td>
          <td class="m13">0</td>
          <td class="m14">0</td>
        </tr>
        <tr>
          <td class="m21">s</td>
          <td class="m22">c</td>
          <td class="m23">0</td>
          <td class="m24">0</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">1</td>
          <td class="m34">0</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>3D回転Z行列</div>
  </div>
</div>
<div class="webgpu_center compare" style="align-items: end;">
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">sx</td>
          <td class="m12">0</td>
          <td class="m13">0</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">sy</td>
          <td class="m23">0</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>2Dスケーリング行列</div>
  </div>
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">sx</td>
          <td class="m12">0</td>
          <td class="m13">0</td>
          <td class="m14">0</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">sy</td>
          <td class="m23">0</td>
          <td class="m24">0</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">0</td>
          <td class="m33">sz</td>
          <td class="m34">0</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>3Dスケーリング行列</div>
  </div>
</div>
<p>XおよびY回転行列も作成できます。</p>
<div class="webgpu_center compare" style="align-items: end;">
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">1</td>
          <td class="m12">0</td>
          <td class="m13">0</td>
          <td class="m14">0</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">c</td>
          <td class="m23">-s</td>
          <td class="m24">0</td>
        </tr>
        <tr>
          <td class="m31">0</td>
          <td class="m32">s</td>
          <td class="m33">c</td>
          <td class="m34">0</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>3D回転X行列</div>
  </div>
  <div>
    <div class="glocal-center">
      <table class="glocal-center-content glocal-mat">
        <tbody><tr>
          <td class="m11">c</td>
          <td class="m12">0</td>
          <td class="m13">s</td>
          <td class="m14">0</td>
        </tr>
        <tr>
          <td class="m21">0</td>
          <td class="m22">1</td>
          <td class="m23">0</td>
          <td class="m24">0</td>
        </tr>
        <tr>
          <td class="m31">-s</td>
          <td class="m32">0</td>
          <td class="m33">c</td>
          <td class="m34">0</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody></table>
    </div>
    <div>3D回転Y行列</div>
  </div>
</div>
<p>これで3つの回転行列ができました。2Dでは、事実上Z軸を中心にしか回転していなかったので、1つしか必要ありませんでした。しかし、3Dを行うには、X軸とY軸を中心に回転できる必要もあります。それらを見ると、すべて非常によく似ていることがわかります。それらを計算すると、以前と同じように単純化されることがわかります。</p>
<p>Z回転</p>
<div class="webgpu_center"><pre class="webgpu_math">newX = x * c + y * -s;
newY = x * s + y *  c;
</pre></div>
<p>Y回転</p>
<div class="webgpu_center"><pre class="webgpu_math">newX = x *  c + z * s;
newZ = x * -s + z * c;
</pre></div>
<p>X回転</p>
<div class="webgpu_center"><pre class="webgpu_math">newY = y * c + z * -s;
newZ = y * s + z *  c;
</pre></div>
<p>これにより、これらの回転が得られます。</p>
<iframe class="external_diagram" src="../resources/axis-diagram.html" style="width: 540px; height: 280px;"></iframe>
<p>これは、<code class="notranslate" translate="no">mat3.translation</code>、<code class="notranslate" translate="no">mat3.rotation</code>、<code class="notranslate" translate="no">mat3.scaling</code>の2D（以前の）バージョンです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat3 = {
  ...
  translation([tx, ty], dst) {
    dst = dst || new Float32Array(12);
    dst[0] = 1;   dst[1] = 0;   dst[2] = 0;
    dst[4] = 0;   dst[5] = 1;   dst[6] = 0;
    dst[8] = tx;  dst[9] = ty;  dst[10] = 1;
    return dst;
  },

  rotation(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(12);
    dst[0] = c;   dst[1] = s;  dst[2] = 0;
    dst[4] = -s;  dst[5] = c;  dst[6] = 0;
    dst[8] = 0;   dst[9] = 0;  dst[10] = 1;
    return dst;

  },

  scaling([sx, sy], dst) {
    dst = dst || new Float32Array(12);
    dst[0] = sx;  dst[1] = 0;   dst[2] = 0;
    dst[4] = 0;   dst[5] = sy;  dst[6] = 0;
    dst[8] = 0;   dst[9] = 0;   dst[10] = 1;
    return dst;
  },
  ...
</pre>
<p>そして、更新された3Dバージョンは次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
  translation([tx, ty, tz], dst) {
    dst = dst || new Float32Array(16);
    dst[ 0] = 1;   dst[ 1] = 0;   dst[ 2] = 0;   dst[ 3] = 0;
    dst[ 4] = 0;   dst[ 5] = 1;   dst[ 6] = 0;   dst[ 7] = 0;
    dst[ 8] = 0;   dst[ 9] = 0;   dst[10] = 1;   dst[11] = 0;
    dst[12] = tx;  dst[13] = ty;  dst[14] = tz;  dst[15] = 1;
    return dst;
  },

  rotationX(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[ 0] = 1;  dst[ 1] = 0;   dst[ 2] = 0;  dst[ 3] = 0;
    dst[ 4] = 0;  dst[ 5] = c;   dst[ 6] = s;  dst[ 7] = 0;
    dst[ 8] = 0;  dst[ 9] = -s;  dst[10] = c;  dst[11] = 0;
    dst[12] = 0;  dst[13] = 0;   dst[14] = 0;  dst[15] = 1;
    return dst;
  },

  rotationY(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[ 0] = c;  dst[ 1] = 0;  dst[ 2] = -s;  dst[ 3] = 0;
    dst[ 4] = 0;  dst[ 5] = 1;  dst[ 6] = 0;   dst[ 7] = 0;
    dst[ 8] = s;  dst[ 9] = 0;  dst[10] = c;   dst[11] = 0;
    dst[12] = 0;  dst[13] = 0;  dst[14] = 0;   dst[15] = 1;
    return dst;
  },

  rotationZ(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[ 0] = c;   dst[ 1] = s;  dst[ 2] = 0;  dst[ 3] = 0;
    dst[ 4] = -s;  dst[ 5] = c;  dst[ 6] = 0;  dst[ 7] = 0;
    dst[ 8] = 0;   dst[ 9] = 0;  dst[10] = 1;  dst[11] = 0;
    dst[12] = 0;   dst[13] = 0;  dst[14] = 0;   dst[15] = 1;
    return dst;
  },

  scaling([sx, sy, sz], dst) {
    dst = dst || new Float32Array(16);
    dst[ 0] = sx;  dst[ 1] = 0;   dst[ 2] = 0;    dst[ 3] = 0;
    dst[ 4] = 0;   dst[ 5] = sy;  dst[ 6] = 0;    dst[ 7] = 0;
    dst[ 8] = 0;   dst[ 9] = 0;   dst[10] = sz;   dst[11] = 0;
    dst[12] = 0;   dst[13] = 0;   dst[14] = 0;    dst[15] = 1;
    return dst;
  },
  ...
</pre>
<p>同様に、単純化された関数を作成します。これは2Dのものです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  translate(m, translation, dst) {
    return mat3.multiply(m, mat3.translation(translation), dst);
  },

  rotate(m, angleInRadians, dst) {
    return mat3.multiply(m, mat3.rotation(angleInRadians), dst);
  },

  scale(m, scale, dst) {
    return mat3.multiply(m, mat3.scaling(scale), dst);
  },
</pre>
<p>そして、3Dのものです。<code class="notranslate" translate="no">mat4</code>と名付け、さらに2つの回転関数を追加した以外は、あまり変更はありません。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  translate(m, translation, dst) {
    return mat4.multiply(m, mat4.translation(translation), dst);
  },

  rotateX(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationX(angleInRadians), dst);
  },

  rotateY(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationY(angleInRadians), dst);
  },

  rotateZ(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationZ(angleInRadians), dst);
  },

  scale(m, scale, dst) {
    return mat4.scaling(m, mat4.scaling(scale), dst);
  },
  ...
</pre>
<p>そして、4x4行列の乗算関数が必要です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  multiply(a, b, dst) {
    dst = dst || new Float32Array(16);
    const b00 = b[0 * 4 + 0];
    const b01 = b[0 * 4 + 1];
    const b02 = b[0 * 4 + 2];
    const b03 = b[0 * 4 + 3];
    const b10 = b[1 * 4 + 0];
    const b11 = b[1 * 4 + 1];
    const b12 = b[1 * 4 + 2];
    const b13 = b[1 * 4 + 3];
    const b20 = b[2 * 4 + 0];
    const b21 = b[2 * 4 + 1];
    const b22 = b[2 * 4 + 2];
    const b23 = b[2 * 4 + 3];
    const b30 = b[3 * 4 + 0];
    const b31 = b[3 * 4 + 1];
    const b32 = b[3 * 4 + 2];
    const b33 = b[3 * 4 + 3];
    const a00 = a[0 * 4 + 0];
    const a01 = a[0 * 4 + 1];
    const a02 = a[0 * 4 + 2];
    const a03 = a[0 * 4 + 3];
    const a10 = a[1 * 4 + 0];
    const a11 = a[1 * 4 + 1];
    const a12 = a[1 * 4 + 2];
    const a13 = a[1 * 4 + 3];
    const a20 = a[2 * 4 + 0];
    const a21 = a[2 * 4 + 1];
    const a22 = a[2 * 4 + 2];
    const a23 = a[2 * 4 + 3];
    const a30 = a[3 * 4 + 0];
    const a31 = a[3 * 4 + 1];
    const a32 = a[3 * 4 + 2];
    const a33 = a[3 * 4 + 3];

    dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
    dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
    dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
    dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;

    dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
    dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
    dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
    dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;

    dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
    dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
    dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
    dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;

    dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
    dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
    dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
    dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

    return dst;
  },
</pre>
<p>また、射影関数を更新する必要があります。これが古いものです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  projection(width, height, dst) {
    // 注：この行列はY軸を反転させるため、0が上になります。
    dst = dst || new Float32Array(12);
    dst[0] = 2 / width;  dst[1] = 0;             dst[2] = 0;
    dst[4] = 0;          dst[5] = -2 / height;   dst[6] = 0;
    dst[8] = -1;         dst[9] = 1;             dst[10] = 1;
    return dst;
  },
</pre>
<p>これは、ピクセルからクリップ空間に変換しました。3Dに拡張する最初の試みとして、次のように試してみましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  projection(width, height, depth, dst) {
    // 注：この行列はY軸を反転させるため、0が上になります。
    dst = dst || new Float32Array(16);
    dst[ 0] = 2 / width;  dst[ 1] = 0;            dst[ 2] = 0;          dst[ 3] = 0;
    dst[ 4] = 0;          dst[ 5] = -2 / height;  dst[ 6] = 0;          dst[ 7] = 0;
    dst[ 8] = 0;          dst[ 9] = 0;            dst[10] = 0.5 / depth;  dst[11] = 0;
    dst[12] = -1;         dst[13] = 1;            dst[14] = 0.5;          dst[15] = 1;
    return dst;
  },
</pre>
<p>XとYでピクセルからクリップ空間に変換する必要があったように、Zでも同じことを行う必要があります。この場合、Z軸も「ピクセル単位」にしていますか？<code class="notranslate" translate="no">depth</code>に<code class="notranslate" translate="no">width</code>と同様の値を渡すので、空間は幅0から<code class="notranslate" translate="no">width</code>ピクセル、高さ0から<code class="notranslate" translate="no">height</code>ピクセルになりますが、<code class="notranslate" translate="no">depth</code>の場合は<code class="notranslate" translate="no">-depth / 2</code>から<code class="notranslate" translate="no">+depth / 2</code>になります。</p>
<p>ユニフォームに4x4行列を提供する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 色、行列
-  const uniformBufferSize = (4 + 12) * 4;
+  const uniformBufferSize = (4 + 16) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // float32インデックスでのさまざまなユニフォーム値へのオフセット
  const kColorOffset = 0;
  const kMatrixOffset = 4;

  const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
-  const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 12);
+  const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);
</pre>
<p>そして、行列を計算するコードを更新する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no"> const settings = {
-    translation: [150, 100],
-    rotation: degToRad(30),
-    scale: [1, 1],
+    translation: [45, 100, 0],
+    rotation: [degToRad(40), degToRad(25), degToRad(325)],
+    scale: [1, 1, 1],
  };

  ...

  function render() {
    ...

-    mat3.projection(canvas.clientWidth, canvas.clientHeight, matrixValue);
-    mat3.translate(matrixValue, settings.translation, matrixValue);
-    mat3.rotate(matrixValue, settings.rotation, matrixValue);
-    mat3.scale(matrixValue, settings.scale, matrixValue);
+    mat4.projection(canvas.clientWidth, canvas.clientHeight, 400, matrixValue);
+    mat4.translate(matrixValue, settings.translation, matrixValue);
+    mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
+    mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
+    mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
+    mat4.scale(matrixValue, settings.scale, matrixValue);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-1-flat-f.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-1-flat-f.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>最初の問題は、データが平らなFであるため、3Dであることがわかりにくいことです。これを修正するには、データを3Dに拡張しましょう。現在のFは、それぞれ2つの三角形の3つの長方形で構成されています。3Dにするには、合計16個の長方形が必要です。前面に3つ、背面に3つ、左側に1つ、右側に4つ、上面に2つ、下面に3つです。</p>
<img class="webgpu_center noinvertdark" style="width: 400px;" src="../resources/3df.svg">
<p>現在のすべての頂点位置を取得して複製し、Z方向に移動してから、それらをすべてインデックスで接続するだけです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createFVertices() {
  const vertexData = new Float32Array([
    // 左列
    0, 0, 0,
    30, 0, 0,
    0, 150, 0,
    30, 150, 0,

    // 上の横木
    30, 0, 0,
    100, 0, 0,
    30, 30, 0,
    100, 30, 0,

    // 中間の横木
    30, 60, 0,
    70, 60, 0,
    30, 90, 0,
    70, 90, 0,

+    // 左列の裏
+    0, 0, 30,
+    30, 0, 30,
+    0, 150, 30,
+    30, 150, 30,
+
+    // 上の横木の裏
+    30, 0, 30,
+    100, 0, 30,
+    30, 30, 30,
+    100, 30, 30,
+
+    // 中間の横木の裏
+    30, 60, 30,
+    70, 60, 30,
+    30, 90, 30,
+    70, 90, 30,
-  ]);
+  ];

-  const indexData = new Uint32Array([
+  const indices = [
    // 前面
    0,  1,  2,    2,  1,  3,  // 左列
    4,  5,  6,    6,  5,  7,  // 上の横木
    8,  9, 10,   10,  9, 11,  // 中間の横木

    // 背面
+    12,  13,  14,   14, 13, 15,  // 左列の裏
+    16,  17,  18,   18, 17, 19,  // 上の横木の裏
+    20,  21,  22,   22, 21, 23,  // 中間の横木の裏
+
+    0, 5, 12,   12, 5, 17,   // 上
+    5, 7, 17,   17, 7, 19,   // 上の横木の右
+    6, 7, 18,   18, 7, 19,   // 上の横木の下
+    6, 8, 18,   18, 8, 20,   // 上と中間の横木の間
+    8, 9, 20,   20, 9, 21,   // 中間の横木の上
+    9, 11, 21,  21, 11, 23,  // 中間の横木の右
+    10, 11, 22, 22, 11, 23,  // 中間の横木の下
+    10, 3, 22,  22, 3, 15,   // 幹の右
+    2, 3, 14,   14, 3, 15,   // 下
+    0, 2, 12,   12, 2, 14,   // 左
-  ]);
+  ];

+  const quadColors = [
+      200,  70, 120,  // 左列前面
+      200,  70, 120,  // 上の横木前面
+      200,  70, 120,  // 中間の横木前面
+
+       80,  70, 200,  // 左列背面
+       80,  70, 200,  // 上の横木背面
+       80,  70, 200,  // 中間の横木背面
+
+       70, 200, 210,  // 上
+      160, 160, 220,  // 上の横木右
+       90, 130, 110,  // 上の横木下
+      200, 200,  70,  // 上と中間の横木の間
+      210, 100,  70,  // 中間の横木の上
+      210, 160,  70,  // 中間の横木の右
+       70, 180, 210,  // 中間の横木の下
+      100,  70, 210,  // 幹の右
+       76, 210, 100,  // 下
+      140, 210,  80,  // 左
+  ];
+
+  const numVertices = indices.length;
+  const vertexData = new Float32Array(numVertices * 4); // xyz + color
+  const colorData = new Uint8Array(vertexData.buffer);
+
+  for (let i = 0; i &lt; indices.length; ++i) {
+    const positionNdx = indices[i] * 3;
+    const position = positions.slice(positionNdx, positionNdx + 3);
+    vertexData.set(position, i * 4);
+
+    const quadNdx = (i / 6 | 0) * 3;
+    const color = quadColors.slice(quadNdx, quadNdx + 3);
+    colorData.set(color, i * 16 + 12);  // RGBを設定します
+    colorData[i * 16 + 15] = 255;       // Aを設定します
+  }

  return {
    vertexData,
-    indexData,
-    numVertices: indexData.length,
+    numVertices,
  };
}
</pre>
<p>各インデックスをウォークし、そのインデックスの位置を取得し、位置の値を<code class="notranslate" translate="no">vertexData</code>に入れます。<code class="notranslate" translate="no">colorData</code>として<em>同じデータ</em>に別のビューがあり、クワッドインデックス（6頂点ごとに1つのクワッド）で色を取得し、そのクワッドの各頂点に同じ色を挿入します。データは次のようになります。</p>
<img class="webgpu_center" style="background-color: transparent; width: 1024px;" src="../resources/vertex-buffer-f32x3-u8x4.svg">
<p>追加した色は、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb">CSS <code class="notranslate" translate="no">rgb()</code>色</a>と同様に、0から255までの値を持つ符号なしバイトです。パイプラインの属性タイプを<code class="notranslate" translate="no">unorm8x4</code>（符号なし正規化8ビット値x 4）に設定することにより、GPUはバッファから値を取得し、シェーダーに供給するときにそれらを<em>正規化</em>します。これは、それらを0から1にする、この場合は255で割ることを意味します。</p>
<p>データができたので、それを使用するようにパイプラインを変更する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: (3) * 4, // (3) floats, 4 bytes each
+          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
+            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>インデックスバッファを作成する必要はもうありません。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const { vertexData, indexData, numVertices } = createFVertices();
+  const { vertexData, numVertices } = createFVertices();
  const vertexBuffer = device.createBuffer({
    label: 'vertex buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
-  const indexBuffer = device.createBuffer({
-    label: 'index buffer',
-    size: indexData.byteLength,
-    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
-  });
-  device.queue.writeBuffer(indexBuffer, 0, indexData);
</pre>
<p>そして、インデックスなしで描画する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no"> function render() {
    ...
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
-    pass.setIndexBuffer(indexBuffer, 'uint32');

    ...

    pass.setBindGroup(0, bindGroup);
-    pass.drawIndexed(numVertices);
+    pass.draw(numVertices);

    ...
  }
</pre>
<p>これで、次のようになります。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-3-colored-3d-f.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-3-colored-3d-f.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>おっと、それは何ですか？まあ、3D「F」のさまざまな部分、前面、背面、側面などが、ジオメトリデータに表示される順序で描画されることがわかります。これにより、前面にあるものが最初に描画され、その後ろにあるものが後で描画されてそれを覆い隠すことがあるため、望ましい結果が得られません。</p>
<img class="webgpu_center" style="background-color: transparent; width: 163px;" src="../resources/polygon-drawing-order.gif">
<p><span style="background: rgb(200, 70, 120); color: white; padding: 0.25em">赤みがかった部分</span>は「F」の<strong>前面</strong>ですが、データの最初の部分であるため、最初に描画され、その後ろにある他の三角形が後で描画されてそれを覆い隠します。たとえば、<span style="background: rgb(80, 70, 200); color: white; padding: 0.25em">紫の部分</span>は実際には「F」の背面です。データで2番目に来るため、2番目に描画されます。</p>
<p>WebGPUの三角形には、前面と背面の概念があります。デフォルトでは、前面の三角形の頂点はクリップ空間で反時計回りの方向に進みます。背面の三角形の頂点はクリップ空間で時計回りの方向に進みます。</p>
<img src="../resources/triangle-winding.svg" class="webgpu_center" style="width: 400px;">
<p>GPUには、前面のみまたは背面のみの三角形を描画する機能があります。パイプラインを変更することで、その機能をオンにできます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
+    primitive: {
+      cullMode: 'back',
+    },
  });
</pre>
<p><code class="notranslate" translate="no">cullMode</code>を<code class="notranslate" translate="no">back</code>に設定すると、「裏向き」の三角形がカリングされます。この場合の「カリング」は、「描画しない」という派手な言葉です。したがって、<code class="notranslate" translate="no">cullMode</code>を<code class="notranslate" translate="no">'back'</code>に設定すると、次のようになります。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-4-cullmode-back.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-4-cullmode-back.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>おい！三角形はどこに行ったのですか？まあ、それらの多くは間違った方向を向いていることがわかります。回転させると、反対側を見ると表示されます。幸いなことに、修正は簡単です。どちらが逆かを調べて、2つの頂点を交換するだけです。たとえば、1つの逆三角形にインデックスがある場合、</p>
<div class="webgpu_center"><pre class="webgpu_math">6, 7, 8,
</pre></div>
<p>2つを交換して、逆方向に進むようにするだけです。</p>
<div class="webgpu_center"><pre class="webgpu_math">6, 8, 7,
</pre></div>
<p>重要なのは、WebGPUに関する限り、三角形が時計回りまたは反時計回りと見なされるかどうかは、クリップ空間内のその三角形の頂点に依存するということです。つまり、WebGPUは、頂点シェーダーで頂点に数学を適用した後に、三角形が前面か背面かを判断します。つまり、たとえば、Xで-1でスケーリングされた時計回りの三角形は反時計回りの三角形になるか、180度回転した時計回りの三角形は反時計回りの三角形になります。以前は<code class="notranslate" translate="no">cullMode</code>を設定していなかったため、時計回り（前面）と反時計回り（背面）の両方の三角形を見ることができました。<code class="notranslate" translate="no">cullMode</code>を<code class="notranslate" translate="no">back</code>に設定したので、スケーリングや回転などの理由で前面の三角形が反転すると、WebGPUはそれを描画しません。これは良いことです。3Dで何かを回転させると、通常、あなたの方を向いている三角形が前面と見なされるようにしたいからです。</p>
<p>しかし！クリップ空間では+Yが上ですが、ピクセル空間では+Yが下であることを忘れないでください。つまり、行列はすべての三角形を垂直に反転させています。つまり、+Yを下にしてものを描画するには、<code class="notranslate" translate="no">cullMode</code>を<code class="notranslate" translate="no">'front'</code>に設定するか、すべての三角形の頂点を反転させる必要があります。<code class="notranslate" translate="no">cullMode</code>を<code class="notranslate" translate="no">'front'</code>に設定し、すべての三角形が同じ方向を向くように頂点データを修正しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const indices = [
    // 前面
    0,  1,  2,    2,  1,  3,  // 左列
    4,  5,  6,    6,  5,  7,  // 上の横木
    8,  9, 10,   10,  9, 11,  // 中間の横木

    // 背面
-    12,  13,  14,   14, 13, 15,  // 左列の裏
+    12,  14,  13,   14, 15, 13,  // 左列の裏
-    16,  17,  18,   18, 17, 19,  // 上の横木の裏
+    16,  18,  17,   18, 19, 17,  // 上の横木の裏
-    20,  21,  22,   22, 21, 23,  // 中間の横木の裏
+    20,  22,  21,   22, 23, 21,  // 中間の横木の裏

-    0, 5, 12,   12, 5, 17,   // 上
+    0, 12, 5,   12, 17, 5,   // 上
-    5, 7, 17,   17, 7, 19,   // 上の横木の右
+    5, 17, 7,   17, 19, 7,   // 上の横木の右
    6, 7, 18,   18, 7, 19,   // 上の横木の下
-    6, 8, 18,   18, 8, 20,   // 上と中間の横木の間
+    6, 18, 8,   18, 20, 8,   // 上と中間の横木の間
-    8, 9, 20,   20, 9, 21,   // 中間の横木の上
+    8, 20, 9,   20, 21, 9,   // 中間の横木の上
-    9, 11, 21,  21, 11, 23,  // 中間の横木の右
+    9, 21, 11,  21, 23, 11,  // 中間の横木の右
    10, 11, 22, 22, 11, 23,  // 中間の横木の下
-    10, 3, 22,  22, 3, 15,   // 幹の右
+    10, 22, 3,  22, 15, 3,   // 幹の右
    2, 3, 14,   14, 3, 15,   // 下
    0, 2, 12,   12, 2, 14,   // 左
  ];
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    ...
    primitive: {
-      cullMode: 'back',
+      cullMode: 'front',
    },
  });
</pre>
<p>これらの変更により、すべての三角形を1つの方向に向けることで、次のようになります。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-5-order-fixed.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-5-order-fixed.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>それは近いですが、まだ1つ問題があります。すべての三角形が正しい方向を向いていて、私たちから離れているものがカリングされていても、背面にあるはずの三角形が前面にあるはずの三角形の上に描画される場所がまだあります。</p>
<h2 id="「深度テクスチャ」の入力"><a id="a-depth-textures"></a>「深度テクスチャ」の入力</h2>
<p>深度テクスチャは、深度バッファまたはZバッファとも呼ばれ、描画しているテクスチャの各カラーテクセルに対応する<em>深度</em>テクセルの長方形です。深度テクスチャを作成してバインドすると、WebGPUが各ピクセルを描画するときに、深度ピクセルも描画できます。これは、頂点シェーダーからZに対して返す値に基づいて行われます。XとYでクリップ空間に変換する必要があったように、Zもクリップ空間にあります。Zの場合、クリップ空間は0から+1です。</p>
<p>WebGPUがカラーピクセルを描画する前に、対応する深度ピクセルをチェックします。描画しようとしているピクセルの深度（Z）値が、対応する深度ピクセルの値に対して何らかの条件と一致しない場合、WebGPUは新しいカラーピクセルを描画しません。それ以外の場合は、フラグメントシェーダーからの色で新しいカラーピクセルと、新しい深度値で深度ピクセルの両方を描画します。つまり、他のピクセルの後ろにあるピクセルは描画されません。</p>
<p>深度テクスチャを設定して使用するには、パイプラインを更新する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
    primitive: {
      cullMode: 'front',
    },
+    depthStencil: {
+      depthWriteEnabled: true,
+      depthCompare: 'less',
+      format: 'depth24plus',
+    },
  });
</pre>
<p>上記では、<code class="notranslate" translate="no">depthCompare: 'less'</code>を設定しています。これは、新しいピクセルのZ値が深度テクスチャの対応するピクセルよりも「小さい」場合にのみ、新しいピクセルを描画することを意味します。他のオプションには、<code class="notranslate" translate="no">never</code>、<code class="notranslate" translate="no">equal</code>、<code class="notranslate" translate="no">less-equal</code>、<code class="notranslate" translate="no">greater</code>、<code class="notranslate" translate="no">not-equal</code>、<code class="notranslate" translate="no">greater-equal</code>、<code class="notranslate" translate="no">always</code>があります。</p>
<p><code class="notranslate" translate="no">depthWriteEnabled: true</code>は、<code class="notranslate" translate="no">depthCompare</code>テストに合格した場合、新しいピクセルのZ値を深度テクスチャに書き込むことを意味します。この場合、描画しているピクセルが深度テクスチャにすでにあるものよりも小さいZ値を持つたびに、そのピクセルを描画し、深度テクスチャを更新します。このようにして、後でさらに後ろにある（より高いZ値を持つ）ピクセルを描画しようとすると、描画されません。</p>
<p><code class="notranslate" translate="no">format</code>は<code class="notranslate" translate="no">fragment.targets[?].format</code>に似ています。これは、使用する深度テクスチャの形式です。利用可能な深度テクスチャ形式は、<a href="webgpu-textures.html#a-depth-stencil-formats">テクスチャに関する記事</a>にリストされていました。<code class="notranslate" translate="no">depth24plus</code>は、選択するのに適したデフォルトの形式です。</p>
<p>また、レンダーパス記述子を更新して、深度ステンシルアタッチメントを持つようにする必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass',
    colorAttachments: [
      {
        // view: &lt;- レンダリング時に設定されます
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
+    depthStencilAttachment: {
+      // view: &lt;- レンダリング時に設定されます
+      depthClearValue: 1.0,
+      depthLoadOp: 'clear',
+      depthStoreOp: 'store',
+    },
  };
</pre>
<p>深度値は通常0.0から1.0までです。<code class="notranslate" translate="no">depthClearValue</code>を1に設定します。<code class="notranslate" translate="no">depthCompare</code>を<code class="notranslate" translate="no">less</code>に設定したので、これは理にかなっています。</p>
<p>最後に、深度テクスチャを作成する必要があります。問題は、カラーアタッチメントのサイズと一致する必要があることです。この場合、キャンバスから取得するテクスチャです。キャンバステクスチャは、<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>コールバックでキャンバスのサイズを変更するとサイズが変わります。または、より明確に言うと、<code class="notranslate" translate="no">context.getCurrentTexture</code>を呼び出すときに取得するテクスチャは、キャンバスに設定した任意のサイズになります。それを念頭に置いて、レンダリング時に正しいサイズのテクスチャを作成しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let depthTexture;

  function render() {
    // キャンバスコンテキストから現在のテクスチャを取得し、
    // レンダリングするテクスチャとして設定します。
-    renderPassDescriptor.colorAttachments[0].view =
-        context.getCurrentTexture().createView();
+    const canvasTexture = context.getCurrentTexture();
+    renderPassDescriptor.colorAttachments[0].view = canvasTexture.createView();

+    // 深度テクスチャがない場合、またはそのサイズが
+    // キャンバステクスチャと異なる場合は、新しい深度テクスチャを作成します。
+    if (!depthTexture ||
+        depthTexture.width !== canvasTexture.width ||
+        depthTexture.height !== canvasTexture.height) {
+      if (depthTexture) {
+        depthTexture.destroy();
+      }
+      depthTexture = device.createTexture({
+        size: [canvasTexture.width, canvasTexture.height],
+        format: 'depth24plus',
+        usage: GPUTextureUsage.RENDER_ATTACHMENT,
+      });
+    }
+    renderPassDescriptor.depthStencilAttachment.view = depthTexture.createView();

  ...
</pre>
<p>深度テクスチャを追加すると、次のようになります。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-6-depth-texture.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-6-depth-texture.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>3Dです！</p>
<h2 id="ortho--orthographic">Ortho / Orthographic</h2>
<p>マイナーなことですが、ほとんどの3D数学ライブラリには、クリップ空間からピクセル空間への変換を行う<code class="notranslate" translate="no">projection</code>関数はありません。むしろ、通常、次のような<code class="notranslate" translate="no">ortho</code>または<code class="notranslate" translate="no">orthographic</code>という関数があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
  ortho(left, right, bottom, top, near, far, dst) {
    dst = dst || new Float32Array(16);

    dst[0] = 2 / (right - left);
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;

    dst[4] = 0;
    dst[5] = 2 / (top - bottom);
    dst[6] = 0;
    dst[7] = 0;

    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1 / (near - far);
    dst[11] = 0;

    dst[12] = (right + left) / (left - right);
    dst[13] = (top + bottom) / (bottom - top);
    dst[14] = near / (near - far);
    dst[15] = 1;

    return dst;
  },
  ...
</pre>
<p>幅、高さ、深度のパラメータしか持たなかった単純化された<code class="notranslate" translate="no">projection</code>関数とは異なり、このより一般的な正射影関数では、左、右、下、上、近、遠を渡すことができ、より柔軟性があります。元の射影関数と同じように使用するには、次のように呼び出します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    mat4.projection(canvas.clientWidth, canvas.clientHeight, 400, matrixValue);
+    mat4.ortho(
+        0,                   // left
+        canvas.clientWidth,  // right
+        canvas.clientHeight, // bottom
+        0,                   // top
+        200,                 // near
+        -200,                // far
+        matrixValue,         // dst
+    );   
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-orthographic-projection-step-7-ortho.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-orthographic-projection-step-7-ortho.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>次に、<a href="webgpu-perspective-projection.html">遠近法を持たせる方法</a>について説明します。</p>
<div class="webgpu_bottombar">
<h3>なぜ正射影と呼ばれるのですか？</h3>
<p>
この場合の正射影は、<i>直交</i>という言葉に由来します。
</p>
<blockquote>
<h2>直交</h2>
<p><i>形容詞</i>:</p>
<ol><li>直角の、または直角を含む</li></ol>
</blockquote>
</div>
<!-- この記事の最後にこれを保持してください -->
<link href="../webgpu-orthographic-projection.css" rel="stylesheet">
<script type="module" src="../webgpu-orthographic-projection.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-orthographic-projection.html">English
    </option><option value="/webgpu/lessons/es/webgpu-orthographic-projection.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-orthographic-projection.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-orthographic-projection.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-orthographic-projection.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-orthographic-projection.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-orthographic-projection.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 正射影`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>