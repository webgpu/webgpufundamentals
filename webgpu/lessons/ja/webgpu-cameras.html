<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-cameras.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="行列によるカメラ">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_ja.jpg">

<meta property="og:title" content="WebGPU カメラ">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_ja.jpg">
<meta property="og:description" content="行列によるカメラ">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU カメラ">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html">
<meta name="twitter:description" content="行列によるカメラ">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html",
      "inLanguage":"ja",
      "name":"WebGPU カメラ",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-cameras.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU カメラ</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-cameras.html">English
    </option><option value="/webgpu/lessons/es/webgpu-cameras.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-cameras.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-cameras.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-cameras.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-cameras.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-cameras.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-cameras.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU カメラ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>この記事は、3D数学について学ぶことを目的とした一連の記事の7番目です。各記事は前のレッスンを基にしているので、順番に読むと最も理解しやすいかもしれません。</p>
<ol>
<li><a href="webgpu-translation.html">平行移動</a></li>
<li><a href="webgpu-rotation.html">回転</a></li>
<li><a href="webgpu-scale.html">スケーリング</a></li>
<li><a href="webgpu-matrix-math.html">行列演算</a></li>
<li><a href="webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="webgpu-cameras.html">カメラ</a> ⬅ ここです</li>
<li><a href="webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="webgpu-scene-graphs.html">シーングラフ</a></li>
</ol>
<p>前回の投稿では、<code class="notranslate" translate="no">mat4.perspective</code>関数が視点を原点(0, 0, 0)に置き、錐台内のオブジェクトがその手前の<code class="notranslate" translate="no">-zNear</code>から<code class="notranslate" translate="no">-zFar</code>の間に配置されるため、Fを錐台の前に移動させる必要がありました。これは、表示させたいものはすべてこの空間に配置する必要があることを意味します。</p>
<p>現実世界では、通常、カメラを動かしてあるオブジェクトの写真を撮ります。</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="move-camera"></div>
   <div class="caption">カメラをオブジェクトに移動する</div>
</div>
<p>しかし、前回の投稿では、-Z軸上の原点の前にあるものを必要とする射影行列を考え出しました。これを実現するために、カメラを原点に移動させ、他のすべてを適切な量だけ移動させて、<em>カメラに対して</em>同じ場所に留まるようにする必要があります。</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="move-world"></div>
   <div class="caption">オブジェクトをビューに移動する</div>
</div>
<p>私たちは、世界をカメラの前に効果的に移動させる必要があります。これを行う最も簡単な方法は、「逆」行列を使用することです。一般的な場合に逆行列を計算する数学は複雑ですが、概念的には簡単です。逆行列は、他の値を打ち消すために使用する値です。たとえば、X方向に123だけ平行移動する行列の逆行列は、X方向に-123だけ平行移動する行列です。5倍に拡大する行列の逆行列は、1/5または0.2倍に縮小する行列です。X軸を中心に30度回転する行列の逆行列は、X軸を中心に-30度回転する行列です。</p>
<p>これまで、平行移動、回転、拡大縮小を使用して、「F」の位置と向きに影響を与えてきました。すべての行列を乗算した後、「F」を原点から目的の場所、サイズ、向きに移動する方法を表す単一の行列が得られます。カメラについても同じことができます。カメラを原点から目的の場所に移動および回転させる方法を示す行列が得られたら、その逆行列を計算できます。これにより、他のすべてを反対の量だけ移動および回転させる方法を示す行列が得られ、カメラが(0, 0, 0)にあり、他のすべてをその前に移動させたことになります。</p>
<p>上の図のように、「F」の円を持つ3Dシーンを作成しましょう。</p>
<p>まず最初に、「F」の頂点データを調整しましょう。最初は2Dでピクセルから始めました。「F」の左上隅は0,0にあり、右に100ピクセル、下に150ピクセル伸びています。「ピクセル」は3Dの単位としてはおそらく意味がなく、作成した透視射影行列は正のYを上として使用するため、「F」を反転させて正のYが上になるようにし、原点を中心に配置しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const positions = [
-    // 左列
-    0, 0, 0,
-    30, 0, 0,
-    0, 150, 0,
-    30, 150, 0,
-
-    // 上の横木
-    30, 0, 0,
-    100, 0, 0,
-    30, 30, 0,
-    100, 30, 0,
-
-    // 中間の横木
-    30, 60, 0,
-    70, 60, 0,
-    30, 90, 0,
-    70, 90, 0,
-
-    // 左列の裏
-    0, 0, 30,
-    30, 0, 30,
-    0, 150, 30,
-    30, 150, 30,
-
-    // 上の横木の裏
-    30, 0, 30,
-    100, 0, 30,
-    30, 30, 30,
-    100, 30, 30,
-
-    // 中間の横木の裏
-    30, 60, 30,
-    70, 60, 30,
-    30, 90, 30,
-    70, 90, 30,
+    // 左列
+     -50,  75,  15,
+     -20,  75,  15,
+     -50, -75,  15,
+     -20, -75,  15,
+
+    // 上の横木
+     -20,  75,  15,
+      50,  75,  15,
+     -20,  45,  15,
+      50,  45,  15,
+
+    // 中間の横木
+     -20,  15,  15,
+      20,  15,  15,
+     -20, -15,  15,
+      20, -15,  15,
+
+    // 左列の裏
+     -50,  75, -15,
+     -20,  75, -15,
+     -50, -75, -15,
+     -20, -75, -15,
+
+    // 上の横木の裏
+     -20,  75, -15,
+      50,  75, -15,
+     -20,  45, -15,
+      50,  45, -15,
+
+    // 中間の横木の裏
+     -20,  15, -15,
+      20,  15, -15,
+     -20, -15, -15,
+      20, -15, -15,
  ];
</pre>
<p>さらに、<a href="webgpu-perspective-projection.html">前の記事</a>で説明したように、ほとんどの2Dピクセルライブラリに合わせて正のY = 下を使用していたため、通常の3Dとは逆の三角形の頂点順序になり、Yを-1でスケーリングしていたため、通常の<code class="notranslate" translate="no">'back'</code>向きの三角形ではなく<code class="notranslate" translate="no">'front'</code>向きの三角形をカリングすることになりました。通常の3Dで正のY = 上を使用するようになったので、頂点の順序を反転させて、時計回りの三角形が外側を向くようにしましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const indices = [
-     0,  1,  2,    2,  1,  3,  // 左列
-     4,  5,  6,    6,  5,  7,  // 上の横木
-     8,  9, 10,   10,  9, 11,  // 中間の横木
-
-    12, 14, 13,   14, 15, 13,  // 左列の裏
-    16, 18, 17,   18, 19, 17,  // 上の横木の裏
-    20, 22, 21,   22, 23, 21,  // 中間の横木の裏
-
-     0, 12,  5,   12, 17,  5,   // 上
-     5, 17,  7,   17, 19,  7,   // 上の横木の右
-     6,  7, 18,   18,  7, 19,   // 上の横木の下
-     6, 18,  8,   18, 20,  8,   // 上と中間の横木の間
-     8, 20,  9,   20, 21,  9,   // 中間の横木の上
-     9, 21, 11,   21, 23, 11,   // 中間の横木の右
-    10, 11, 22,   22, 11, 23,   // 中間の横木の下
-    10, 22,  3,   22, 15,  3,   // 幹の右
-     2,  3, 14,   14,  3, 15,   // 下
-     0,  2, 12,   12,  2, 14,   // 左
+     0,  2,  1,    2,  3,  1,   // 左列
+     4,  6,  5,    6,  7,  5,   // 上の横木
+     8, 10,  9,   10, 11,  9,   // 中間の横木
+
+    12, 13, 14,   14, 13, 15,   // 左列の裏
+    16, 17, 18,   18, 17, 19,   // 上の横木の裏
+    20, 21, 22,   22, 21, 23,   // 中間の横木の裏
+
+     0,  5, 12,   12,  5, 17,   // 上
+     5,  7, 17,   17,  7, 19,   // 上の横木の右
+     6, 18,  7,   18, 19,  7,   // 上の横木の下
+     6,  8, 18,   18,  8, 20,   // 上と中間の横木の間
+     8,  9, 20,   20,  9, 21,   // 中間の横木の上
+     9, 11, 21,   21, 11, 23,   // 中間の横木の右
+    10, 22, 11,   22, 23, 11,   // 中間の横木の下
+    10,  3, 22,   22,  3, 15,   // 幹の右
+     2, 14,  3,   14, 15,  3,   // 下
+     0, 12,  2,   12, 14,  2,   // 左
  ];
</pre>
<p>最後に、<code class="notranslate" translate="no">cullMode</code>を<em>裏向き</em>の三角形をカリングするように設定しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
    primitive: {
-      cullMode: 'front',  // 注：一般的でない設定。記事を参照
+      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
  });
</pre>
<p>以下は、行列が与えられた場合にその逆行列を計算する関数です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...

+  inverse(m, dst) {
+    dst = dst || new Float32Array(16);
+
+    const m00 = m[0 * 4 + 0];
+    const m01 = m[0 * 4 + 1];
+    const m02 = m[0 * 4 + 2];
+    const m03 = m[0 * 4 + 3];
+    const m10 = m[1 * 4 + 0];
+    const m11 = m[1 * 4 + 1];
+    const m12 = m[1 * 4 + 2];
+    const m13 = m[1 * 4 + 3];
+    const m20 = m[2 * 4 + 0];
+    const m21 = m[2 * 4 + 1];
+    const m22 = m[2 * 4 + 2];
+    const m23 = m[2 * 4 + 3];
+    const m30 = m[3 * 4 + 0];
+    const m31 = m[3 * 4 + 1];
+    const m32 = m[3 * 4 + 2];
+    const m33 = m[3 * 4 + 3];
+
+    const tmp0 = m22 * m33;
+    const tmp1 = m32 * m23;
+    const tmp2 = m12 * m33;
+    const tmp3 = m32 * m13;
+    const tmp4 = m12 * m23;
+    const tmp5 = m22 * m13;
+    const tmp6 = m02 * m33;
+    const tmp7 = m32 * m03;
+    const tmp8 = m02 * m23;
+    const tmp9 = m22 * m03;
+    const tmp10 = m02 * m13;
+    const tmp11 = m12 * m03;
+    const tmp12 = m20 * m31;
+    const tmp13 = m30 * m21;
+    const tmp14 = m10 * m31;
+    const tmp15 = m30 * m11;
+    const tmp16 = m10 * m21;
+    const tmp17 = m20 * m11;
+    const tmp18 = m00 * m31;
+    const tmp19 = m30 * m01;
+    const tmp20 = m00 * m21;
+    const tmp21 = m20 * m01;
+    const tmp22 = m00 * m11;
+    const tmp23 = m10 * m01;
+
+    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
+               (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
+    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
+               (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
+    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
+               (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
+    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
+               (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
+
+    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
+
+    dst[0] = d * t0;
+    dst[1] = d * t1;
+    dst[2] = d * t2;
+    dst[3] = d * t3;
+
+    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -
+                  (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
+    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -
+                  (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
+    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -
+                  (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
+    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -
+                  (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
+
+    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -
+                  (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
+    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -
+                  (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
+    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -
+                   (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
+    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -
+                   (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
+
+    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -
+                   (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
+    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -
+                   (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
+    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -
+                   (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
+    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -
+                   (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
+    return dst;
+  },
...
</pre>
<p>以前の例で行ったように、5つのものを描画するには、5つのユニフォームバッファと5つのバインドグループが必要です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const numFs = 5;
+  const objectInfos = [];
+  for (let i = 0; i &lt; numFs; ++i) {
    // 行列
    const uniformBufferSize = (16) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);

    // float32インデックスでのさまざまなユニフォーム値へのオフセット
    const kMatrixOffset = 0;

    const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: uniformBuffer },
      ],
    });

+    objectInfos.push({
+      uniformBuffer,
+      uniformValues,
+      matrixValue,
+      bindGroup,
+    });
+  }
</pre>
<p>例をすっきりさせるために、いくつかの設定を取り除きましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    fieldOfView: degToRad(100),
-    translation: [-65, 0, -120],
-    rotation: [degToRad(220), degToRad(25), degToRad(325)],
-    scale: [1, 1, 1],
  };

  ...

-      mat4.translate(matrixValue, settings.translation, matrixValue);
-      mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
-      mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
-      mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
-      mat4.scale(matrixValue, settings.scale, matrixValue);
</pre>
<p>5つのものを描画し、それらはすべて同じ射影行列を使用するため、Fを描画するループの前に計算します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...

    const aspect = canvas.clientWidth / canvas.clientHeight;
-    mat4.perspective(
+    const projection = mat4.perspective(
        settings.fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
-        matrixValue,
    );
</pre>
<p>次に、カメラ行列を計算します。この行列は、世界におけるカメラの位置と向きを表します。以下のコードは、原点を中心に半径*1.5の距離でカメラを回転させ、原点を見つめる行列を作成します。</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="camera-movement"></div>
   <div class="caption">カメラの動き</div>
</div>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const radius = 200;
  const settings = {
    fieldOfView: degToRad(100),
+    cameraAngle: 0,
  };

  ...

  function render() {

     ...
 

+    // カメラの行列を計算します。
+    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
+    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);
</pre>
<p>次に、カメラ行列から「ビュー行列」を計算します。「ビュー行列」は、カメラの反対側にすべてを移動させる行列で、カメラが原点(0,0,0)にあるかのように、すべてをカメラに対して相対的にします。これは、逆行列（指定された行列と正反対の動作をする行列）を計算する<code class="notranslate" translate="no">inverse</code>関数を使用することで実行できます。この場合、指定された行列はカメラをある位置と向きに原点に対して移動させます。その逆行列は、カメラが原点にあるように他のすべてを移動させる行列です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // カメラ行列からビュー行列を作成します。
    const viewMatrix = mat4.inverse(cameraMatrix);
</pre>
<p>次に、ビュー行列と射影行列を組み合わせてビュー射影行列を作成します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    // ビュー行列と射影行列を組み合わせます
+    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);
</pre>
<p>最後に、Fの円を描画します。各Fについて、ビュー射影行列から始め、円上の位置を計算し、その位置に平行移動します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        settings.fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    // カメラの行列を計算します。
    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);

    // カメラ行列からビュー行列を作成します。
    const viewMatrix = mat4.inverse(cameraMatrix);

    // ビュー行列と射影行列を組み合わせます
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

+    objectInfos.forEach(({
+      matrixValue,
+      uniformBuffer,
+      uniformValues,
+      bindGroup,
+    }, i) =&gt; {
+      const angle = i / numFs * Math.PI * 2;
+      const x = Math.cos(angle) * radius;
+      const z = Math.sin(angle) * radius;

+      mat4.translate(viewProjectionMatrix, [x, 0, z], matrixValue);

      // ユニフォーム値をユニフォームバッファにアップロードします
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.draw(numVertices);
+    });
</pre>
<p>そして、出来上がり！「F」の円の周りを回るカメラです。<code class="notranslate" translate="no">cameraAngle</code>スライダーをドラッグしてカメラを動かしてみてください。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-1-direct-math.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-1-direct-math.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>それはそれでいいのですが、回転と平行移動を使ってカメラを好きな場所に移動させ、見たいものの方を向かせるのは必ずしも簡単ではありません。たとえば、カメラが常に特定の「F」の1つを指すようにしたい場合、その「F」を指すようにカメラを回転させる方法を計算するには、かなり複雑な数学が必要になります。</p>
<p>幸いなことに、もっと簡単な方法があります。カメラをどこに置きたいか、何を指したいかを決めるだけで、カメラをそこに置く行列を計算できます。行列の仕組みに基づくと、これは驚くほど簡単です。</p>
<p>まず、カメラをどこに置きたいかを知る必要があります。これを<code class="notranslate" translate="no">eye</code>と呼びます。次に、見たいもの、または狙いたいものの位置を知る必要があります。これを<code class="notranslate" translate="no">target</code>と呼びます。<code class="notranslate" translate="no">eye</code>から<code class="notranslate" translate="no">target</code>を引くと、カメラからターゲットに到達するために必要な方向を指すベクトルが得られます。これを<code class="notranslate" translate="no">zAxis</code>と呼びましょう。カメラは-Z方向を向いていることがわかっているので、逆方向に<code class="notranslate" translate="no">eye - target</code>を引くことができます。結果を正規化し、行列の<code class="notranslate" translate="no">z</code>の部分に直接コピーします。</p>
<div class="webgpu_center">
  <div class="glocal-center">
    <table class="glocal-center-content glocal-mat">
      <tbody><tr>
        <td class="m11"> </td>
        <td class="m12"> </td>
        <td class="m13">Zx</td>
        <td class="m14"> </td>
      </tr>
      <tr>
        <td class="m21"> </td>
        <td class="m22"> </td>
        <td class="m23">Zy</td>
        <td class="m24"> </td>
      </tr>
      <tr>
        <td class="m31"> </td>
        <td class="m32"> </td>
        <td class="m33">Zz</td>
        <td class="m34"> </td>
      </tr>
      <tr>
        <td class="m41"> </td>
        <td class="m42"> </td>
        <td class="m43"> </td>
        <td class="m44"> </td>
      </tr>
    </tbody></table>
  </div>
</div>
<p>行列のこの部分はZ軸を表します。この場合、カメラのZ軸です。ベクトルを正規化するということは、1.0単位を表すベクトルにすることです。<a href="webgpu-rotation.html">回転に関する記事</a>に戻ると、単位円とそれが2D回転にどのように役立ったかについて話しました。3Dでは単位球が必要であり、正規化されたベクトルは単位球上の点を表します。</p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-00"></div>
  <div class="caption"><span class="z-axis">z軸</span></div>
</div>
<p>しかし、それだけでは情報が不十分です。単一のベクトルは単位球上の点を与えますが、その点からどの向きにものを配置すればよいのでしょうか？行列の他の部分、具体的にはX軸とY軸の部分を埋める必要があります。一般に、これら3つの部分は互いに垂直であることがわかっています。また、「一般的に」、カメラを真上に向けることはありません。それを考えると、どちらが上か、この場合は(0,1,0)がわかっていれば、それと「外積」と呼ばれるものを使って、行列のX軸とY軸を計算できます。</p>
<p>外積が数学的に何を意味するのかはわかりません。私が知っているのは、2つの単位ベクトルがあり、それらの外積を計算すると、それら2つのベクトルに垂直なベクトルが得られるということです。つまり、南東を指すベクトルと上を指すベクトルがあり、外積を計算すると、南西または北東を指すベクトルが得られます。なぜなら、それらは南東と上に垂直な2つのベクトルだからです。外積を計算する順序によっては、反対の答えが得られます。</p>
<p>いずれにせよ、<span class="z-axis"><code class="notranslate" translate="no">zAxis</code></span>と<span style="color: gray;"><code class="notranslate" translate="no">up</code></span>の外積を計算すると、カメラの<span class="x-axis">xAxis</span>が得られます。</p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-01"></div>
  <div class="caption"><span style="color:gray;">up</span> cross <span class="z-axis">zAxis</span> = <span class="x-axis">xAxis</span></div>
</div>
<p>そして、<span class="x-axis"><code class="notranslate" translate="no">xAxis</code></span>が得られたので、<span class="z-axis"><code class="notranslate" translate="no">zAxis</code></span>と<span class="x-axis"><code class="notranslate" translate="no">xAxis</code></span>をクロスさせることができます。これにより、カメラの<span class="y-axis"><code class="notranslate" translate="no">yAxis</code></span>が得られます。</p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-02"></div>
  <div class="caption"><span class="z-axis">zAxis</span> cross <span class="x-axis">xAxis</span> = <span class="y-axis">yAxis</span></div>
</div>
<p>あとは、3つの軸を行列に差し込むだけです。これにより、<code class="notranslate" translate="no">eye</code>から<code class="notranslate" translate="no">target</code>を指すものを方向付ける行列が得られます。最後の列に<code class="notranslate" translate="no">eye</code>の位置を入れるだけです。</p>
<div class="webgpu_center">
  <div class="glocal-center">
    <table class="glocal-center-content glocal-mat">
      <tbody>
        <tr class="vertical-spans">
          <td><span class="x-axis">x軸 →</span></td>
          <td><span class="y-axis">y軸 →</span></td>
          <td><span class="z-axis">z軸 →</span></td>
          <td><span>視点の位置 →</span></td>
        </tr>
        <tr>
          <td class="m11">Xx</td>
          <td class="m12">Yx</td>
          <td class="m13">Zx</td>
          <td class="m14">Tx</td>
        </tr>
        <tr>
          <td class="m21">Xy</td>
          <td class="m22">Yy</td>
          <td class="m23">Zy</td>
          <td class="m24">Ty</td>
        </tr>
        <tr>
          <td class="m31">Xz</td>
          <td class="m32">Yz</td>
          <td class="m33">Zz</td>
          <td class="m34">Tz</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<p>以下は、2つのベクトルの外積を計算するコードです。行列コードと同様に、オプションの宛先配列を受け取るようにします。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const vec3 = {
+  cross(a, b, dst) {
+    dst = dst || new Float32Array(3);
+
+    const t0 = a[1] * b[2] - a[2] * b[1];
+    const t1 = a[2] * b[0] - a[0] * b[2];
+    const t2 = a[0] * b[1] - a[1] * b[0];
+
+    dst[0] = t0;
+    dst[1] = t1;
+    dst[2] = t2;
+
+    return dst;
+  },
+};
</pre>
<p>以下は、2つのベクトルを減算するコードです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
+  subtract(a, b, dst) {
+    dst = dst || new Float32Array(3);
+
+    dst[0] = a[0] - b[0];
+    dst[1] = a[1] - b[1];
+    dst[2] = a[2] - b[2];
+
+    return dst;
+  },
</pre>
<p>以下は、ベクトルを正規化する（単位ベクトルにする）コードです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
+  normalize(v, dst) {
+    dst = dst || new Float32Array(3);
+
+    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
+    // 0で除算しないようにします。
+    if (length &gt; 0.00001) {
+      dst[0] = v[0] / length;
+      dst[1] = v[1] / length;
+      dst[2] = v[2] / length;
+    } else {
+      dst[0] = 0;
+      dst[1] = 0;
+      dst[2] = 0;
+    }
+
+    return dst;
+  },
</pre>
<p>以下は、<em>カメラ</em>行列を計算するコードです。上記で説明した手順に従います。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
  cameraAim(eye, target, up, dst) {
    dst = dst || new Float32Array(16);

    const zAxis = vec3.normalize(vec3.subtract(eye, target));
    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));

    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;

    return dst;
  },
  ...
</pre>
<p>そして、これを使用して、移動中にカメラを特定の「F」に向ける方法は次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    // カメラの行列を計算します。
-    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
-    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);
+    // 最初のFの位置を計算します
+    const fPosition = [radius, 0, 0];
+
+    // 行列演算を使用して、カメラがある円上の位置を計算します
+    const tempMatrix = mat4.rotationY(settings.cameraAngle);
+    mat4.translate(tempMatrix, [0, 0, radius * 1.5], tempMatrix);
+
+    // 計算した行列からカメラの位置を取得します
+    const eye = tempMatrix.slice(12, 15);
+
+    const up = [0, 1, 0];
+
+    // cameraAimを使用してカメラの行列を計算します
+    const cameraMatrix = mat4.cameraAim(eye, fPosition, up);

    // カメラ行列からビュー行列を作成します。
    const viewMatrix = mat4.inverse(cameraMatrix);
</pre>
<p>そして、これが結果です。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-2-camera-aim.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-2-camera-aim.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>スライダーをドラッグして、カメラが単一の「F」を追跡する方法に注目してください。</p>
<p>ほとんどの数学ライブラリには<code class="notranslate" translate="no">cameraAim</code>関数がありません。代わりに、<code class="notranslate" translate="no">lookAt</code>関数があり、これは<code class="notranslate" translate="no">cameraAim</code>関数とまったく同じことを行いますが、ビュー行列にも変換します。機能的には、<code class="notranslate" translate="no">lookAt</code>は次のように実装できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
+  lookAt(eye, target, up, dst) {
+    return mat4.inverse(mat4.cameraAim(eye, target, up, dst), dst);
+  },
  ...
};
</pre>
<p>この<code class="notranslate" translate="no">lookAt</code>関数を使用すると、コードは次のようになります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    // look atを使用してカメラの行列を計算します。
-    const cameraMatrix = mat4.cameraAim(eye, fPosition, up);
-
-    // カメラ行列からビュー行列を作成します。
-    const viewMatrix = mat4.inverse(cameraMatrix);
+    // ビュー行列を計算します
+    const viewMatrix = mat4.lookAt(eye, fPosition, up);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-3-look-at.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-3-look-at.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>この種の「エイム」数学は、カメラだけでなく、他の用途にも使用できることに注意してください。一般的な用途は、キャラクターの頭をあるターゲットに追従させることです。砲塔をターゲットに向けることです。オブジェクトをパスに沿って追従させることです。パス上のターゲットの位置を計算します。次に、パス上のターゲットが数秒後にどこにあるかを計算します。これら2つの値を<code class="notranslate" translate="no">aim</code>関数にプラグインすると、オブジェクトをパスに沿って追従させ、パスに向かって方向付ける行列が得られます。</p>
<p>通常、何かを「狙う」には、上記の関数のように負のZ軸ではなく、正のZ軸を指すようにする必要があります。したがって、<code class="notranslate" translate="no">eye</code>から<code class="notranslate" translate="no">target</code>を引くのではなく、<code class="notranslate" translate="no">target</code>から<code class="notranslate" translate="no">eye</code>を引く必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
+  aim(eye, target, up, dst) {
+    dst = dst || new Float32Array(16);
+
+    const zAxis = vec3.normalize(vec3.subtract(target, eye));
+    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
+    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));
+
+    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
+    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
+    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
+    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;
+
+    return dst;
+  },

  cameraAim(eye, target, up, dst) {
    dst = dst || new Float32Array(16);

    const zAxis = vec3.normalize(vec3.subtract(eye, target));
    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));

    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;

    return dst;
  },
...

&lt;a id="a-aim-fs"&gt;&lt;/a&gt; たくさんのFを別のFに向けるようにしましょう（ええ、Fが多すぎますが、例をこれ以上データでごちゃごちゃさせたくありません）。5x5のFのグリッドと、それらが「狙う」ためのもう1つのFを作成します。

```js
-  const numFs = 5;
+  const numFs = 5 * 5 + 1;
</pre>
<p>次に、カメラのターゲットをハードコーディングし、Fの1つを移動できるように設定を変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
-    fieldOfView: degToRad(100),
-    cameraAngle: 0,
+    target: [0, 200, 300],
+    targetAngle: 0,
  };

  const radToDegOptions = { min: -360, max: 360, step: 1, converters: GUI.converters.radToDeg };

  const gui = new GUI();
  gui.onChange(render);
-  gui.add(settings, 'fieldOfView', {min: 1, max: 179, converters: GUI.converters.radToDeg});
-  gui.add(settings, 'cameraAngle', radToDegOptions);
+  gui.add(settings.target, '1', -100, 300).name('target height');
+  gui.add(settings, 'targetAngle', radToDegOptions).name('target angle');
</pre>
<p>そして最後に、最初の25個のFについては、<code class="notranslate" translate="no">aim</code>を使用してグリッドに配置し、26番目のFを<em>狙い</em>ます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    // 角度に基づいてターゲットのX、Zを更新します
+    settings.target[0] = Math.cos(settings.targetAngle) * radius;
+    settings.target[2] = Math.sin(settings.targetAngle) * radius;

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
-        settings.fieldOfView,
+        degToRad(60), // fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
    );

-    // 最初のFの位置を計算します
-    const fPosition = [radius, 0, 0];
-
-    // 行列演算を使用して、カメラがある円上の位置を計算します
-    const tempMatrix = mat4.rotationY(settings.cameraAngle);
-    mat4.translate(tempMatrix, [0, 0, radius * 1.5], tempMatrix);
-
-    // 計算した行列からカメラの位置を取得します
-    const eye = tempMatrix.slice(12, 15);
+    const eye = [-500, 300, -500];
+    const target = [0, -100, 0];
    const up = [0, 1, 0];

    // ビュー行列を計算します
-    const viewMatrix = mat4.lookAt(eye, fPosition, up);
+    const viewMatrix = mat4.lookAt(eye, target, up);

    // ビュー行列と射影行列を組み合わせます
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    objectInfos.forEach(({
      matrixValue,
      uniformBuffer,
      uniformValues,
      bindGroup,
    }, i) =&gt; {
-      const angle = i / numFs * Math.PI * 2;
-      const x = Math.cos(angle) * radius;
-      const z = Math.sin(angle) * radius;
-
-      mat4.translate(viewProjectionMatrix, [x, 0, z], matrixValue);

+      const deep = 5;
+      const across = 5;
+      if (i &lt; 25) {
+        // グリッド位置を計算します
+        const gridX = i % across;
+        const gridZ = i / across | 0;
+
+        // 0から1の位置を計算します
+        const u = gridX / (across - 1);
+        const v = gridZ / (deep - 1);
+
+        // 中央に配置して広げます
+        const x = (u - 0.5) * across * 150;
+        const z = (v - 0.5) * deep * 150;
+
+        // このFをその位置からターゲットFに向ける
+        const aimMatrix = mat4.aim([x, 0, z], settings.target, up);
+        mat4.multiply(viewProjectionMatrix, aimMatrix, matrixValue);
+      } else {
+        mat4.translate(viewProjectionMatrix, settings.target, matrixValue);
+      }

      // ユニフォーム値をユニフォームバッファにアップロードします
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<p>そして今、25個のFが26番目のFに面しています（前面は正のZです）。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-4-aim-Fs.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-4-aim-Fs.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>スライダーを動かして、25個のFすべてが<em>狙う</em>のを見てください。</p>
<!-- この記事の最後にこれを保持してください -->
<link href="../webgpu-cameras.css" rel="stylesheet">
<script type="module" src="../webgpu-cameras.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-cameras.html">English
    </option><option value="/webgpu/lessons/es/webgpu-cameras.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-cameras.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-cameras.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-cameras.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-cameras.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-cameras.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-cameras.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU カメラ`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>