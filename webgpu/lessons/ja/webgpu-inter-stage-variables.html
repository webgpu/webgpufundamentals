<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-inter-stage-variables.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="頂点シェーダからフラグメントシェーダへデータを渡す">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ja.jpg">

<meta property="og:title" content="inter-stage(シェーダ間)変数">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ja.jpg">
<meta property="og:description" content="頂点シェーダからフラグメントシェーダへデータを渡す">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="inter-stage(シェーダ間)変数">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html">
<meta name="twitter:description" content="頂点シェーダからフラグメントシェーダへデータを渡す">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html",
      "inLanguage":"ja",
      "name":"inter-stage(シェーダ間)変数",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-inter-stage-variables.html#primaryimage"
      }
    }
  ]
}
</script>

<title>inter-stage(シェーダ間)変数</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>inter-stage(シェーダ間)変数</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>前回の「<a href="webgpu-fundamentals.html">基本</a>」と題した記事では、
WebGPUの、とてもとても基本的な事柄について説明しました。
今回は、inter-stage変数について、<em>普通に基本的な</em>事柄について説明します。</p>
<p>inter-stage変数が登場するのは、頂点シェーダとフラグメントシェーダの間です。</p>
<p>頂点シェーダが３点の座標値を出力すると、三角形がラスタライズ(ピクセルとして描画)されます。
頂点シェーダはこの「位置を表す座標値」のほかに、何がしかの情報を出力することができます。
この情報は各頂点と結びついており、デフォルトでは、
３点の間でグラデーションのように補間(interpolate)されます。</p>
<p>前回の記事で使った「三角形を描くシェーダ」を改造して、inter-stage変数を使ってみましょう。
今回改造するのは、このシェーダ部分だけです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
-    label: 'our hardcoded red triangle shaders',
+    label: 'our hardcoded rgb triangle shaders',
    code: `
+      struct OurVertexShaderOutput {
+        @builtin(position) position: vec4f,
+        @location(0) color: vec4f,
+      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
+        var color = array&lt;vec4f, 3&gt;(
+          vec4f(1, 0, 0, 1), // red
+          vec4f(0, 1, 0, 1), // green
+          vec4f(0, 0, 1, 1), // blue
+        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
      }

-      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+        return fsInput.color;
      }
    `,
  });
</pre>
<p>最初に<code class="notranslate" translate="no">struct</code>(構造体)を宣言しています。
これはinter-stage変数を使うための簡単な方法です。
この<code class="notranslate" translate="no">struct</code>を介して、頂点シェーダとフラグメントシェーダの間で
データの受け渡しをすることができます。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>頂点シェーダはは返り値として<code class="notranslate" translate="no">vec4f</code>型変数を返していましたが、
これを、構造体<code class="notranslate" translate="no">OurVertexShaderOutput</code>を返すように変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
</pre>
<p>三つの色を表す配列を用意します。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        var color = array&lt;vec4f, 3&gt;(
          vec4f(1, 0, 0, 1), // 赤
          vec4f(0, 1, 0, 1), // 緑
          vec4f(0, 0, 1, 1), // 青
        );
</pre>
<p>返り値として、位置を表す<code class="notranslate" translate="no">vec4f</code>ではなく、位置と色の情報を持つ構造体を返すようにします。
そのために、まず構造体のインスタンスを宣言します。
構造体の各項目に値が設定できたら、それをreturnします。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
</pre>
<p>フラグメントシェーダはこの構造体を、関数の引数として受け取るように変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
        return fsInput.color;
      }
</pre>
<p>フラグメントシェーダの返り値は、色です。受け取った構造体の中に入っています。</p>
<p>これを実行します。頂点シェーダは呼ばれるたびに赤、緑、青を、それぞれの頂点の情報として返します。
３つの点を結ぶ三角形を構成する各ピクセルを描くひとつひとつのフラグメントシェーダは、
３つの点の間で補間(interpolate)された色を受け取ります。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>inter-stage変数は、主に三角形中のテクスチャ座標の補間のために利用されます。
これについては「<a href="webgpu-textures.html">テクスチャについて</a>」で説明します。
ほかの用途としては、三角形の法線情報の補間があります。
これについては、光源処理に関する記事の１本目、
「<a href="webgpu-lighting-directional.html">平行光源について</a>」で扱います。</p>
<h2 id="inter-stage変数はlocationで結び付けられる">inter-stage変数は<code class="notranslate" translate="no">location</code>で結び付けられる</h2>
<p>頂点シェーダとフラグメントシェーダの間での情報の受け渡しは、インデックスを介して行われる、という点に注意してください。
インデックスを介したデータの受け渡し、という考え方は、inter-stage変数に限らずWebGPUの多くの場面で登場します。
inter-stage変数の場合、<code class="notranslate" translate="no">location</code>インデックスが使用されます。</p>
<p>「インデックスを介した」というのがどういうことか説明するために、試しにフラグメントシェーダ「だけ」変更してみます。
構造体<code class="notranslate" translate="no">OurVertexShaderOutput</code>ではなく、<code class="notranslate" translate="no">location(0)</code>の<code class="notranslate" translate="no">vec4f</code>を受け取るようにします。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(@location(0) color: vec4f) -&gt; @location(0) vec4f {
        return color;
      }
</pre>
<p>上のようなコードに変更しても、挙動は変わらずに動作します。
構造体や、変数の名前や、引数の記述順、ではなく、
<code class="notranslate" translate="no">location(0)</code>として明示的に指定したインデックスによって関係づけられている、ということです。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle-by-fn-param.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle-by-fn-param.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<h2 id="builtinpositionの仕組み"><code class="notranslate" translate="no">@builtin(position)</code>の仕組み</h2>
<p>これを踏まえて、<code class="notranslate" translate="no">@builtin(position)</code>について考えてみます。
今使用しているサンプルプログラムでは、頂点シェーダとフラグメントシェーダで、共通の構造体を使っています。
この構造体には<code class="notranslate" translate="no">position</code>というフィールドがあります。
<code class="notranslate" translate="no">position</code>には<code class="notranslate" translate="no">location</code>のインデックス情報がなく、替わりに<code class="notranslate" translate="no">@builtin(position)</code>と宣言されています。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
*        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>この構造体の<code class="notranslate" translate="no">position</code>フィールドは<strong>inter-stage変数ではありません</strong>。<code class="notranslate" translate="no">builtin</code>です。</p>
<p><code class="notranslate" translate="no">@builtin(position)</code>と記述されたものは、頂点シェーダとフラグメントシェーダで、違った解釈がされます。</p>
<p>頂点シェーダにおいては、<code class="notranslate" translate="no">@builtin(position)</code>とは出力で、GPUが三角形/線/点を描くために必要とする座標情報です。</p>
<p>フラグメントシェーダにおいては、<code class="notranslate" translate="no">@builtin(position)</code>は入力で、フラグメントシェーダが色を決めるべきピクセル、の座標情報です。
これは「ピクセル座標」です。</p>
<p>ピクセル座標は、ピクセルが構成する四角形の一端の頂点を(0,0)、同ピクセルの対角の頂点を(1,1)としています。
そして、フラグメントシェーダに渡されるのは、各ピクセルの中央の座標値です。
描画対象とするテクスチャが3x2ピクセルのサイズである場合、座標は次の図のようになります。</p>
<div class="webgpu_center"><img src="../resources/webgpu-pixels.svg" style="width: 500px;"></div>
<p>このピクセル座標によって色が決まるようなシェーダを書くこともできます。
例として、市松模様(checkerboard)を描いてみます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded checkerboard triangle shaders',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
-        @location(0) color: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
-        var color = array&lt;vec4f, 3&gt;(
-          vec4f(1, 0, 0, 1), // red
-          vec4f(0, 1, 0, 1), // green
-          vec4f(0, 0, 1, 1), // blue
-        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
-        vsOutput.color = color[vertexIndex];
        return vsOutput;
      }

      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-        return fsInput.color;
+        let red = vec4f(1, 0, 0, 1);
+        let cyan = vec4f(0, 1, 1, 1);
+
+        let grid = vec2u(fsInput.position.xy) / 8;
+        let checker = (grid.x + grid.y) % 2 == 1;
+
+        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>上のコードでは<code class="notranslate" translate="no">fsInput.position</code>を使っています。
この構造体フィールドは<code class="notranslate" translate="no">@builtin(position)</code>として宣言されています。
この<code class="notranslate" translate="no">vec4f</code>型の値から、<code class="notranslate" translate="no">xy</code>、つまり<code class="notranslate" translate="no">vec2f</code>型の座標値を取り出して、それを<code class="notranslate" translate="no">vec2u</code>型の値に変換しています。
<code class="notranslate" translate="no">vec2u</code>は符号なし整数値を2つ持つベクトルです。
これを8で割って、「8ピクセルごとに変化する」カウンタにしています。
このgridの座標<code class="notranslate" translate="no">x</code>と<code class="notranslate" translate="no">y</code>を足して<code class="notranslate" translate="no">% 2</code>（2で割った余り)を求めて、0か1の値を得ています。
その値が1ならtrue、0ならfalse、となる真偽値(boolean)としています。
この真偽値を元に、WGSLの組み込み関数<code class="notranslate" translate="no">select</code>を使って、<code class="notranslate" translate="no">red</code>と<code class="notranslate" translate="no">cyan</code>のどちらかの値を選択しています。
WGSLの<code class="notranslate" translate="no">select</code>関数の仕組みは、JavaScriptで表現するならこんな感じです
(下のJavaScriptコードが難解という人は「アロー関数」、「三項演算子」を調べてください)。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// 条件(condition)がfalseなら`a`の値を、そうでなければ`b`の値を返す。
select = (a, b, condition) =&gt; condition ? b : a;
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">@builtin(position)</code>をフラグメントシェーダ側のコード中で使わない場合でも、
頂点シェーダとフラグメントシェーダで「共通の構造体」が使える、というのは便利です。
一方で、共通の構造体を使っていても、頂点シェーダから見た<code class="notranslate" translate="no">position</code>フィールドと
フラグメントシェーダから見た<code class="notranslate" translate="no">position</code>フィールドは「関係がない、別の変数である」
ということは重要です。</p>
<p>inter-stage変数の本質は、ロケーション、<code class="notranslate" translate="no">@location(?)</code>の部分です。
重要なのは「ロケーションを合わせること」なので、
「頂点シェーダの出力」と「フラグメントシェーダの入力」で同じ構造体を使う必要はなく、
それぞれで別の書き方をするのはそれほど珍しいことではありません。</p>
<p>このことは、頂点シェーダ、フラグメントシェーダのソースコードが別々になっている場合を考えるとわかりやすいでしょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
-    label: 'hardcoded checkerboard triangle shaders',
+  const vsModule = device.createShaderModule({
+    label: 'hardcoded triangle',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
        return vsOutput;
      }
+    `,
+  });
+
+  const fsModule = device.createShaderModule({
+    label: 'checkerboard',
+    code: `
-      @fragment fn fs(@builtin(position) pixelPosition: vec4f) -&gt; @location(0) vec4f {
+      @fragment fn fs(@builtin(position) pixelPosition: vec4f) -&gt; @location(0) vec4f {
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);

-        let grid = vec2u(fsInput.position.xy) / 8;
+        let grid = vec2u(pixelPosition.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;

        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>シェーダモジュールが２つになるので、パイプラインの生成コードをそれに合わせて修正します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded checkerboard triangle pipeline',
    layout: 'auto',
    vertex: {
-      module,
+      module: vsModule,
    },
    fragment: {
-      module,
+      module: fsModule,
      targets: [{ format: presentationFormat }],
    },
  });

</pre>
<p>以上の変更後も、同じように動作します。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position-separate-modules.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position-separate-modules.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>WebGPUのサンプルプログラムではよく、２つのシェーダで１つの構造体を利用する書き方をします。
が、これは「便利だから」という以上の意味はない、というのが、この話題のポイントです。
実際のところ、この点においてはWebGPUは「WGSLが文法上正しいか」のチェックしかしません。
WebGPUは次に、指定した<code class="notranslate" translate="no">entryPoint</code>を確認しますが、これもentryPointがどこか、以上のチェックはしません。
頂点シェーダとフラグメントシェーダで@builtin(position)が別々の解釈をされても問題ありません。</p>
<p>プログラマの視点からすると、構造体やバインドグループの記述を各シェーダについて別々に書かずに済むのは、便利です。
一方で、WebGPUの視点からすると、構造体やバインドグループの記述は各シェーダそれぞれに書かれているように解釈されます。
ソースコード的には同じことが書かれていても、それぞれのシェーダで違った解釈がされる。それでも問題ない。ということです。</p>
<p>注：今回、市松模様を描くために<code class="notranslate" translate="no">@builtin(position)</code>を使っていますが、
これはあまり一般的なやり方ではありません。
市松模様に限らず、何がしかのパターンを描きたいとき、通常はテクスチャの仕組みを利用します。
これについては別の記事、「<a href="webgpu-textures.html">テクスチャについて</a>」で説明します。
今回のやり方に問題があることは、ウィンドウサイズを変えてみると観察することができます。
市松模様の「パターンの大きさ」はピクセル座標の値を元にしているので、
描画される三角形の大きさとは関係なく、canvasの解像度に依存して決定されます。</p>
<h2 id="「補間interpolation方法」の設定"><a id="a-interpolate"></a>「補間(interpolation)方法」の設定</h2>
<p>ここまで、inter-stage変数について見てきました。
inter-stage変数は、頂点シェーダで出力されて、「補間」されて、フラグメントシェーダに渡されます。
WebGPUでは、この「補間」をどうやるかについて、設定項目が２つあります。
「補間」については、デフォルトの設定以外で使いたいケースはほとんどありません。
そういった特殊ケースについては、別の記事で触れます。</p>
<p>補間タイプの設定：</p>
<ul>
<li><code class="notranslate" translate="no">perspective</code>: perspective correctで(３次元のパースに合うように)補間する(<strong>default</strong>)</li>
<li><code class="notranslate" translate="no">linear</code>: linearに(線形補間的に)、perspective correctでない形で補間する</li>
<li><code class="notranslate" translate="no">flat</code>: 補間しない。補間サンプリングを行なわない</li>
</ul>
<p>補間サンプリングの設定：</p>
<ul>
<li><code class="notranslate" translate="no">center</code>: 補間に際して「ピクセルの中心」をサンプリングする(<strong>default</strong>)</li>
<li><code class="notranslate" translate="no">centroid</code>: 補間に際して「プリミティブ(三角形などの基本図形)」単位でサンプリングする。プリミティブ内の全ピクセルで同じ値となる</li>
<li><code class="notranslate" translate="no">sample</code>:  補間を「サンプル」単位で行なう。フラグメントシェーダは各サンプルについて実行される</li>
<li><code class="notranslate" translate="no">first</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. (default) The value comes from the first vertex of the primitive being drawn</li>
<li><code class="notranslate" translate="no">either</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. The value comes from either the first or the last vertex of the primitive being drawn.</li>
</ul>
<p>補間の設定は、inter-stage変数の属性として記述します。たとえばこんな風に書きます。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  @location(2) @interpolate(linear, center) myVariableFoo: vec4f;
  @location(3) @interpolate(flat) myVariableBar: vec4f;
</pre>
<p>なお、inter-stage変数が整数型の場合は、<code class="notranslate" translate="no">flat</code>の設定にする必要があります。</p>
<p>補間タイプ<code class="notranslate" translate="no">flat</code>に設定した場合、フラグメントシェーダに渡される値は、
「三角形の１つめの頂点」のinter-stage変数の値です。</p>
<p>次の記事「<a href="webgpu-uniforms.html">uniform変数</a>」では、
シェーダにデータを渡す、別な方法を紹介します。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `inter-stage(シェーダ間)変数`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>