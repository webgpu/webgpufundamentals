<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-points.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPUã§ã®ãƒã‚¤ãƒ³ãƒˆã®æç”»">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-points_ja.jpg">

<meta property="og:title" content="WebGPU ãƒã‚¤ãƒ³ãƒˆ">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-points_ja.jpg">
<meta property="og:description" content="WebGPUã§ã®ãƒã‚¤ãƒ³ãƒˆã®æç”»">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU ãƒã‚¤ãƒ³ãƒˆ">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html">
<meta name="twitter:description" content="WebGPUã§ã®ãƒã‚¤ãƒ³ãƒˆã®æç”»">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-points_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-points_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html",
      "inLanguage":"ja",
      "name":"WebGPU ãƒã‚¤ãƒ³ãƒˆ",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-points.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU ãƒã‚¤ãƒ³ãƒˆ</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-points.html">English
    </option><option value="/webgpu/lessons/es/webgpu-points.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-points.html" selected="">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-points.html">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-points.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-points.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-points.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-points.html">ç®€ä½“ä¸­æ–‡
</option></select>


    <a href="#toc">ç›®æ¬¡</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU ãƒã‚¤ãƒ³ãƒˆ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">ã“ã®è¨˜äº‹ã¯Gemini Code Assistã«ã‚ˆã£ã¦è‡ªå‹•ç¿»è¨³ã•ã‚Œã¾ã—ãŸã€‚ç¿»è¨³ã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€ãŠæ‰‹æ•°ã§ã™ãŒ<a href="https://github.com/webgpu/webgpufundamentals/pulls">ã“ã¡ã‚‰</a>ã‹ã‚‰Pull Requestã‚’é€ä¿¡ã—ã¦ãã ã•ã„ã€‚</div>
<p>WebGPUã¯ãƒã‚¤ãƒ³ãƒˆã¸ã®æç”»ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ã‚’<code class="notranslate" translate="no">'point-list'</code>ã«è¨­å®šã—ã¾ã™ã€‚</p>
<p><a href="webgpu-vertex-buffers.html">é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§ç´¹ä»‹ã—ãŸã‚¢ã‚¤ãƒ‡ã‚¢ã‹ã‚‰å§‹ã‚ã¦ã€ãƒ©ãƒ³ãƒ€ãƒ ãªãƒã‚¤ãƒ³ãƒˆã‚’æŒã¤ç°¡å˜ãªä¾‹ã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ã€‚</p>
<p>ã¾ãšã€å˜ç´”ãªé ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã¨ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã§ã™ã€‚ç°¡å˜ã«ã™ã‚‹ãŸã‚ã«ã€ä½ç½®ã«ã¯ã‚¯ãƒªãƒƒãƒ—ç©ºé–“åº§æ¨™ã‚’ä½¿ç”¨ã—ã€ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã§ã¯è‰²ã‚’é»„è‰²ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
};

@vertex fn vs(vert: Vertex,) -&gt; VSOutput {
  var vsOut: VSOutput;
  vsOut.position = vert.position;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vec4f(1, 1, 0, 1); // yellow
}
</pre>
<p>æ¬¡ã«ã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’ä½œæˆã™ã‚‹ã¨ãã«ã€ãƒˆãƒãƒ­ã‚¸ã‚’<code class="notranslate" translate="no">'point-list'</code>ã«è¨­å®šã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '1 pixel points',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
+    primitive: {
+      topology: 'point-list',
+    },
  });
</pre>
<p>é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã«ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¯ãƒªãƒƒãƒ—ç©ºé–“ãƒã‚¤ãƒ³ãƒˆã‚’ã„ãã¤ã‹å…¥åŠ›ã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const rand = (min, max) =&gt; min + Math.random() * (max - min);

  const kNumPoints = 100;
  const vertexData = new Float32Array(kNumPoints * 2);
  for (let i = 0; i &lt; kNumPoints; ++i) {
    const offset = i * 2;
    vertexData[offset + 0] = rand(-1, 1);
    vertexData[offset + 1] = rand(-1, 1);
  }

  const vertexBuffer = device.createBuffer({
    label: 'vertex buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
</pre>
<p>ãã—ã¦ã€æç”»ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.draw(kNumPoints);
    pass.end();
</pre>
<p>ãã—ã¦ã€100å€‹ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé»„è‰²ã®ç‚¹ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<p>æ®‹å¿µãªãŒã‚‰ã€ãã‚Œã‚‰ã¯ã™ã¹ã¦1ãƒ”ã‚¯ã‚»ãƒ«ã®ã‚µã‚¤ã‚ºã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚1ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚ºã®ãƒã‚¤ãƒ³ãƒˆã¯ã€WebGPUãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã™ã¹ã¦ã§ã™ã€‚ã‚‚ã£ã¨å¤§ããªã‚‚ã®ãŒå¿…è¦ãªå ´åˆã¯ã€è‡ªåˆ†ã§è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å¹¸ã„ãªã“ã¨ã«ã€ãã‚Œã¯ç°¡å˜ã§ã™ã€‚ã‚¯ãƒ¯ãƒƒãƒ‰ã‚’ä½œæˆã—ã€<a href="webgpu-vertex-buffers.html#a-instancing">ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–</a>ã‚’ä½¿ç”¨ã™ã‚‹ã ã‘ã§ã™ã€‚</p>
<p>é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«ã‚¯ãƒ¯ãƒƒãƒ‰ã¨ã‚µã‚¤ã‚ºå±æ€§ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚ã¾ãŸã€æç”»ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚µã‚¤ã‚ºã‚’æ¸¡ã™ãŸã‚ã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚‚è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
+  @location(1) size: f32,
};

+struct Uniforms {
+  resolution: vec2f,
+};

struct VSOutput {
  @builtin(position) position: vec4f,
};

+@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
    vert: Vertex,
+    @builtin(vertex_index) vNdx: u32,
) -&gt; VSOutput {
+  let points = array(
+    vec2f(-1, -1),
+    vec2f( 1, -1),
+    vec2f(-1,  1),
+    vec2f(-1,  1),
+    vec2f( 1, -1),
+    vec2f( 1,  1),
+  );
  var vsOut: VSOutput;
+  let pos = points[vNdx];
-  vsOut.position = vec4f(vert.position, 0, 1);
+  vsOut.position = vec4f(vert.position + pos * vert.size / uni.resolution, 0, 1);
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vec4f(1, 1, 0, 1); // yellow
}
</pre>
<p>JavaScriptã§ã¯ã€ãƒã‚¤ãƒ³ãƒˆã”ã¨ã«ã‚µã‚¤ã‚ºå±æ€§ã‚’è¿½åŠ ã—ã€<code class="notranslate" translate="no">stepMode: 'instance'</code>ã‚’è¨­å®šã—ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã«å±æ€§ã‚’é€²ã‚ã‚‹ã‚ˆã†ã«è¨­å®šã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®<code class="notranslate" translate="no">'triangle-list'</code>ãŒå¿…è¦ãªã®ã§ãƒˆãƒãƒ­ã‚¸è¨­å®šã‚’å‰Šé™¤ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'sizeable points',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: 2 * 4, // 2 floats, 4 bytes each
+          arrayStride: (2 + 1) * 4, // 3 floats, 4 bytes each
+          stepMode: 'instance',
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
+            {shaderLocation: 1, offset: 8, format: 'float32'},  // size
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
-    primitive: {
-      topology: 'point-list',
-    },
  });
</pre>
<p>é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã«ãƒã‚¤ãƒ³ãƒˆã”ã¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNumPoints = 100;
-  const vertexData = new Float32Array(kNumPoints * 2);
+  const vertexData = new Float32Array(kNumPoints * 3);
  for (let i = 0; i &lt; kNumPoints; ++i) {
-    const offset = i * 2;
+    const offset = i * 3;
    vertexData[offset + 0] = rand(-1, 1);
    vertexData[offset + 1] = rand(-1, 1);
+    vertexData[offset + 2] = rand(1, 32);
  }
</pre>
<p>è§£åƒåº¦ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã€ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ãŒå¿…è¦ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const uniformValues = new Float32Array(2);
  const uniformBuffer = device.createBuffer({
    size: uniformValues.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  const kResolutionOffset = 0;
  const resolutionValue = uniformValues.subarray(
      kResolutionOffset, kResolutionOffset + 2);
</pre>
<p>ãã—ã¦ã€ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã‚’ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ãŸã‚ã®ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ãŒå¿…è¦ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer }},
    ],
  });
</pre>
<p>æ¬¡ã«ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã«ã€ç¾åœ¨ã®è§£åƒåº¦ã§ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã‚’æ›´æ–°ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç¾åœ¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å–å¾—ã—ã€
    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦è¨­å®šã—ã¾ã™ã€‚
    const canvasTexture = context.getCurrentTexture();
    renderPassDescriptor.colorAttachments[0].view =
        canvasTexture.createView();

+    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã®è§£åƒåº¦ã‚’æ›´æ–°ã—ã¾ã™
+    resolutionValue.set([canvasTexture.width, canvasTexture.height]);
+    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<p>æ¬¡ã«ã€ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¨­å®šã—ã€ãƒã‚¤ãƒ³ãƒˆã”ã¨ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
+    pass.setBindGroup(0, bindGroup);
-    pass.draw(kNumPoints);
+    pass.draw(6, kNumPoints);
    pass.end();
</pre>
<p>ãã—ã¦ã€ã‚µã‚¤ã‚ºå¤‰æ›´å¯èƒ½ãªãƒã‚¤ãƒ³ãƒˆãŒã§ãã¾ã—ãŸã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-w-size.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-w-size.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<p>ãƒã‚¤ãƒ³ãƒˆã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä»˜ã‘ãŸã„å ´åˆã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã—ã‚‡ã†ã‹ï¼Ÿé ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã‚’æ¸¡ã™ã ã‘ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
  @location(1) size: f32,
};

struct Uniforms {
  resolution: vec2f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
+  @location(0) texcoord: vec2f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
    vert: Vertex,
    @builtin(vertex_index) vNdx: u32,
) -&gt; VSOutput {
  let points = array(
    vec2f(-1, -1),
    vec2f( 1, -1),
    vec2f(-1,  1),
    vec2f(-1,  1),
    vec2f( 1, -1),
    vec2f( 1,  1),
  );
  var vsOut: VSOutput;
  let pos = points[vNdx];
  vsOut.position = vec4f(vert.position + pos * vert.size / uni.resolution, 0, 1);
+  vsOut.texcoord = pos * 0.5 + 0.5;
  return vsOut;
}
</pre>
<p>ãã—ã¦ã‚‚ã¡ã‚ã‚“ã€ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã§ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+@group(0) @binding(1) var s: sampler;
+@group(0) @binding(2) var t: texture_2d&lt;f32&gt;;

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
-  return vec4f(1, 1, 0, 1); // yellow
+  return textureSample(t, s, vsOut.texcoord);
}
</pre>
<p><a href="webgpu-importing-textures.html">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½¿ç”¨ã—ã¦å˜ç´”ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const ctx = new OffscreenCanvas(32, 32).getContext('2d');
  ctx.font = '27px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('ğŸ¥‘', 16, 16);

  const texture = device.createTexture({
    size: [32, 32],
    format: 'rgba8unorm',
    usage: GPUTextureUsage.TEXTURE_BINDING |
           GPUTextureUsage.COPY_DST |
           GPUTextureUsage.RENDER_ATTACHMENT,
  });
  device.queue.copyExternalImageToTexture(
    { source: ctx.canvas, flipY: true },
    { texture, premultipliedAlpha: true },
    [32, 32],
  );
</pre>
<p>ãã—ã¦ã€ã‚µãƒ³ãƒ—ãƒ©ãƒ¼ãŒå¿…è¦ã§ã‚ã‚Šã€ãã‚Œã‚‰ã‚’ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã«è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const sampler = device.createSampler({
    minFilter: 'linear',
    magFilter: 'linear',
  });

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer }},
+      { binding: 1, resource: sampler },
+      { binding: 2, resource: texture.createView() },
    ],
  });
</pre>
<p><a href="webgpu-transparency.html">é€æ˜åº¦</a>ã‚’å¾—ã‚‹ãŸã‚ã«ã€ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚‚ã‚ªãƒ³ã«ã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'sizeable points with texture',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (2 + 1) * 4, // 3 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
            {shaderLocation: 1, offset: 8, format: 'float32'},  // size
          ],
        },
      ],
    },
    fragment: {
      module,
-      targets: [{ format: presentationFormat }],
+      targets: [
+        {
+         format: presentationFormat,
+          blend: {
+            color: {
+              srcFactor: 'one',
+              dstFactor: 'one-minus-src-alpha',
+              operation: 'add',
+            },
+            alpha: {
+              srcFactor: 'one',
+              dstFactor: 'one-minus-src-alpha',
+              operation: 'add',
+            },
+          },
+        },
+      ],
    },
  });
</pre>
<p>ãã—ã¦ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ä»˜ãã®ãƒã‚¤ãƒ³ãƒˆãŒã§ãã¾ã—ãŸã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-w-texture.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-w-texture.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<p>ãã—ã¦ã€ç¶šã‘ã¦ã„ãã“ã¨ãŒã§ãã¾ã™ã€‚ãƒã‚¤ãƒ³ãƒˆã”ã¨ã«å›è»¢ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ<a href="webgpu-matrix-math.html">è¡Œåˆ—æ¼”ç®—ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã§èª¬æ˜ã—ãŸæ•°å­¦ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
  @location(1) size: f32,
+  @location(2) rotation: f32,
};

struct Uniforms {
  resolution: vec2f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
    vert: Vertex,
    @builtin(vertex_index) vNdx: u32,
) -&gt; VSOutput {
  let points = array(
    vec2f(-1, -1),
    vec2f( 1, -1),
    vec2f(-1,  1),
    vec2f(-1,  1),
    vec2f( 1, -1),
    vec2f( 1,  1),
  );
  var vsOut: VSOutput;
  let pos = points[vNdx];
+  let c = cos(vert.rotation);
+  let s = sin(vert.rotation);
+  let rot = mat2x2f(
+     c, s,
+    -s, c,
+  );
-  vsOut.position = vec4f(vert.position + pos * vert.size / uni.resolution, 0, 1);
+  vsOut.position = vec4f(vert.position + rot * pos * vert.size / uni.resolution, 0, 1);
  vsOut.texcoord = pos * 0.5 + 0.5;
  return vsOut;
      }
</pre>
<p>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«å›è»¢å±æ€§ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'sizeable rotatable points with texture',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: (2 + 1) * 4, // 3 floats, 4 bytes each
+          arrayStride: (2 + 1 + 1) * 4, // 4 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
            {shaderLocation: 1, offset: 8, format: 'float32'},  // size
+            {shaderLocation: 2, offset: 12, format: 'float32'},  // rotation
          ],
        },
      ],
    },
    ...
</pre>
<p>é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã«å›è»¢ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNumPoints = 100;
-  const vertexData = new Float32Array(kNumPoints * 3);
+  const vertexData = new Float32Array(kNumPoints * 4);
  for (let i = 0; i &lt; kNumPoints; ++i) {
-    const offset = i * 3;
+    const offset = i * 4;
    vertexData[offset + 0] = rand(-1, 1);
    vertexData[offset + 1] = rand(-1, 1);
*    vertexData[offset + 2] = rand(10, 64);
+    vertexData[offset + 3] = rand(0, Math.PI * 2);
  }

</pre>
<p>ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ğŸ¥‘ã‹ã‚‰ğŸ‘‰ã«å¤‰æ›´ã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  ctx.fillText('ğŸ¥‘', 16, 16);
+  ctx.fillText('ğŸ‘‰', 16, 16);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-w-rotation.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-w-rotation.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<h1 id="3dã®ãƒã‚¤ãƒ³ãƒˆã¯ã©ã†ã§ã™ã‹ï¼Ÿ">3Dã®ãƒã‚¤ãƒ³ãƒˆã¯ã©ã†ã§ã™ã‹ï¼Ÿ</h1>
<p>ç°¡å˜ãªç­”ãˆã¯ã€<a href="webgpu-perspective-projection.html">é ‚ç‚¹ã®3Dæ•°å­¦</a>ã‚’è¡Œã£ãŸå¾Œã€ã‚¯ãƒ¯ãƒƒãƒ‰å€¤ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ã™ã€‚</p>
<p>ãŸã¨ãˆã°ã€<a href="https://www.google.com/search?q=fibonacci+sphere">ãƒ•ã‚£ãƒœãƒŠãƒƒãƒçƒ</a>ã®3Dä½ç½®ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createFibonacciSphereVertices({
  numSamples,
  radius,
}) {
  const vertices = [];
  const increment = Math.PI * (3 - Math.sqrt(5));
  for (let i = 0; i &lt; numSamples; ++i) {
    const offset = 2 / numSamples;
    const y = ((i * offset) - 1) + (offset / 2);
    const r = Math.sqrt(1 - Math.pow(y, 2));
    const phi = (i % numSamples) * increment;
    const x = Math.cos(phi) * r;
    const z = Math.sin(phi) * r;
    vertices.push(x * radius, y * radius, z * radius);
  }
  return new Float32Array(vertices);
}
</pre>
<p><a href="../webgpu-cameras.js">3Dæ•°å­¦ã«é–¢ã™ã‚‹ã‚·ãƒªãƒ¼ã‚ºã§èª¬æ˜ã—ãŸã‚ˆã†ã«</a>ã€é ‚ç‚¹ã«3Dæ•°å­¦ã‚’é©ç”¨ã—ã¦ãƒã‚¤ãƒ³ãƒˆã§é ‚ç‚¹ã‚’æç”»ã§ãã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec4f,
};

struct Uniforms {
*  matrix: mat4x4f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
    vert: Vertex,
) -&gt; VSOutput {
  var vsOut: VSOutput;
*  let clipPos = uni.matrix * vert.position;
  vsOut.position = clipPos;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vec4f(1, 0.5, 0.2, 1);  // orange
}
</pre>
<p>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '3d points with fixed size',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (3) * 4, // 3 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [
        {
         format: presentationFormat,
        },
      ],
    },
    primitive: {
      topology: 'point-list',
    },
  });

  const vertexData = createFibonacciSphereVertices({
    radius: 1,
    numSamples: 1000,
  });
  const kNumPoints = vertexData.length / 3;

  const vertexBuffer = device.createBuffer({
    label: 'vertex buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
</pre>
<p>ãã—ã¦ã€è¡Œåˆ—ç”¨ã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã¨ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã€ãŠã‚ˆã³ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã‚’ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«æ¸¡ã™ãŸã‚ã®ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const uniformValues = new Float32Array(16);
  const uniformBuffer = device.createBuffer({
    size: uniformValues.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  const kMatrixOffset = 0;
  const matrixValue = uniformValues.subarray(
      kMatrixOffset, kMatrixOffset + 16);

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer }},
    ],
  });
</pre>
<p>ãã—ã¦ã€å°„å½±è¡Œåˆ—ã€ã‚«ãƒ¡ãƒ©ã€ãã®ä»–ã®3Dæ•°å­¦ã‚’ä½¿ç”¨ã—ã¦æç”»ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(time) {
    time *= 0.001;

    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç¾åœ¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å–å¾—ã—ã€
    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦è¨­å®šã—ã¾ã™ã€‚
    const canvasTexture = context.getCurrentTexture();
    renderPassDescriptor.colorAttachments[0].view =
        canvasTexture.createView();

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã«è¡Œåˆ—ã‚’è¨­å®šã—ã¾ã™
    const fov = 90 * Math.PI / 180;
    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(fov, aspect, 0.1, 50);
    const view = mat4.lookAt(
      [0, 0, 1.5],  // position
      [0, 0, 0],    // target
      [0, 1, 0],    // up
    );
    const viewProjection = mat4.multiply(projection, view);
    mat4.rotateY(viewProjection, time, matrixValue);
    mat4.rotateX(matrixValue, time * 0.5, matrixValue);

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’GPUã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.setBindGroup(0, bindGroup);
    pass.draw(kNumPoints);
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
</pre>
<p><code class="notranslate" translate="no">requestAnimationFrame</code>ãƒ«ãƒ¼ãƒ—ã«ã‚‚åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-3d-1px.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-3d-1px.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<p>è¦‹ã«ãã„ã®ã§ã€ä¸Šè¨˜ã®æ‰‹æ³•ã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€ä»¥å‰ã«è¡Œã£ãŸã‚ˆã†ã«ã‚¯ãƒ¯ãƒƒãƒ‰ä½ç½®ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec4f,
};

struct Uniforms {
  matrix: mat4x4f,
+  resolution: vec2f,
+  size: f32,
};

struct VSOutput {
  @builtin(position) position: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
    vert: Vertex,
+    @builtin(vertex_index) vNdx: u32,
) -&gt; VSOutput {
+  let points = array(
+    vec2f(-1, -1),
+    vec2f( 1, -1),
+    vec2f(-1,  1),
+    vec2f(-1,  1),
+    vec2f( 1, -1),
+    vec2f( 1,  1),
+  );
  var vsOut: VSOutput;
+  let pos = points[vNdx];
  let clipPos = uni.matrix * vert.position;
+  let pointPos = vec4f(pos * uni.size / uni.resolution, 0, 0);
-  vsOut.position = clipPos;
+  vsOut.position = clipPos + pointPos;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vec4f(1, 0.5, 0.2, 1);
}
</pre>
<p>å‰ã®ä¾‹ã¨ã¯ç•°ãªã‚Šã€å„é ‚ç‚¹ã«ç•°ãªã‚‹ã‚µã‚¤ã‚ºã¯ä½¿ç”¨ã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ã™ã¹ã¦ã®é ‚ç‚¹ã«å˜ä¸€ã®ã‚µã‚¤ã‚ºã‚’æ¸¡ã—ã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const uniformValues = new Float32Array(16);
+  const uniformValues = new Float32Array(16 + 2 + 1 + 1);
  const uniformBuffer = device.createBuffer({
    size: uniformValues.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  const kMatrixOffset = 0;
+  const kResolutionOffset = 16;
+  const kSizeOffset = 18;
  const matrixValue = uniformValues.subarray(
      kMatrixOffset, kMatrixOffset + 16);
+  const resolutionValue = uniformValues.subarray(
+      kResolutionOffset, kResolutionOffset + 2);
+  const sizeValue = uniformValues.subarray(
+      kSizeOffset, kSizeOffset + 1);
</pre>
<p>ä¸Šè¨˜ã®ã‚ˆã†ã«è§£åƒåº¦ã‚’è¨­å®šã—ã€ã‚µã‚¤ã‚ºã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(time) {
    ...
+    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã«ã‚µã‚¤ã‚ºã‚’è¨­å®šã—ã¾ã™
+    sizeValue[0] = 10;

    const fov = 90 * Math.PI / 180;
    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(fov, aspect, 0.1, 50);
    const view = mat4.lookAt(
      [0, 0, 1.5],  // position
      [0, 0, 0],    // target
      [0, 1, 0],    // up
    );
    const viewProjection = mat4.multiply(projection, view);
    mat4.rotateY(viewProjection, time, matrixValue);
    mat4.rotateX(matrixValue, time * 0.5, matrixValue);

+    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã®è§£åƒåº¦ã‚’æ›´æ–°ã—ã¾ã™
+    resolutionValue.set([canvasTexture.width, canvasTexture.height]);

    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å€¤ã‚’GPUã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<p>ãã—ã¦ã€ä»¥å‰ã«è¡Œã£ãŸã‚ˆã†ã«ã€ãƒã‚¤ãƒ³ãƒˆã®æç”»ã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸã‚¯ãƒ¯ãƒƒãƒ‰ã®æç”»ã«åˆ‡ã‚Šæ›¿ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '3d points',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (3) * 4, // 3 floats, 4 bytes each
+          stepMode: 'instance',
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [
        {
         format: presentationFormat,
        },
      ],
    },
-    primitive: {
-      topology: 'point-list',
-    },
  });

  ...

  function render(time) {

    ...

-    pass.draw(kNumPoints);
+    pass.draw(6, kNumPoints);

    ...
</pre>
<p>ã“ã‚Œã«ã‚ˆã‚Šã€3Dã®ãƒã‚¤ãƒ³ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ã‚«ãƒ¡ãƒ©ã‹ã‚‰ã®è·é›¢ã«åŸºã¥ã„ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚‚ã•ã‚Œã¾ã™ã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-3d.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-3d.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<h2 id="å›ºå®šã‚µã‚¤ã‚ºã®3dãƒã‚¤ãƒ³ãƒˆ"><a id="a-fixed-size-3d-points"></a>å›ºå®šã‚µã‚¤ã‚ºã®3Dãƒã‚¤ãƒ³ãƒˆ</h2>
<p>ãƒã‚¤ãƒ³ãƒˆã®ã‚µã‚¤ã‚ºã‚’å›ºå®šã—ãŸã„å ´åˆã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
<p><a href="webgpu-perspective-projection.html">é è¿‘æŠ•å½±ã«é–¢ã™ã‚‹è¨˜äº‹</a>ã‹ã‚‰ã€GPUã¯é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¿”ã™ä½ç½®ã‚’Wã§é™¤ç®—ã™ã‚‹ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚ã“ã®é™¤ç®—ã«ã‚ˆã‚Šã€é ãã®ã‚‚ã®ãŒå°ã•ãè¦‹ãˆã‚‹é è¿‘æ„ŸãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ãŸããªã„ãƒã‚¤ãƒ³ãƒˆã«ã¤ã„ã¦ã¯ã€ãã‚Œã‚‰ã‚’ãã®Wã§ä¹—ç®—ã™ã‚‹ã ã‘ã§ã€é™¤ç®—ã•ã‚ŒãŸå¾Œã«æœ¬å½“ã«æ¬²ã—ã‹ã£ãŸå€¤ã«ãªã‚Šã¾ã™ã€‚</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">    var vsOut: VSOutput;
    let pos = points[vNdx];
    let clipPos = uni.matrix * vert.position;
-    let pointPos = vec4f(pos * uni.size / uni.resolution, 0, 0);
+    let pointPos = vec4f(pos * uni.size / uni.resolution * clipPos.w, 0, 0);
    vsOut.position = clipPos + pointPos;
    return vsOut;
</pre>
<p>ãã—ã¦ã€ä»Šã§ã¯åŒã˜ã‚µã‚¤ã‚ºã‚’ç¶­æŒã—ã¾ã™ã€‚</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-points-3d-fixed-size.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-points-3d-fixed-size.html" target="_blank">ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã</a>
</div>

<p></p>
<div class="webgpu_bottombar">
<h3>ãªãœWebGPUã¯1x1ãƒ”ã‚¯ã‚»ãƒ«ã‚ˆã‚Šå¤§ãã„ãƒã‚¤ãƒ³ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„ã®ã§ã™ã‹ï¼Ÿ</h3>
<p>WebGPUã¯ã€Vulkanã€Metalã€DirectXã€ã•ã‚‰ã«ã¯OpenGLãªã©ã®ãƒã‚¤ãƒ†ã‚£ãƒ–GPU APIã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚æ®‹å¿µãªãŒã‚‰ã€ã“ã‚Œã‚‰ã®APIã¯ã€ãƒã‚¤ãƒ³ãƒˆã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã®æ„å‘³ã«ã¤ã„ã¦äº’ã„ã«åŒæ„ã—ã¦ã„ã¾ã›ã‚“ã€‚ä¸€éƒ¨ã®APIã«ã¯ã€ãƒã‚¤ãƒ³ãƒˆã®ã‚µã‚¤ã‚ºã«ãƒ‡ãƒã‚¤ã‚¹ä¾å­˜ã®åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚ä¸€éƒ¨ã®APIã¯ã€ä¸­å¿ƒãŒã‚¯ãƒªãƒƒãƒ—ã‚¹ãƒšãƒ¼ã‚¹ã®å¤–å´ã«ã‚ã‚‹å ´åˆã€ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¾ã›ã‚“ãŒã€ä»–ã®APIã¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚ä¸€éƒ¨ã®APIã§ã¯ã€ã“ã®2ç•ªç›®ã®å•é¡Œã¯ãƒ‰ãƒ©ã‚¤ãƒãƒ¼æ¬¡ç¬¬ã§ã™ã€‚ã“ã‚Œã‚‰ã™ã¹ã¦ãŒã€WebGPUãŒãƒãƒ¼ã‚¿ãƒ–ãƒ«ãªã“ã¨ã‚’è¡Œã„ã€1x1ã‚µã‚¤ã‚ºã®ãƒ”ã‚¯ã‚»ãƒ«ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’æ±ºå®šã—ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</p>
<p>è‰¯ã„ç‚¹ã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ã«ã€ã‚ˆã‚Šå¤§ããªãƒã‚¤ãƒ³ãƒˆã‚’è‡ªåˆ†ã§ç°¡å˜ã«ã‚µãƒãƒ¼ãƒˆã§ãã‚‹ã“ã¨ã§ã™ã€‚ä¸Šè¨˜ã®è§£æ±ºç­–ã¯ã€ãƒ‡ãƒã‚¤ã‚¹é–“ã§ãƒãƒ¼ã‚¿ãƒ–ãƒ«ã§ã‚ã‚Šã€ãƒã‚¤ãƒ³ãƒˆã®ã‚µã‚¤ã‚ºã«åˆ¶é™ãŒãªãã€ãƒ‡ãƒã‚¤ã‚¹é–“ã§ä¸€è²«ã—ã¦ãƒã‚¤ãƒ³ãƒˆã‚’ã‚¯ãƒªãƒƒãƒ—ã—ã¾ã™ã€‚ãƒã‚¤ãƒ³ãƒˆã®ä¸­å¿ƒãŒã‚¯ãƒªãƒƒãƒ—ã‚¹ãƒšãƒ¼ã‚¹ã®å¤–å´ã«ã‚ã‚‹ã‹ã©ã†ã‹ã«é–¢ä¿‚ãªãã€ã‚¯ãƒªãƒƒãƒ—ã‚¹ãƒšãƒ¼ã‚¹ã®å†…å´ã«ã‚ã‚‹ãƒã‚¤ãƒ³ãƒˆã®éƒ¨åˆ†ã‚’æç”»ã—ã¾ã™ã€‚</p>
<p>ã•ã‚‰ã«è‰¯ã„ã“ã¨ã«ã€ã“ã‚Œã‚‰ã®è§£æ±ºç­–ã¯ã‚ˆã‚ŠæŸ”è»Ÿã§ã™ã€‚ãŸã¨ãˆã°ã€ãƒã‚¤ãƒ³ãƒˆã®å›è»¢ã¯ã€ãƒã‚¤ãƒ†ã‚£ãƒ–APIã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‹¬è‡ªã®è§£æ±ºç­–ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå¤šãã®æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ã€ç‰©äº‹ã‚’ã•ã‚‰ã«æŸ”è»Ÿã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-points.html">English
    </option><option value="/webgpu/lessons/es/webgpu-points.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-points.html" selected="">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-points.html">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-points.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-points.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-points.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-points.html">ç®€ä½“ä¸­æ–‡
</option></select>


        <div id="toc">
          <ul>  <li>åŸºæœ¬</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">åŸºæœ¬</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stageå¤‰æ•°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ </a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒƒãƒ•ã‚¡</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡</a></li>
  <li>ãƒ†ã‚¯ã‚¹ãƒãƒ£</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">ãƒ†ã‚¯ã‚¹ãƒãƒ£</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">ç”»åƒã®èª­ã¿è¾¼ã¿</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ãƒ“ãƒ‡ã‚ªã®ä½¿ç”¨</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ†ã‚¯ã‚¹ãƒãƒ£</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">å®šæ•°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">æ§‹é€ ä½“ã¨ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">é€æ˜åº¦ã¨ãƒ–ãƒ¬ãƒ³ãƒ‡ã‚£ãƒ³ã‚°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">ãƒã‚¤ãƒ³ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã¨åˆ¶é™</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">ä»•çµ„ã¿</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">äº’æ›ãƒ¢ãƒ¼ãƒ‰</a></li>
        </ul>
  <li>3Dã®æ•°å­¦</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">å¹³è¡Œç§»å‹•</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">å›è»¢</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">ã‚¹ã‚±ãƒ¼ãƒ«</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">è¡Œåˆ—æ¼”ç®—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">æ­£å°„å½±</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">é€è¦–æŠ•å½±</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">ã‚«ãƒ¡ãƒ©</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">è¡Œåˆ—ã‚¹ã‚¿ãƒƒã‚¯</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">ã‚·ãƒ¼ãƒ³ã‚°ãƒ©ãƒ•</a></li>
        </ul>
  <li>ãƒ©ã‚¤ãƒˆ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">æŒ‡å‘æ€§ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">ç‚¹å…‰æº</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ</a></li>
        </ul>
  <li>ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">å¤§ããªã‚¯ãƒªãƒƒãƒ—ç©ºé–“ã®ä¸‰è§’å½¢</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">ç’°å¢ƒãƒãƒƒãƒ—</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹</a></li>
        </ul>
  <li>ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">åŸºæœ¬çš„ãªCRTã‚¨ãƒ•ã‚§ã‚¯ãƒˆ</a></li>
        </ul>
        </ul>
  <li>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆã‚·ã‚§ãƒ¼ãƒ€</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®åŸºæœ¬</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">ç”»åƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">ç”»åƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ  ãƒ‘ãƒ¼ãƒˆ2</a></li>
        </ul>
  <li>ãã®ä»–ã®ãƒˆãƒ”ãƒƒã‚¯</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">è¤‡æ•°ã®ã‚­ãƒ£ãƒ³ãƒã‚¹</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ãƒã‚¤ãƒ³ãƒˆ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLã‹ã‚‰WebGPUã¸</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">é€Ÿåº¦ã¨æœ€é©åŒ–</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">ãƒ‡ãƒãƒƒã‚°ã¨ã‚¨ãƒ©ãƒ¼</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">ãƒªã‚½ãƒ¼ã‚¹ / å‚è€ƒæ–‡çŒ®</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL é–¢æ•°ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—æ©Ÿ</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>å•é¡Œç‚¹/ãƒã‚°? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubã§issueã‚’ä½œæˆ</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU ãƒã‚¤ãƒ³ãƒˆ`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>