<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-uniforms.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="シェーダーへの定数データの受け渡し">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ja.jpg">

<meta property="og:title" content="WebGPU ユニフォーム">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ja.jpg">
<meta property="og:description" content="シェーダーへの定数データの受け渡し">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU ユニフォーム">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html">
<meta name="twitter:description" content="シェーダーへの定数データの受け渡し">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html",
      "inLanguage":"ja",
      "name":"WebGPU ユニフォーム",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-uniforms.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU ユニフォーム</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-uniforms.html">English
    </option><option value="/webgpu/lessons/es/webgpu-uniforms.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-uniforms.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-uniforms.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-uniforms.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-uniforms.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-uniforms.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-uniforms.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU ユニフォーム</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>前の記事は<a href="webgpu-inter-stage-variables.html">ステージ間変数</a>に関するものでした。この記事はユニフォームに関するものです。</p>
<p>ユニフォームは、シェーダーのグローバル変数のようなものです。シェーダーを実行する前に値を設定でき、シェーダーの各反復でそれらの値を持ちます。次にGPUにシェーダーを実行するように依頼するときに、別の値に設定できます。</p>
<p><a href="webgpu-fundamentals.html">最初の記事</a>の三角形の例から始めて、いくつかのユニフォームを使用するように変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'triangle shaders with uniforms',
    code: `
+      struct OurStruct {
+        color: vec4f,
+        scale: vec2f,
+        offset: vec2f,
+      };
+
+      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        return vec4f(
+          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+        return ourStruct.color;
      }
    `,
  });

  });
</pre>
<p>まず、3つのメンバーを持つ構造体を宣言しました。</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">      struct OurStruct {
        color: vec4f,
        scale: vec2f,
        offset: vec2f,
      };
</pre>
<p>次に、その構造体の型のユニフォーム変数を宣言しました。変数は<code class="notranslate" translate="no">ourStruct</code>で、その型は<code class="notranslate" translate="no">OurStruct</code>です。</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
</pre>
<p>次に、頂点シェーダーから返されるものを変更して、ユニフォームを使用するようにしました。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
         ...
      ) ... {
        ...
        return vec4f(
          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
      }
</pre>
<p>頂点位置にスケールを乗算し、オフセットを追加していることがわかります。これにより、三角形のサイズを設定し、配置できます。</p>
<p>また、フラグメントシェーダーを変更して、ユニフォームから色を返すようにしました。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs() -&gt; @location(0) vec4f {
        return ourStruct.color;
      }
</pre>
<p>シェーダーをユニフォームを使用するように設定したので、GPU上に値を保持するためのバッファを作成する必要があります。</p>
<p>これは、ネイティブデータとサイズを扱ったことがない場合、学ぶべきことがたくさんある領域です。これは大きなトピックなので、<a href="webgpu-memory-layout.html">このトピックに関する別の記事があります</a>。メモリ内の構造体のレイアウト方法がわからない場合は、<a href="webgpu-memory-layout.html">記事を読んでください</a>。その後、ここに戻ってきてください。この記事は、<a href="webgpu-memory-layout.html">すでに読んだ</a>ことを前提としています。</p>
<p><a href="webgpu-memory-layout.html">記事</a>を読んだので、シェーダーの構造体に一致するデータでバッファを埋めることができます。</p>
<p>まず、バッファを作成し、ユニフォームで使用できるように、またデータをコピーして更新できるように、使用法フラグを割り当てます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const uniformBufferSize =
    4 * 4 + // colorは4つの32ビット浮動小数点数（各4バイト）です
    2 * 4 + // scaleは2つの32ビット浮動小数点数（各4バイト）です
    2 * 4;  // offsetは2つの32ビット浮動小数点数（各4バイト）です
  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
</pre>
<p>次に、JavaScriptで値を設定できるように<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code class="notranslate" translate="no">TypedArray</code></a>を作成します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // JavaScript側でユニフォームの値を保持するための型付き配列を作成します
  const uniformValues = new Float32Array(uniformBufferSize / 4);
</pre>
<p>そして、後で変更しない構造体の値の2つを埋めます。オフセットは、<a href="webgpu-memory-layout.html">メモリレイアウトに関する記事</a>で説明した内容を使用して計算されました。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // float32インデックスでのさまざまなユニフォーム値へのオフセット
  const kColorOffset = 0;
  const kScaleOffset = 4;
  const kOffsetOffset = 6;

  uniformValues.set([0, 1, 0, 1], kColorOffset);        // 色を設定します
  uniformValues.set([-0.5, -0.25], kOffsetOffset);      // オフセットを設定します
</pre>
<p>上記では、色を緑に設定しています。オフセットは、三角形をキャンバスの左1/4、下1/8に移動します。（クリップ空間は-1から1まで、つまり2単位の幅なので、0.25は2の1/8です）。</p>
<p>次に、<a href="webgpu-fundamentals.html#a-draw-diagram">最初の記事の図が示すように</a>、シェーダーにバッファについて伝えるには、バインドグループを作成してバッファをバインドする必要があります。シェーダーで設定したのと同じ<code class="notranslate" translate="no">@group(?)</code>と<code class="notranslate" translate="no">@binding(?)</code>を渡す必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer }},
    ],
  });
</pre>
<p>コマンドバッファを送信する前に、<code class="notranslate" translate="no">uniformValues</code>の残りの値を設定し、それらの値をGPU上のバッファにコピーする必要がある場合があります。<code class="notranslate" translate="no">render</code>関数の冒頭でそれを行います。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // JavaScript側のFloat32Arrayでユニフォーム値を設定します
    const aspect = canvas.width / canvas.height;
    uniformValues.set([0.5 / aspect, 0.5], kScaleOffset); // スケールを設定します

    // JavaScriptからGPUに値をコピーします
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<blockquote>
<p>注：<code class="notranslate" translate="no">writeBuffer</code>は、バッファにデータをコピーする1つの方法です。<a href="webgpu-copying-data.html">この記事</a>で説明されている他のいくつかの方法があります。</p>
</blockquote>
<p>スケールを半分のサイズに設定し、キャンバスのアスペクトを考慮して、三角形がキャンバスのサイズに関係なく同じ幅と高さの比率を維持するようにしています。</p>
<p>最後に、描画する前にバインドグループを設定する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
+    pass.setBindGroup(0, bindGroup);
    pass.draw(3);  // 頂点シェーダーを3回呼び出します
    pass.end();
</pre>
<p>そして、それで、説明どおりの緑色の三角形が得られます。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>この単一の三角形の場合、描画コマンドが実行されるときの状態は次のようになります。</p>
<div class="webgpu_center"><img src="../resources/webgpu-draw-diagram-triangle-uniform.svg" style="width: 863px;"></div>
<p>これまで、シェーダーで使用したすべてのデータは、ハードコードされていました（頂点シェーダーの三角形の頂点位置、およびフラグメントシェーダーの色）。シェーダーに値を渡すことができるようになったので、異なるデータで<code class="notranslate" translate="no">draw</code>を複数回呼び出すことができます。</p>
<p>単一のバッファを更新することで、異なるオフセット、スケール、色で異なる場所に描画できます。ただし、コマンドはコマンドバッファに入れられ、送信するまで実際には実行されないことを覚えておくことが重要です。したがって、これを<strong>行うことはできません</strong>。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // BAD!
    for (let x = -1; x &lt; 1; x += 0.1) {
      uniformValues.set([x, x], kOffsetOffset);
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
      pass.draw(3);
    }
    pass.end();

    // エンコードを終了し、コマンドを送信します
    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
</pre>
<p>なぜなら、上記のように、<code class="notranslate" translate="no">device.queue.xxx</code>関数は「キュー」で発生しますが、<code class="notranslate" translate="no">pass.xxx</code>関数はコマンドバッファにコマンドをエンコードするだけだからです。コマンドバッファで<code class="notranslate" translate="no">submit</code>を実際に呼び出すと、バッファ内の唯一のものは、書き込んだ最後の値になります。</p>
<p>これを次のように変更できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // BAD! 遅い！
    for (let x = -1; x &lt; 1; x += 0.1) {
      uniformValues.set([x, 0], kOffsetOffset);
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();

      // エンコードを終了し、コマンドを送信します
      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    }
</pre>
<p>上記のコードは、1つのバッファを更新し、1つのコマンドバッファを作成し、1つのものを描画するコマンドを追加し、コマンドバッファを終了して送信します。これは機能しますが、複数の理由で遅くなります。最大の理由は、単一のコマンドバッファでより多くの作業を行うのがベストプラクティスであるためです。</p>
<p>したがって、代わりに、描画したいものごとに1つのユニフォームバッファを作成できます。そして、バッファはバインドグループを介して間接的に使用されるため、描画したいものごとに1つのバインドグループも必要になります。次に、描画したいすべてのものを単一のコマンドバッファに入れることができます。</p>
<p>やってみましょう。</p>
<p>まず、ランダム関数を作成しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// [minとmax)の間の乱数
// 1つの引数がある場合は[0からmin)になります
// 引数がない場合は[0から1)になります
const rand = (min, max) =&gt; {
  if (min === undefined) {
    min = 0;
    max = 1;
  } else if (max === undefined) {
    max = min;
    min = 0;
  }
  return min + Math.random() * (max - min);
};

</pre>
<p>そして、多数の個々のものを描画できる多数の色とオフセットを持つバッファを設定しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // float32インデックスでのさまざまなユニフォーム値へのオフセット
  const kColorOffset = 0;
  const kScaleOffset = 4;
  const kOffsetOffset = 6;

+  const kNumObjects = 100;
+  const objectInfos = [];
+
+  for (let i = 0; i &lt; kNumObjects; ++i) {
+    const uniformBuffer = device.createBuffer({
+      label: `uniforms for obj: ${i}`,
+      size: uniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });
+
+    // JavaScript側でユニフォームの値を保持するための型付き配列を作成します
+    const uniformValues = new Float32Array(uniformBufferSize / 4);
-  uniformValues.set([0, 1, 0, 1], kColorOffset);        // 色を設定します
-  uniformValues.set([-0.5, -0.25], kOffsetOffset);      // オフセットを設定します
+    uniformValues.set([rand(), rand(), rand(), 1], kColorOffset);        // 色を設定します
+    uniformValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], kOffsetOffset);      // オフセットを設定します
+
+    const bindGroup = device.createBindGroup({
+      label: `bind group for obj: ${i}`,
+      layout: pipeline.getBindGroupLayout(0),
+      entries: [
+        { binding: 0, resource: { buffer: uniformBuffer }},
+      ],
+    });
+
+    objectInfos.push({
+      scale: rand(0.2, 0.5),
+      uniformBuffer,
+      uniformValues,
+      bindGroup,
+    });
+  }
</pre>
<p>キャンバスのアスペクトを考慮に入れたいので、まだバッファに値を設定していません。レンダリング時までキャンバスのアスペクトがわからないためです。</p>
<p>レンダリング時に、すべてのアスペクト調整されたスケールでバッファを更新します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
-    // JavaScript側のFloat32Arrayでユニフォーム値を設定します
-    const aspect = canvas.width / canvas.height;
-    uniformValues.set([0.5 / aspect, 0.5], kScaleOffset); // スケールを設定します
-
-    // JavaScriptからGPUに値をコピーします
-    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

    // キャンバスコンテキストから現在のテクスチャを取得し、
    // レンダリングするテクスチャとして設定します。
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

+    // JavaScript側のFloat32Arrayでユニフォーム値を設定します
+    const aspect = canvas.width / canvas.height;

+    for (const {scale, bindGroup, uniformBuffer, uniformValues} of objectInfos) {
+      uniformValues.set([scale / aspect, scale], kScaleOffset); // スケールを設定します
+      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
       pass.setBindGroup(0, bindGroup);
       pass.draw(3);  // 頂点シェーダーを3回呼び出します
+    }
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }
</pre>
<p>繰り返しになりますが、<code class="notranslate" translate="no">encoder</code>と<code class="notranslate" translate="no">pass</code>オブジェクトはコマンドバッファにコマンドをエンコードしているだけであることを忘れないでください。したがって、<code class="notranslate" translate="no">render</code>関数が終了すると、事実上、この順序でこれらの<em>コマンド</em>を発行したことになります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.writeBuffer(...) // オブジェクト0のデータでユニフォームバッファ0を更新します
device.queue.writeBuffer(...) // オブジェクト1のデータでユニフォームバッファ1を更新します
device.queue.writeBuffer(...) // オブジェクト2のデータでユニフォームバッファ2を更新します
device.queue.writeBuffer(...) // オブジェクト3のデータでユニフォームバッファ3を更新します
...
// それぞれ独自のユニフォームバッファを持つ100個のものを描画するコマンドを実行します。
device.queue.submit([commandBuffer]);
</pre>
<p>これがそれです。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms-multiple.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms-multiple.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>ここで、もう1つ説明します。シェーダーで複数のユニフォームバッファを参照できます。上記の例では、描画するたびにスケールを更新し、<code class="notranslate" translate="no">writeBuffer</code>を呼び出してそのオブジェクトの<code class="notranslate" translate="no">uniformValues</code>を対応するユニフォームバッファにアップロードします。しかし、スケールのみが更新され、色とオフセットは更新されないため、色とオフセットをアップロードする時間を無駄にしています。</p>
<p>ユニフォームを、一度設定する必要があるユニフォームと、描画するたびに更新されるユニフォームに分割できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    code: `
      struct OurStruct {
        color: vec4f,
-        scale: vec2f,
        offset: vec2f,
      };

+      struct OtherStruct {
+        scale: vec2f,
+      };

      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
+      @group(0) @binding(1) var&lt;uniform&gt; otherStruct: OtherStruct;

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        return vec4f(
-          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
+          pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
        return ourStruct.color;
      }
    `,
  });
</pre>
<p>描画したいものごとに2つのユニフォームバッファが必要です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  // ユニフォーム値用のバッファを作成します
-  const uniformBufferSize =
-    4 * 4 + // colorは4つの32ビット浮動小数点数（各4バイト）です
-    2 * 4 + // scaleは2つの32ビット浮動小数点数（各4バイト）です
-    2 * 4;  // offsetは2つの32ビット浮動小数点数（各4バイト）です
-  // float32インデックスでのさまざまなユニフォーム値へのオフセット
-  const kColorOffset = 0;
-  const kScaleOffset = 4;
-  const kOffsetOffset = 6;
+  // ユニフォーム値用の2つのバッファを作成します
+  const staticUniformBufferSize =
+    4 * 4 + // colorは4つの32ビット浮動小数点数（各4バイト）です
+    2 * 4 + // offsetは2つの32ビット浮動小数点数（各4バイト）です
+    2 * 4;  // パディング
+  const uniformBufferSize =
+    2 * 4;  // scaleは2つの32ビット浮動小数点数（各4バイト）です
+
+  // float32インデックスでのさまざまなユニフォーム値へのオフセット
+  const kColorOffset = 0;
+  const kOffsetOffset = 4;
+
+  const kScaleOffset = 0;

  const kNumObjects = 100;
  const objectInfos = [];

  for (let i = 0; i &lt; kNumObjects; ++i) {
+    const staticUniformBuffer = device.createBuffer({
+      label: `static uniforms for obj: ${i}`,
+      size: staticUniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });
+
+    // これらは一度だけ設定されるので、今すぐ設定します
+    {
-      const uniformValues = new Float32Array(uniformBufferSize / 4);
+      const uniformValues = new Float32Array(staticUniformBufferSize / 4);
      uniformValues.set([rand(), rand(), rand(), 1], kColorOffset);        // 色を設定します
      uniformValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], kOffsetOffset);      // オフセットを設定します

      // これらの値をGPUにコピーします
-      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
+      device.queue.writeBuffer(staticUniformBuffer, 0, uniformValues);
    }

+    // JavaScript側でユニフォームの値を保持するための型付き配列を作成します
+    const uniformValues = new Float32Array(uniformBufferSize / 4);
+    const uniformBuffer = device.createBuffer({
+      label: `changing uniforms for obj: ${i}`,
+      size: uniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });

    const bindGroup = device.createBindGroup({
      label: `bind group for obj: ${i}`,
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: staticUniformBuffer }},
+        { binding: 1, resource: { buffer: uniformBuffer }},
      ],
    });

    objectInfos.push({
      scale: rand(0.2, 0.5),
      uniformBuffer,
      uniformValues,
      bindGroup,
    });
  }
</pre>
<p>レンダーコードには何も変更はありません。各オブジェクトのバインドグループには、各オブジェクトの両方のユニフォームバッファへの参照が含まれています。以前と同様に、スケールを更新しています。しかし、今では、スケール値を保持するユニフォームバッファを更新するときに<code class="notranslate" translate="no">device.queue.writeBuffer</code>を呼び出すときにスケールのみをアップロードしていますが、以前は各オブジェクトの色+オフセット+スケールをアップロードしていました。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms-split.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms-split.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>この単純な例では、複数のユニフォームバッファに分割するのはおそらくやり過ぎでしたが、何がいつ変更されるかに基づいて分割するのが一般的です。例としては、共有される行列用の1つのユニフォームバッファがあります。たとえば、<a href="webgpu-cameras.html">射影行列、ビュー行列、カメラ行列</a>です。これらは、描画したいすべてのものに対して同じであることが多いため、1つのバッファを作成し、すべてのオブジェクトが同じユニフォームバッファを使用するようにできます。</p>
<p>個別に、シェーダーは、<a href="webgpu-cameras.html">ワールド/モデル行列</a>や<a href="webgpu-lighting-directional.html">法線行列</a>など、このオブジェクトに固有のもののみを含む別のユニフォームバッファを参照する場合があります。</p>
<p>別のユニフォームバッファには、マテリアル設定が含まれている場合があります。これらの設定は、複数のオブジェクトで共有される場合があります。</p>
<p>3Dの描画について説明するときに、これの多くを行います。</p>
<p>次は、<a href="webgpu-storage-buffers.html">ストレージバッファ</a>です。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-uniforms.html">English
    </option><option value="/webgpu/lessons/es/webgpu-uniforms.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-uniforms.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-uniforms.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-uniforms.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-uniforms.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-uniforms.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-uniforms.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU ユニフォーム`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>