<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-storage-buffers.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="シェーダーへの大きなデータの受け渡し">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ja.jpg">

<meta property="og:title" content="WebGPU ストレージバッファ">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ja.jpg">
<meta property="og:description" content="シェーダーへの大きなデータの受け渡し">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU ストレージバッファ">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html">
<meta name="twitter:description" content="シェーダーへの大きなデータの受け渡し">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html",
      "inLanguage":"ja",
      "name":"WebGPU ストレージバッファ",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-storage-buffers.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU ストレージバッファ</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-buffers.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-buffers.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-buffers.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-storage-buffers.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-storage-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-buffers.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU ストレージバッファ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>この記事はストレージバッファに関するもので、<a href="webgpu-uniforms.html">前の記事</a>の続きです。</p>
<p>ストレージバッファは、多くの点でユニフォームバッファに似ています。JavaScriptで<code class="notranslate" translate="no">UNIFORM</code>を<code class="notranslate" translate="no">STORAGE</code>に変更し、WGSLで<code class="notranslate" translate="no">var&lt;uniform&gt;</code>を<code class="notranslate" translate="no">var&lt;storage, read&gt;</code>に変更するだけで、前のページの例はそのまま機能します。</p>
<p>実際、変数をより適切な名前に変更せずに、違いは次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const staticUniformBuffer = device.createBuffer({
      label: `static uniforms for obj: ${i}`,
      size: staticUniformBufferSize,
-      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });


...

    const uniformBuffer = device.createBuffer({
      label: `changing uniforms for obj: ${i}`,
      size: uniformBufferSize,
-      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
</pre>
<p>そして、WSGLでは</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">-@group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
-@group(0) @binding(1) var&lt;uniform&gt; otherStruct: OtherStruct;
+@group(0) @binding(0) var&lt;storage, read&gt; ourStruct: OurStruct;
+@group(0) @binding(1) var&lt;storage, read&gt; otherStruct: OtherStruct;
</pre>
<p>そして、他の変更なしで、以前と同じように機能します。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-storage-split-minimal-changes.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-storage-split-minimal-changes.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<h2 id="ユニフォームバッファとストレージバッファの違い">ユニフォームバッファとストレージバッファの違い</h2>
<p>ユニフォームバッファとストレージバッファの主な違いは次のとおりです。</p>
<ol>
<li>
<p>ユニフォームバッファは、一般的なユースケースでは高速になる可能性があります。</p>
<p>これは、ユースケースに大きく依存します。一般的なアプリでは、さまざまなものをたくさん描画する必要があります。たとえば、3Dゲームだとします。アプリは、車、建物、岩、茂み、人々などを描画する場合があります。それぞれに、上記の例で渡したものと同様の向きとマテリアルのプロパティを渡す必要があります。この場合、ユニフォームバッファを使用することをお勧めします。</p>
</li>
<li>
<p>ストレージバッファは、ユニフォームバッファよりもはるかに大きくなる可能性があります。</p>
<ul>
<li>デフォルトでは、ユニフォームバッファの最大サイズは64 KiB（65536バイト）です。</li>
<li>デフォルトでは、ストレージバッファの最大サイズは128 MiB（134217728バイト）です。</li>
</ul>
<p>すべての実装は、少なくともこれらのサイズをサポートする必要があります。<a href="webgpu-limits-and-features.html">別の記事</a>で、より大きな制限を確認して要求する方法について詳しく説明します。</p>
</li>
<li>
<p>ストレージバッファは読み書き可能ですが、ユニフォームバッファは読み取り専用です。</p>
<p><a href="webgpu-fundamentals.html">最初の記事</a>のコンピュートシェーダーの例で、ストレージバッファへの書き込みの例を見ました。</p>
</li>
</ol>
<h2 id="ストレージバッファを使用したインスタンス化"><a id="a-instancing"></a>ストレージバッファを使用したインスタンス化</h2>
<p>上記の最初の2つの点を考慮して、最後の例を取り上げ、1回の描画呼び出しですべての100個の三角形を描画するように変更しましょう。これは、ストレージバッファに<em>適合する可能性のある</em>ユースケースです。適合する可能性があると言うのは、繰り返しになりますが、WebGPUは他のプログラミング言語に似ているためです。同じことを達成するには多くの方法があります。<code class="notranslate" translate="no">array.forEach</code>と<code class="notranslate" translate="no">for (const elem of array)</code>と<code class="notranslate" translate="no">for (let i = 0; i &lt; array.length; ++i)</code>です。それぞれに用途があります。WebGPUでも同じことが言えます。やろうとすることには、それを達成するための複数の方法があります。三角形を描画する場合、WebGPUが気にするのは、頂点シェーダーから<code class="notranslate" translate="no">builtin(position)</code>の値を返し、フラグメントシェーダーから<code class="notranslate" translate="no">location(0)</code>の色/値を返すことだけです。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>最初に行うことは、ストレージ宣言をランタイムサイズの配列に変更することです。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-@group(0) @binding(0) var&lt;storage, read&gt; ourStruct: OurStruct;
-@group(0) @binding(1) var&lt;storage, read&gt; otherStruct: OtherStruct;
+@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
+@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
</pre>
<p>次に、これらの値を使用するようにシェーダーを変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
+  @builtin(instance_index) instanceIndex: u32
) -&gt; @builtin(position) {
  let pos = array(
    vec2f( 0.0,  0.5),  // top center
    vec2f(-0.5, -0.5),  // bottom left
    vec2f( 0.5, -0.5)   // bottom right
  );

+  let otherStruct = otherStructs[instanceIndex];
+  let ourStruct = ourStructs[instanceIndex];

   return vec4f(
     pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
}
</pre>
<p>頂点シェーダーに<code class="notranslate" translate="no">instanceIndex</code>という新しいパラメータを追加し、<code class="notranslate" translate="no">@builtin(instance_index)</code>属性を付けました。これは、描画される各「インスタンス」に対してWebGPUから値を取得することを意味します。<code class="notranslate" translate="no">draw</code>を呼び出すとき、<em>インスタンス数</em>の2番目の引数を渡すことができ、描画される各インスタンスについて、処理されるインスタンスの番号が関数に渡されます。</p>
<p><code class="notranslate" translate="no">instanceIndex</code>を使用して、構造体の配列から特定の構造体要素を取得できます。</p>
<p>また、正しい配列要素から色を取得し、フラグメントシェーダーで使用する必要があります。フラグメントシェーダーは<code class="notranslate" translate="no">@builtin(instance_index)</code>にアクセスできません。それは意味がないからです。<a href="webgpu-inter-stage-variables.html">ステージ間変数</a>として渡すこともできますが、頂点シェーダーで色を検索し、色だけを渡す方が一般的です。</p>
<p>これを行うには、<a href="webgpu-inter-stage-variables.html">ステージ間変数に関する記事</a>で行ったように、別の構造体を使用します。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+struct VSOutput {
+  @builtin(position) position: vec4f,
+  @location(0) color: vec4f,
+}

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
  @builtin(instance_index) instanceIndex: u32
-) -&gt; @builtin(position) vec4f {
+) -&gt; VSOutput {
  let pos = array(
    vec2f( 0.0,  0.5),  // top center
    vec2f(-0.5, -0.5),  // bottom left
    vec2f( 0.5, -0.5)   // bottom right
  );

  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

-  return vec4f(
-    pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+  var vsOut: VSOutput;
+  vsOut.position = vec4f(
+      pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+  vsOut.color = ourStruct.color;
+  return vsOut;
}

-@fragment fn fs() -&gt; @location(0) vec4f {
-  return ourStruct.color;
+@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
+  return vsOut.color;
}

</pre>
<p>WGSLシェーダーを変更したので、JavaScriptを更新しましょう。</p>
<p>設定は次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNumObjects = 100;
  const objectInfos = [];

  // 2つのストレージバッファを作成します
  const staticUnitSize =
    4 * 4 + // colorは4つの32ビット浮動小数点数（各4バイト）です
    2 * 4 + // offsetは2つの32ビット浮動小数点数（各4バイト）です
    2 * 4;  // パディング
  const changingUnitSize =
    2 * 4;  // scaleは2つの32ビット浮動小数点数（各4バイト）です
  const staticStorageBufferSize = staticUnitSize * kNumObjects;
  const changingStorageBufferSize = changingUnitSize * kNumObjects;

  const staticStorageBuffer = device.createBuffer({
    label: 'static storage for objects',
    size: staticStorageBufferSize,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  const changingStorageBuffer = device.createBuffer({
    label: 'changing storage for objects',
    size: changingStorageBufferSize,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  // float32インデックスでのさまざまなユニフォーム値へのオフセット
  const kColorOffset = 0;
  const kOffsetOffset = 4;

  const kScaleOffset = 0;

  {
    const staticStorageValues = new Float32Array(staticStorageBufferSize / 4);
    for (let i = 0; i &lt; kNumObjects; ++i) {
      const staticOffset = i * (staticUnitSize / 4);

      // これらは一度だけ設定されるので、今すぐ設定します
      staticStorageValues.set([rand(), rand(), rand(), 1], staticOffset + kColorOffset);        // 色を設定します
      staticStorageValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], staticOffset + kOffsetOffset);      // オフセットを設定します

      objectInfos.push({
        scale: rand(0.2, 0.5),
      });
    }
    device.queue.writeBuffer(staticStorageBuffer, 0, staticStorageValues);
  }

  // changingStorageBufferを更新するために使用できる型付き配列
  const storageValues = new Float32Array(changingStorageBufferSize / 4);

  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: staticStorageBuffer }},
      { binding: 1, resource: { buffer: changingStorageBuffer }},
    ],
  });
</pre>
<p>上記では、2つのストレージバッファを作成します。1つは<code class="notranslate" translate="no">OurStruct</code>の配列用、もう1つは<code class="notranslate" translate="no">OtherStruct</code>の配列用です。</p>
<p>次に、<code class="notranslate" translate="no">OurStruct</code>の配列の値をオフセットと色で埋め、そのデータを<code class="notranslate" translate="no">staticStorageBuffer</code>にアップロードします。</p>
<p>両方のバッファを参照する1つのバインドグループを作成します。</p>
<p>新しいレンダリングコードは次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // キャンバスコンテキストから現在のテクスチャを取得し、
    // レンダリングするテクスチャとして設定します。
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

    // JavaScript側のFloat32Arrayでユニフォーム値を設定します
    const aspect = canvas.width / canvas.height;

-    for (const {scale, bindGroup, uniformBuffer, uniformValues} of objectInfos) {
-      uniformValues.set([scale / aspect, scale], kScaleOffset); // スケールを設定します
-      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
-
-      pass.setBindGroup(0, bindGroup);
-      pass.draw(3);  // 頂点シェーダーを3回呼び出します
-    }

+    // 各オブジェクトのスケールを設定します
+    objectInfos.forEach(({scale}, ndx) =&gt; {
+      const offset = ndx * (changingUnitSize / 4);
+      storageValues.set([scale / aspect, scale], offset + kScaleOffset); // スケールを設定します
+    });
+    // すべてのスケールを一度にアップロードします
+    device.queue.writeBuffer(changingStorageBuffer, 0, storageValues);
+
+    pass.setBindGroup(0, bindGroup);
+    pass.draw(3, kNumObjects);  // 各インスタンスに対して頂点シェーダーを3回呼び出します


    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }
</pre>
<p>上記のコードは、<code class="notranslate" translate="no">kNumObjects</code>個のインスタンスを描画します。各インスタンスについて、WebGPUは頂点シェーダーを3回呼び出し、<code class="notranslate" translate="no">vertex_index</code>を0、1、2に設定し、<code class="notranslate" translate="no">instance_index</code>を0〜kNumObjects - 1に設定します。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-storage-buffer-split.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-storage-buffer-split.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>1回の描画呼び出しで、それぞれ異なるスケール、色、オフセットを持つ100個の三角形すべてを描画できました。同じオブジェクトの多数のインスタンスを描画したい状況では、これが1つの方法です。</p>
<h2 id="頂点データにストレージバッファを使用する">頂点データにストレージバッファを使用する</h2>
<p>これまで、シェーダーで直接ハードコードされた三角形を使用してきました。ストレージバッファの1つのユースケースは、頂点データを格納することです。上記の例で<code class="notranslate" translate="no">instance_index</code>で現在のストレージバッファをインデックス付けしたように、<code class="notranslate" translate="no">vertex_index</code>で別のストレージバッファをインデックス付けして頂点データを取得できます。</p>
<p>やってみましょう！</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  offset: vec2f,
};

struct OtherStruct {
  scale: vec2f,
};

+struct Vertex {
+  position: vec2f,
+};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
+@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
-  let pos = array(
-    vec2f( 0.0,  0.5),  // top center
-    vec2f(-0.5, -0.5),  // bottom left
-    vec2f( 0.5, -0.5)   // bottom right
-  );

  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
-      pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+      pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
  vsOut.color = ourStruct.color;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color;
}
</pre>
<p>次に、いくつかの頂点データを持つ別のストレージバッファを設定する必要があります。まず、いくつかの頂点データを生成する関数を作成しましょう。円を作成しましょう。
<a id="a-create-circle"></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // 1つのサブディビジョンあたり2つの三角形、1つの三角形あたり3つの頂点、それぞれ2つの値（xy）。
  const numVertices = numSubdivisions * 3 * 2;
  const vertexData = new Float32Array(numSubdivisions * 2 * 3 * 2);

  let offset = 0;
  const addVertex = (x, y) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
  };

  // 1つのサブディビジョンあたり2つの三角形
  //
  // 0--1 4
  // | / /|
  // |/ / |
  // 2 3--5
  for (let i = 0; i &lt; numSubdivisions; ++i) {
    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;

    const c1 = Math.cos(angle1);
    const s1 = Math.sin(angle1);
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);

    // 最初の三角形
    addVertex(c1 * radius, s1 * radius);
    addVertex(c2 * radius, s2 * radius);
    addVertex(c1 * innerRadius, s1 * innerRadius);

    // 2番目の三角形
    addVertex(c1 * innerRadius, s1 * innerRadius);
    addVertex(c2 * radius, s2 * radius);
    addVertex(c2 * innerRadius, s2 * innerRadius);
  }

  return {
    vertexData,
    numVertices,
  };
}
</pre>
<p>上記のコードは、次のような三角形から円を作成します。</p>
<div class="webgpu_center"><div class="center"><div data-diagram="circle" style="width: 300px;"></div></div></div>
<p>したがって、それを使用して、円の頂点でストレージバッファを埋めることができます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 頂点データを持つストレージバッファを設定します
  const { vertexData, numVertices } = createCircleVertices({
    radius: 0.5,
    innerRadius: 0.25,
  });
  const vertexStorageBuffer = device.createBuffer({
    label: 'storage buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexStorageBuffer, 0, vertexData);
</pre>
<p>そして、それをバインドグループに追加する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: staticStorageBuffer }},
      { binding: 1, resource: { buffer: changingStorageBuffer }},
+      { binding: 2, resource: { buffer: vertexStorageBuffer }},
    ],
  });
</pre>
<p>そして最後に、レンダリング時に、円のすべての頂点をレンダリングするように要求する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    pass.draw(3, kNumObjects);  // 複数のインスタンスに対して頂点シェーダーを3回呼び出します
+    pass.draw(numVertices, kNumObjects);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-storage-buffer-vertices.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-storage-buffer-vertices.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>上記では、</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">struct Vertex {
  pos: vec2f;
};

@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;
</pre>
<p>構造体なしで、直接<code class="notranslate" translate="no">vec2f</code>を使用することもできました。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;
+@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;vec2f&gt;;
...
-pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
</pre>
<p>しかし、構造体にすることで、後で頂点ごとのデータを追加するのが間違いなく簡単になりますか？</p>
<p>ストレージバッファを介して頂点を渡すことは、人気が高まっています。ただし、一部の古いデバイスでは、<a href="webgpu-vertex-buffers.html">頂点バッファに関する記事</a>で次に説明する<em>古典的な</em>方法よりも遅いと言われています。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>複数のカラーアタッチメントを持つことができ、その場合は<code class="notranslate" translate="no">location(1)</code>、<code class="notranslate" translate="no">location(2)</code>などに対してより多くの色/値を返す必要があります。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-buffers.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-buffers.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-buffers.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-storage-buffers.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-storage-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-buffers.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU ストレージバッファ`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>