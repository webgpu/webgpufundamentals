<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-multiple-canvases.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="複数のキャンバス">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-multiple-canvases_ja.jpg">

<meta property="og:title" content="WebGPU 複数のキャンバス">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-multiple-canvases_ja.jpg">
<meta property="og:description" content="複数のキャンバス">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 複数のキャンバス">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html">
<meta name="twitter:description" content="複数のキャンバス">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-multiple-canvases_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-multiple-canvases_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html",
      "inLanguage":"ja",
      "name":"WebGPU 複数のキャンバス",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-multiple-canvases.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 複数のキャンバス</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-multiple-canvases.html">English
    </option><option value="/webgpu/lessons/es/webgpu-multiple-canvases.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-multiple-canvases.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-multiple-canvases.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-multiple-canvases.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-multiple-canvases.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-multiple-canvases.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 複数のキャンバス</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>WebGPUで複数のキャンバスに描画するのは非常に簡単です。<a href="webgpu-fundamentals.html">基礎に関する記事</a>では、キャンバスを検索し、<code class="notranslate" translate="no">getContext</code>を呼び出してコンテキストを構成しました。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // キャンバスからWebGPUコンテキストを取得し、構成します
  const canvas = document.querySelector('canvas');
  const context = canvas.getContext('webgpu');
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device,
    format: presentationFormat,
  });
</pre>
<p>キャンバスに描画するために、そのコンテキストを使用してキャンバスのテクスチャを取得し、そのテクスチャをレンダーパスの最初の<code class="notranslate" translate="no">colorAttachment</code>として設定しました。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass',
    colorAttachments: [
      {
*        // view: &lt;- レンダリング時に設定されます
        clearValue: [0.3, 0.3, 0.3, 1],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
  };  

  function render() {
    // キャンバスコンテキストから現在のテクスチャを取得し、
    // レンダリングするテクスチャとして設定します。
*    renderPassDescriptor.colorAttachments[0].view =
*        context.getCurrentTexture().createView();

    // コマンドをエンコードし始めるためのコマンドエンコーダーを作成します
    const encoder = device.createCommandEncoder({ label: 'our encoder' });

    // レンダリング固有のコマンドをエンコードするためのレンダーパスエンコーダーを作成します
    const pass = encoder.beginRenderPass(renderPassDescriptor);

</pre>
<p>別のキャンバスに描画するには、そのキャンバスに対して同じ手順に従うだけです。</p>
<ol>
<li>キャンバスを検索します（または作成します）。</li>
<li>「webgpu」コンテキストを取得します。</li>
<li>コンテキストを構成します。</li>
<li>そのキャンバスにレンダリングしたい場合は、<code class="notranslate" translate="no">context.getCurrentTexture</code>を呼び出し、そのテクスチャをレンダーパスの<code class="notranslate" translate="no">colorAttachment</code>として使用します。</li>
</ol>
<p>最初の例を取り上げ、3つのキャンバスにレンダリングしましょう。</p>
<p>まず、さらに2つのキャンバスを追加しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">  &lt;body&gt;
    &lt;canvas&gt;&lt;/canvas&gt;
+    &lt;canvas&gt;&lt;/canvas&gt;
+    &lt;canvas&gt;&lt;/canvas&gt;
  &lt;/body&gt;
</pre>
<p>次に、コンテキストを取得し、すべてのキャンバスを構成しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 各キャンバスのWebGPUコンテキストを取得し、構成します
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  const infos = [];
  for (const canvas of document.querySelectorAll('canvas')) {
    const context = canvas.getContext('webgpu');
    context.configure({
      device,
      format: presentationFormat,
    });
    infos.push({ context });
  }
</pre>
<p>そして最後に、それらすべてにレンダリングしましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
*    // コマンドをエンコードし始めるためのコマンドエンコーダーを作成します
*    const encoder = device.createCommandEncoder({ label: 'our encoder' });

+    for (const {context} of infos) {
      // キャンバスコンテキストから現在のテクスチャを取得し、
      // レンダリングするテクスチャとして設定します。
      renderPassDescriptor.colorAttachments[0].view =
          context.getCurrentTexture().createView();

      // レンダリング固有のコマンドをエンコードするためのレンダーパスエンコーダーを作成します
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
      pass.draw(3);  // 頂点シェーダーを3回呼び出します。
      pass.end();
+    }

*    const commandBuffer = encoder.finish();
*    device.queue.submit([commandBuffer]);
  }

  render();
</pre>
<p>変更点は、（1）コマンドエンコーダーを作成する場所で、3つのキャンバスすべてをレンダリングするために共有できるようにしたこと、（2）コンテキストをループ処理したことです。</p>
<p>そして、3つのキャンバスにレンダリングしました。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-multiple-canvases.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-multiple-canvases.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>注：単一のコマンドエンコーダーを作成することは厳密には必要ありませんが、わずかに効率的です。</p>
<p>では、他に何が残っているでしょうか？</p>
<h2 id="多数のキャンバスの最適化">多数のキャンバスの最適化</h2>
<p>回転する製品を表示したいとしましょう。これを簡単にするために、ハードコードされた三角形に固執しますが、<a href="webgpu-matrix-math.html">行列演算に関する記事で説明したように</a>行列を渡すことで回転するようにしましょう。また、それぞれがわずかに異なるように見えるように色を渡しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+  struct Uniforms {
+    matrix: mat4x4f,
+    color: vec4f,
+  };
+
+  @group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

  @vertex fn vs(
    @builtin(vertex_index) vertexIndex : u32
  ) -&gt; @builtin(position) vec4f {
    let pos = array(
      vec2f( 0.0,  0.5),  // top center
      vec2f(-0.5, -0.5),  // bottom left
      vec2f( 0.5, -0.5)   // bottom right
    );

-    return vec4f(pos[vertexIndex], 0.0, 1.0);
+    return uni.matrix * vec4f(pos[vertexIndex], 0.0, 1.0);
  }

  @fragment fn fs() -&gt; @location(0) vec4f {
-    return vec4f(1, 0, 0, 1);
+    return uni.color;
  }
</pre>
<p>それぞれに<a href="webgpu-uniforms.html">ユニフォームバッファ</a>と、バインドグループと関連するものが必要です。</p>
<p>200個のキャンバスを作成し、WebGPU用に構成しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const infos = [];
  const numProducts = 200;
  for (let i = 0; i &lt; numProducts; ++i) {
    // これを作成します
    // &lt;div class="product size?"&gt;
    //   &lt;canvas&gt;&lt;/canvas&gt;
    //   &lt;div&gt;Product#: ?&lt;/div&gt;
    // &lt;/div&gt;
    const canvas = document.createElement('canvas');

    const container = document.createElement('div');
    container.className = `product size${i % 4}`;

    const description = document.createElement('div');
    description.textContent = `product#: ${i + 1}`;

    container.appendChild(canvas);
    container.appendChild(description);
    document.body.appendChild(container);

    // WebGPUコンテキストを取得して構成します。
    const context = canvas.getContext('webgpu');
    context.configure({
      device,
      format: presentationFormat,
    });

    infos.push({
      context,
    });
  }
</pre>
<p>これに伴うCSSが必要です。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  .product {
    display: inline-block;
    padding: 1em;
    background: #888;
    margin: 1em;
  }
  .size0&gt;canvas {
    width: 200px;
    height: 200px;
  }
  .size1&gt;canvas {
    width: 250px;
    height: 200px;
  }
  .size2&gt;canvas {
    width: 300px;
    height: 200px;
  }
  .size3&gt;canvas {
    width: 100px;
    height: 200px;
  }
</pre>
<p>4つのサイズは、物事を正しく行っていることを確認するためだけです。すべて同じサイズにした場合、間違いを隠してしまう可能性があります。</p>
<p>それぞれにユニフォームバッファとバインドグループが必要です。後で色を変更しないので、今すぐ1つ選択します。ランダムなclearValueも選択しましょう（なぜですか？🤷‍♂️）。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function randomColor() {
+    return [Math.random(), Math.random(), Math.random(), 1];
+  }

  const infos = [];
  const numProducts = 200;
  for (let i = 0; i &lt; numProducts; ++i) {
    ...

+    // ユニフォーム用のユニフォームバッファと型配列ビューを作成します。
+    const uniformValues = new Float32Array(16 + 4);
+    const uniformBuffer = device.createBuffer({
+      size: uniformValues.byteLength,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });
+    const kMatrixOffset = 0;
+    const kColorOffset = 16;
+    const matrixValue = uniformValues.subarray(
+        kMatrixOffset, kMatrixOffset + 16);
+    const colorValue = uniformValues.subarray(
+        kColorOffset, kColorOffset + 4);
+    colorValue.set(randomColor());
+
+    // このユニフォームのバインドグループを作成します
+    const bindGroup = device.createBindGroup({
+      layout: pipeline.getBindGroupLayout(0),
+      entries: [
+        { binding: 0, resource: uniformBuffer },
+      ],
+    });

    infos.push({
      context,
+      clearValue: randomColor(),
+      matrixValue,
+      uniformValues,
+      uniformBuffer,
+      bindGroup,
    });

</pre>
<p><a href="../webgpu-fundamentals.html#a-resizing">各キャンバスのサイズを変更する</a>ために<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>も追加しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const resizeObserver = new ResizeObserver(entries =&gt; {
    for (const entry of entries) {
      const canvas = entry.target;
      const width = entry.contentBoxSize[0].inlineSize;
      const height = entry.contentBoxSize[0].blockSize;
      canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
      canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
    }
  });

  ...

  const infos = [];
  const numProducts = 200;
  for (let i = 0; i &lt; numProducts; ++i) {
    // これを作成します
    // &lt;div class="product size?"&gt;
    //   &lt;canvas&gt;&lt;/canvas&gt;
    //   &lt;div&gt;Product#: ?&lt;/div&gt;
    // &lt;/div&gt;
    const canvas = document.createElement('canvas');
    resizeObserver.observe(canvas);

    ...
</pre>
<p>レンダリング時に、<code class="notranslate" translate="no">requestAnimationFrame</code>（rAF）ループを使用してアニメーション化します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function render(time) {
+    time *= 0.001; // 秒に変換します

    ...

+    requestAnimationFrame(render);
  }

-  render();
+  requestAnimationFrame(render);
</pre>
<p>そして、各キャンバスの行列を更新し、新しい値をユニフォームバッファにアップロードし、バインドグループを設定する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(time) {
    time *= 0.001; // 秒に変換します

    // コマンドをエンコードし始めるためのコマンドエンコーダーを作成します
    const encoder = device.createCommandEncoder({ label: 'our encoder' });

    for (const {
      context,
      uniformBuffer,
      uniformValues,
      matrixValue,
      bindGroup,
      clearValue,
    } of infos) {
      // キャンバスコンテキストから現在のテクスチャを取得し、
      // レンダリングするテクスチャとして設定します。
      renderPassDescriptor.colorAttachments[0].view =
          context.getCurrentTexture().createView();
+      renderPassDescriptor.colorAttachments[0].clearValue = clearValue;
+
+      const { canvas } = context;
+      const aspect = canvas.clientWidth / canvas.clientHeight;
+      mat4.ortho(-aspect, aspect, -1, 1, -1, 1, matrixValue);
+      mat4.rotateZ(matrixValue, time * 0.1, matrixValue);
+
+      // ユニフォーム値をアップロードします。
+      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      // レンダリング固有のコマンドをエンコードするためのレンダーパスエンコーダーを作成します
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
+      pass.setBindGroup(0, bindGroup);
      pass.draw(3);  // 頂点シェーダーを3回呼び出します。
      pass.end();
    }

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    requestAnimationFrame(render);
  }
</pre>
<p>さらにいくつか追加しましょう。その理由は後で説明します。</p>
<p>全体を停止および開始する方法を追加しましょう。まず、ボタンを追加します。</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">  &lt;body&gt;
+    &lt;button type="button" id="stop"&gt;停止/開始&lt;/button&gt;
  &lt;/body&gt;
</pre>
<p>そして、そのためのCSSです。</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">  #stop {
    position: fixed;
    right: 0;
    top: 0;
    margin: 0.5em;
    z-index: 1;
  }
</pre>
<p>次に、アニメーションを開始および停止するようにコードを変更しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let requestId;
  function render(time) {
    ...

-    requestAnimationFrame(render);
+    requestId = requestAnimationFrame(render);
  }

-  requestAnimationFrame(render);

+  function toggleAnimation() {
+    if (requestId) {
+      cancelAnimationFrame(requestId);
+      requestId = undefined;
+    } else {
+      requestId = requestAnimationFrame(render);
+    }
+  }
+
+  toggleAnimation();
+  document.querySelector('#stop')
+      .addEventListener('click', toggleAnimation);

</pre>
<p>これは機能しますが、一時停止してから後で再開すると、すべてのオブジェクトがジャンプします。これは、レンダリングを停止しても、<code class="notranslate" translate="no">time</code>値はページが読み込まれてからの時間であり、回転の計算に使用されるためです。</p>
<p>したがって、アニメーション化しているときにのみ進む独自の時間を保持することで、これを修正しましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let time = 0;
+  let then = 0;
  let requestId;
-  function render(time) {
-    time *= 0.001
+  function render(now) {
+    now *= 0.001; // 秒に変換します
+    const deltaTime = now - then;
+    time += deltaTime;
+    then = now;

  ...

    requestId = requestAnimationFrame(render);
  }

  function toggleAnimation() {
    if (requestId) {
      cancelAnimationFrame(requestId);
      requestId = undefined;
    } else {
      requestId = requestAnimationFrame(render);
+      then = performance.now() * 0.001;
    }
  }
</pre>
<p>そして、200個のキャンバスができました。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-multiple-canvases-x200.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-multiple-canvases-x200.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>この例は重いことに気づくかもしれません！問題は、表示されているのはごくわずかであるにもかかわらず、200個のキャンバスすべてをレンダリングしていることです。キャンバスごとに1つの三角形だけでなく、詳細な製品モデルを描画していたら、はるかに悪化していたでしょう。これが、停止/開始ボタンを追加した理由です。例が実行されている場合、このページは重すぎる可能性があるため、続行する前に停止することをお勧めします。</p>
<blockquote>
<p>注：このサイトでは、例自体が表示されている場合にのみ、例をレンダリングおよびアニメーション化しようとします。</p>
</blockquote>
<p>この問題を解決する1つの方法は、<a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>を使用することです。</p>
<h2 id="intersectionobserverの使用"><a id="a-intersection-observer"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>の使用</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>は、この種の状況のために特別に設計されました。<a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>は、その名のとおり、交差を監視します。デフォルトでは、要素とブラウザウィンドウの交差を監視します。これを使用して、実際に表示されているキャンバスのセットを保持し、それらのキャンバスのみをレンダリングできます。</p>
<p>コードは次のとおりです。</p>
<p>まず、<a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>を作成します。<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>と同様に、監視対象の要素がウィンドウと交差し始めたり停止したりしたときに呼び出される関数を受け取ります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const visibleCanvasSet = new Set();
  const intersectionObserver = new IntersectionObserver((entries) =&gt; {
    for (const { target, isIntersecting } of entries) {
      if (isIntersecting) {
        visibleCanvasSet.add(target);
      } else {
        visibleCanvasSet.delete(target);
      }
    }
  });
</pre>
<p>上記のように、エントリの配列でコールバックを呼び出します。各エントリは、交差しているかどうかを示します。これを使用して、表示されているキャンバスの<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"><code class="notranslate" translate="no">Set</code></a>を保持します。</p>
<p>各キャンバスを監視するように指示する必要があります。また、キャンバスからそのキャンバスの情報にアクセスする方法も必要です。この場合、それはコンテキスト、ユニフォームバッファ、バインドグループなどです。キャンバスからその情報にアクセスするには、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code class="notranslate" translate="no">Map</code></a>を使用します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const infos = [];
+  const canvasToInfoMap = new Map();
  const numProducts = 200;
  for (let i = 0; i &lt; numProducts; ++i) {
    // これを作成します
    // &lt;div class="product size?"&gt;
    //   &lt;canvas&gt;&lt;/canvas&gt;
    //   &lt;div&gt;Product#: ?&lt;/div&gt;
    // &lt;/div&gt;
    const canvas = document.createElement('canvas');
    resizeObserver.observe(canvas);
+    intersectionObserver.observe(canvas);

    ...

-    infos.push({
+    canvasToInfoMap.set(canvas, {
      context,
      clearValue: randomColor(),
      matrixValue,
      uniformValues,
      uniformBuffer,
      bindGroup,
      rotation: Math.random() * Math.PI * 2,
    });
  }
</pre>
<p>レンダー関数では、表示されているキャンバスのみをレンダリングできます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(now) {
    ...

    // コマンドをエンコードし始めるためのコマンドエンコーダーを作成します
    const encoder = device.createCommandEncoder({ label: 'our encoder' });

-    for (const {
+    visibleCanvasSet.forEach(canvas =&gt; {
*      const {
*       context,
*       uniformBuffer,
*       uniformValues,
*       matrixValue,
*       bindGroup,
*       clearValue,
*       rotation,
-    } of infos) {
+      } = canvasToInfoMap.get(canvas);

      // キャンバスコンテキストから現在のテクスチャを取得し、
      // レンダリングするテクスチャとして設定します。
      renderPassDescriptor.colorAttachments[0].view =
          context.getCurrentTexture().createView();
      renderPassDescriptor.colorAttachments[0].clearValue = clearValue;

-      const { canvas } = context;
      const aspect = canvas.clientWidth / canvas.clientHeight;
      mat4.ortho(-aspect, aspect, -1, 1, -1, 1, matrixValue);
      mat4.rotateZ(matrixValue, time * 0.1 + rotation, matrixValue);

      // ユニフォーム値をアップロードします。
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      // レンダリング固有のコマンドをエンコードするためのレンダーパスエンコーダーを作成します
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);  // 頂点シェーダーを3回呼び出します。
      pass.end();
-    }
+    };

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    requestId = requestAnimationFrame(render);
  }
</pre>
<p>そして、これで、実際に表示されているキャンバスのみを描画しています。これにより、うまくいけばはるかに軽くなるはずです。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-multiple-canvases-x200-optimized.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-multiple-canvases-x200-optimized.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="notranslate" translate="no">IntersectionObserver</code></a>は、すべてのケースをカバーするわけではないでしょう。各キャンバスに非常に重いものを描画している場合は、ユーザーが選択したキャンバスのみをアニメーション化したい場合があります。いずれにせよ、うまくいけば、ツールボックスにさらに1つのツールが追加されました。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-multiple-canvases.html">English
    </option><option value="/webgpu/lessons/es/webgpu-multiple-canvases.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-multiple-canvases.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-multiple-canvases.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-multiple-canvases.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-multiple-canvases.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-multiple-canvases.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 複数のキャンバス`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>