<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ja/webgpu-compatibility-mode.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="古いマシンでの実行">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_ja.jpg">

<meta property="og:title" content="WebGPU 互換モード">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_ja.jpg">
<meta property="og:description" content="古いマシンでの実行">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 互換モード">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html">
<meta name="twitter:description" content="古いマシンでの実行">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html",
      "inLanguage":"ja",
      "name":"WebGPU 互換モード",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ja/webgpu-compatibility-mode.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 互換モード</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-compatibility-mode.html">English
    </option><option value="/webgpu/lessons/es/webgpu-compatibility-mode.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compatibility-mode.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compatibility-mode.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compatibility-mode.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compatibility-mode.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compatibility-mode.html">简体中文
</option></select>


    <a href="#toc">目次</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ja/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 互換モード</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <div class="warn">この記事はGemini Code Assistによって自動翻訳されました。翻訳に問題がある場合は、お手数ですが<a href="https://github.com/webgpu/webgpufundamentals/pulls">こちら</a>からPull Requestを送信してください。</div>
<p>WebGPU互換モードは、いくつかの制限付きで、古いデバイスでも実行できるWebGPUのバージョンです。アイデアとしては、いくつかの追加の制限と制約内でアプリを実行できるようにすれば、WebGPU互換アダプターを要求して、より多くの場所でアプリを実行できるようになります。</p>
<blockquote>
<p>注：互換モードはまだ正式に出荷されていません。お使いのブラウザでは実験的に利用できる場合があります。<a href="https://www.google.com/chrome/canary/">Chrome Canary</a>では、バージョン136.0.7063.0（2025-03-11）以降、<code class="notranslate" translate="no">chrome://flags/#enable-unsafe-webgpu</code>にアクセスして「enable-unsafe-webgpu」フラグを有効にすることで互換モードを許可できます。</p>
</blockquote>
<p>互換モードで何ができるかについて少し説明すると、事実上<em>ほぼ</em>すべてのWebGL2プログラムを互換モードで実行するように変換できます。</p>
<p>方法は次のとおりです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const device = await adapter.requestDevice();
</pre>
<p>簡単です！互換モードのすべての制限に従うすべてのアプリは、有効な「コア」WebGPUアプリであり、WebGPUがすでに実行されている場所ならどこでも実行されることに注意してください。</p>
<h1 id="主な制限と制約">主な制限と制約</h1>
<h2 id="頂点シェーダーでストレージバッファが0になる可能性がある">頂点シェーダーでストレージバッファが0になる可能性がある</h2>
<p>WebGPUアプリに最も影響を与える可能性のある主な制限は、これらの古いデバイスの約45％が頂点シェーダーでストレージバッファをサポートしていないことです。</p>
<p>この機能は、このサイトの3番目の記事である<a href="webgpu-storage-buffers.html">ストレージバッファに関する記事</a>で使用しました。その記事の後、<a href="webgpu-vertex-buffers.html">頂点バッファの使用に切り替えました</a>。頂点バッファの使用は一般的であり、どこでも機能しますが、特定のソリューションはストレージバッファを使用する方が簡単です。一例として、<a href="https://webgpu.github.io/webgpu-samples/?sample=wireframe">ワイヤーフレームを描画するこの例</a>があります。頂点データから三角形を生成するためにストレージバッファを使用します。</p>
<p>ストレージバッファに格納された頂点データを使用すると、頂点データにランダムにアクセスできます。頂点バッファ内の頂点データではできません。もちろん、常に他の解決策があります。</p>
<h2 id="中程度の制限と制約">中程度の制限と制約</h2>
<h2 id="テクスチャには単一のviewdimensionのみが許可されます。">テクスチャには単一のviewDimensionのみが許可されます。</h2>
<p>通常のWebGPUでは、次のように2Dテクスチャを作成できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const myTexture = device.createTexture({
  size: [width, height, 6],
  usage: ...
  format: ...
});
</pre>
<p>その後、3つの異なるビューディメンションで表示できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// myTextureを6層の2D配列として表示
const as2DArray = myTexture.createView();

// myTextureのレイヤー3を2Dテクスチャとして表示
const as2D = myTexture.createView({
  viewDimension: '2d',
  baseArrayLayer: 3,
  arrayLayerCount: 1,
});

// myTextureをキューブマップとして表示
const asCube = myTexture.createView({
  viewDimension: 'cube',
});
</pre>
<p>互換モードでは、1つのビューディメンションしか使用できず、テクスチャを作成するときにどのviewDimensionかを選択する必要があります。1層の2Dテクスチャは、デフォルトで<code class="notranslate" translate="no">'2d'</code>ビューとしてのみ使用できます。1層を超える2Dテクスチャは、デフォルトで<code class="notranslate" translate="no">'2d-array</code>’ビューとしてのみ使用できます。デフォルト以外のものが必要な場合は、WebGPUに指示する必要があります。たとえば、キューブマップが必要な場合は、テクスチャを作成するときにWebGPUに指示する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cubeTexture = device.createTexture({
  size: [width, height, 6],
  usage: ...
  format: ...
  textureBindingViewDimension: 'cube', 
});
</pre>
<p>この追加パラメータは、<code class="notranslate" translate="no">TEXTURE_BINDING</code>の使用法でテクスチャを使用することに関連しているため、<code class="notranslate" translate="no">textureBindingViewDimension</code>と呼ばれていることに注意してください。キューブマップまたは2D配列の単一レイヤーを<code class="notranslate" translate="no">RENDER_ATTACHMENT</code>として2Dテクスチャとして使用することはできます。</p>
<p>互換モードでは、別のタイプのビューでテクスチャを使用すると、検証エラーが生成されます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// cubeTextureを6層の2D配列として表示
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // 互換モードでのエラー：テクスチャはキューブマップであり、2D配列ではありません
      resource: cubeTexture.createView(),
    },
  ],
})
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// cubeTextureのレイヤー3を2Dテクスチャとして表示
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // 互換モードでのエラー：テクスチャはキューブマップであり、2Dではありません
      resource: cubeTexture.createView({
        viewDimension: '2d',
        baseArrayLayer: 3,
        arrayLayerCount: 1,
      }),
    },
  ]
});
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// cubeTextureをキューブマップとして表示
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // OK!
      resource: cubeTexture.createView({
        viewDimension: 'cube',
      }),
    },
  ],
});
</pre>
<p>この制限はそれほど大きな問題ではありません。異なる種類のビューでテクスチャを使用したいプログラムはほとんどありません。</p>
<h2 id="texturecreateviewを呼び出すとき、bindgroupでレイヤーのサブセットを選択することはできません"><code class="notranslate" translate="no">texture.createView</code>を呼び出すとき、bindGroupでレイヤーのサブセットを選択することはできません</h2>
<p>コアWebGPUでは、いくつかのレイヤーを持つテクスチャを作成できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const texture = device.createTexture({
  size: [64, 128, 8],   // 8レイヤー
  ...
});
</pre>
<p>その後、レイヤーのサブセットを選択できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // 互換モードでのエラー - レイヤー3と4を選択
      resource: cubeTexture.createView({
        baseArrayLayer: 3,
        arrayLayerCount: 2,
      }),
    },
  ],
});
</pre>
<p>この制限もそれほど大きな問題ではありません。テクスチャからレイヤーのサブセットを選択したいプログラムはほとんどありません。</p>
<h2 id="互換モードでのミップマップの生成"><a id="a-generating-mipmaps"></a> 互換モードでのミップマップの生成</h2>
<p>ただし、これら両方の制限が発生する場所が1つあり、それは一般的なユースケースであるミップマップの生成時です。</p>
<p><a href="../webgpu-importing-textures.html#a-generating-mips-on-the-gpu">テクスチャへの画像のインポートに関する記事</a>で、GPUベースのミップマップジェネレーターを作成したことを思い出してください。<a href="../webgpu-cube-maps.html#a-texture-helpers">キューブマップに関する記事</a>で、2D配列とキューブマップのミップマップを生成するようにその関数を変更しました。そのバージョンでは、テクスチャの各レイヤーを常に<code class="notranslate" translate="no">'2d'</code>ディメンションで表示して、テクスチャの1つのレイヤーのみを参照していました。これは、上記の理由により互換モードでは機能しません。<code class="notranslate" translate="no">'2d-array'</code>または<code class="notranslate" translate="no">'cube'</code>テクスチャの<code class="notranslate" translate="no">'2d'</code>ビューを使用することはできません。また、読み取るレイヤーを選択するためにバインドグループで個々のレイヤーを選択することもできません。</p>
<p>コードを互換モードで動作させるには、作成されたのと同じビューディメンションのテクスチャを操作する必要があり、<code class="notranslate" translate="no">createView</code>を介してレイヤーを選択するのではなく、すべてのレイヤーにアクセスできるテクスチャを渡し、シェーダー自体で目的のレイヤーを選択する必要があります。</p>
<p>では、やってみましょう！<a href="../webgpu-cube-maps.html#a-texture-helpers">キューブマップに関する記事</a>の<code class="notranslate" translate="no">generateMips</code>のコードから始めます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {
    let sampler;
    let module;
    const pipelineByFormat = {};

    return function generateMips(device, texture) {
      if (!module) {
        module = device.createShaderModule({
          label: 'textured quad shaders for mip level generation',
          code: `
            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32
            ) -&gt; VSOutput {
              let pos = array(

                vec2f( 0.0,  0.0),  // center
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 0.0,  1.0),  // center, top

                // 2st triangle
                vec2f( 0.0,  1.0),  // center, top
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 1.0,  1.0),  // right, top
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);
              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;
            @group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;

            @fragment fn fs(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(ourTexture, ourSampler, fsInput.texcoord);
            }
          `,
        });

        sampler = device.createSampler({
          minFilter: 'linear',
          magFilter: 'linear',
        });
      }

      if (!pipelineByFormat[texture.format]) {
        pipelineByFormat[texture.format] = device.createRenderPipeline({
          label: 'mip level generator pipeline',
          layout: 'auto',
          vertex: {
            module,
          },
          fragment: {
            module,
            targets: [{ format: texture.format }],
          },
        });
      }
      const pipeline = pipelineByFormat[texture.format];

      const encoder = device.createCommandEncoder({
        label: 'mip gen encoder',
      });

      for (let baseMipLevel = 1; baseMipLevel &lt; texture.mipLevelCount; ++baseMipLevel) {
        for (let layer = 0; layer &lt; texture.depthOrArrayLayers; ++layer) {
          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: sampler },
              {
                binding: 1,
                resource: texture.createView({
                  dimension: '2d',
                  baseMipLevel: baseMipLevel - 1,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
              },
            ],
          });

          const renderPassDescriptor = {
            label: 'our basic canvas renderPass',
            colorAttachments: [
              {
                view: texture.createView({
                  dimension: '2d',
                  baseMipLevel: baseMipLevel,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
                loadOp: 'clear',
                storeOp: 'store',
              },
            ],
          };

          const pass = encoder.beginRenderPass(renderPassDescriptor);
          pass.setPipeline(pipeline);
          pass.setBindGroup(0, bindGroup);
          pass.draw(6);  // call our vertex shader 6 times
          pass.end();
        }
      }

      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    };
  })();
</pre>
<p>テクスチャの種類（2D、2D配列、キューブなど）ごとに異なるフラグメントシェーダーを使用するようにWGSLを変更し、読み取るレイヤーを渡せるようにする必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+const faceMat = array(
+  mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x
+  mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x
+  mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y
+  mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y
+  mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z
+  mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
+  @location(1) @interpolate(flat, either) baseArrayLayer: u32,
};

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
+  @builtin(instance_index) baseArrayLayer: u32,
) -&gt; VSOutput {
  var pos = array&lt;vec2f, 3&gt;(
    vec2f(-1.0, -1.0),
    vec2f(-1.0,  3.0),
    vec2f( 3.0, -1.0),
  );

  var vsOutput: VSOutput;
  let xy = pos[vertexIndex];
  vsOutput.position = vec4f(xy, 0.0, 1.0);
  vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
+  vsOutput.baseArrayLayer = baseArrayLayer;
  return vsOutput;
}

@group(0) @binding(0) var ourSampler: sampler;
-@group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;

+@group(0) @binding(1) var ourTexture2d: texture_2d&lt;f32&gt;;
@fragment fn fs2d(fsInput: VSOutput) -&gt; @location(0) vec4f {
-  return textureSample(ourTexture, ourSampler, fsInput.texcoord);
+  return textureSample(ourTexture2d, ourSampler, fsInput.texcoord);
}

+@group(0) @binding(1) var ourTexture2dArray: texture_2d_array&lt;f32&gt;;
+@fragment fn fs2darray(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTexture2dArray,
+    ourSampler,
+    fsInput.texcoord,
+    fsInput.baseArrayLayer);
+}
+
+@group(0) @binding(1) var ourTextureCube: texture_cube&lt;f32&gt;;
+@fragment fn fscube(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTextureCube,
+    ourSampler,
+    faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1));
+}
+
+@group(0) @binding(1) var ourTextureCubeArray: texture_cube_array&lt;f32&gt;;
+@fragment fn fscubearray(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTextureCubeArray,
+    ourSampler,
+    faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1), fsInput.baseArrayLayer);
+}
</pre>
<p>このコードには、<code class="notranslate" translate="no">'2d'</code>、<code class="notranslate" translate="no">'2d-array'</code>、<code class="notranslate" translate="no">'cube'</code>、<code class="notranslate" translate="no">'cube-array'</code>のそれぞれに対応する4つのフラグメントシェーダーがあります。<a href="webgpu-large-triangle-to-cover-clip-space.html">クリップ空間をカバーするための大きな三角形</a>のテクニックを<a href="webgpu-large-triangle-to-cover-clip-space.html">他の場所でカバー</a>して描画します。また、<code class="notranslate" translate="no">@builtin(instance_index)</code>を使用してレイヤーを選択します。これは、ユニフォームバッファを使用せずに単一の整数値をシェーダーに渡すための興味深く迅速な方法です。<code class="notranslate" translate="no">draw</code>を呼び出すとき、4番目のパラメータは最初のインスタンスであり、シェーダーに<code class="notranslate" translate="no">@builtin(instance_index)</code>として渡されます。これを頂点シェーダーからフラグメントシェーダーに<code class="notranslate" translate="no">VSOutput.baseArrayLayer</code>を介して渡し、フラグメントシェーダーで<code class="notranslate" translate="no">fsInput.baseArrayLayer</code>として参照できます。</p>
<p>キューブマップコードは、2D配列レイヤーと正規化されたUV座標をキューブマップ3D座標に変換します。これは、互換モードではキューブマップはキューブマップとしてしか表示できないため、再び必要になります。</p>
<p>JavaScriptに戻り、ユーザーがテクスチャを作成したときに使用したviewDimensionを渡せるようにして、これらのシェーダーの1つを選択できるようにする必要があります。渡されない場合は、デフォルトから推測します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  /**
+  * デフォルトのviewDimensionを取得します
+  * 注：これは単なる推測です。ユーザーはすべての場合で
+  * 正しくするために私たちに指示する必要があります。なぜなら、1層の2Dテクスチャと
+  * 2D配列テクスチャを区別できず、6層の2D配列テクスチャと
+  * キューブマップを区別することもできないからです。
+  */
+  function getDefaultViewDimensionForTexture(dimension, depthOrArrayLayers) {
+   switch (dimension) {
+      case '1d':
+        return '1d';
+      default:
+      case '2d':
+        return depthOrArrayLayers &gt; 1 ? '2d-array' : '2d';
+      case '3d':
+        return '3d';
+    }
+  }

  const generateMips = (() =&gt; {
    let sampler;
    let module;
    const pipelineByFormat = {};

-    return function generateMips(device, texture) {
+    return function generateMips(device, texture, textureBindingViewDimension) {
+      // ユーザーがtextureBindingViewDimensionを渡さない場合は推測します
+      textureBindingViewDimension = textureBindingViewDimension ??
+        getDefaultViewDimensionForTexture(texture.dimension, texture.depthOrArrayLayers);
      if (!module) {
        module = device.createShaderModule({
          label: 'textured quad shaders for mip level generation',
          code: `
            const faceMat = array(
              mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x
              mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x
              mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y
              mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y
              mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z
              mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z

            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
              @location(1) @interpolate(flat, either) baseArrayLayer: u32,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32,
              @builtin(instance_index) baseArrayLayer: u32,
            ) -&gt; VSOutput {
              var pos = array&lt;vec2f, 3&gt;(
                vec2f(-1.0, -1.0),
                vec2f(-1.0,  3.0),
                vec2f( 3.0, -1.0),
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy, 0.0, 1.0);
              vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
              vsOutput.baseArrayLayer = baseArrayLayer;
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;

            @group(0) @binding(1) var ourTexture2d: texture_2d&lt;f32&gt;;
            @fragment fn fs2d(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(ourTexture2d, ourSampler, fsInput.texcoord);
            }

            @group(0) @binding(1) var ourTexture2dArray: texture_2d_array&lt;f32&gt;;
            @fragment fn fs2darray(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTexture2dArray,
                ourSampler,
                fsInput.texcoord,
                fsInput.baseArrayLayer);
            }

            @group(0) @binding(1) var ourTextureCube: texture_cube&lt;f32&gt;;
            @fragment fn fscube(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTextureCube,
                ourSampler,
                faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1));
            }

            @group(0) @binding(1) var ourTextureCubeArray: texture_cube_array&lt;f32&gt;;
            @fragment fn fscubearray(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTextureCubeArray,
                ourSampler,
                faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1), fsInput.baseArrayLayer);
            }
          `,
        });

        sampler = device.createSampler({
          minFilter: 'linear',
          magFilter: 'linear',
        });
      }

    ...
</pre>
<p>以前は、同じフォーマットのテクスチャにパイプラインを再利用できるように、フォーマットごとにパイプラインを追跡していました。これを、ビューディメンションごとにフォーマットごとにパイプラインになるように更新する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {
    let sampler;
    let module;
-    const pipelineByFormat = {};
+    const pipelineByFormatAndView = {};

    return function generateMips(device, texture, textureBindingViewDimension) {
      // ユーザーがtextureBindingViewDimensionを渡さない場合は推測します
      textureBindingViewDimension = textureBindingViewDimension ??
        getDefaultViewDimensionForTexture(texture);
      let module = moduleByViewDimension[textureBindingViewDimension];
      if (!module) {
        ...
      }

+      const id = `${texture.format}.${textureBindingViewDimension}`;

-      if (!pipelineByFormat[texture.format]) {
-        pipelineByFormat[texture.format] = device.createRenderPipeline({
-          label: 'mip level generator pipeline',
+      if (!pipelineByFormatAndView[id]) {
+        // viewDimensionに基づいてフラグメントシェーダーを選択します（2d-arrayとcube-arrayから'-'を削除します）
+        const entryPoint = `fs${textureBindingViewDimension.replace(/[\W]/, '')}`;
+        pipelineByFormatAndView[id] = device.createRenderPipeline({
+          label: `mip level generator pipeline for ${textureBindingViewDimension}, format: ${texture.format}`,
          layout: 'auto',
          vertex: {
            module,
          },
          fragment: {
            module,
            entryPoint,
            targets: [{ format: texture.format }],
          },
        });
      }
-      const pipeline = pipelineByFormat[texture.format];
+      const pipeline = pipelineByFormatAndView[id];

      ...
}
</pre>
<p>次に、ミップマップを生成するループを変更して、完全なレイヤーを使用するようにする必要があります。互換モードではレイヤーのサブ範囲が許可されていないためです。また、描画を介してインスタンスインデックスを渡す機能を使用して、読み取りたいレイヤーを選択する必要もあります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {

      ...

      const pipeline = pipelineByFormatAndView[id];

      for (let baseMipLevel = 1; baseMipLevel &lt; texture.mipLevelCount; ++baseMipLevel) {
        for (let layer = 0; layer &lt; texture.depthOrArrayLayers; ++layer) {
          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: sampler },
              {
                binding: 1,
                resource: texture.createView({
-                  dimension: '2d',
+                  dimension: textureBindingViewDimension,
                  baseMipLevel: baseMipLevel - 1,
                  mipLevelCount: 1,
-                  baseArrayLayer: layer,
-                  arrayLayerCount: 1,
                }),
              },
            ],
          });

          const renderPassDescriptor = {
            label: 'our basic canvas renderPass',
            colorAttachments: [
              {
                view: texture.createView({
                  dimension: '2d',
                  baseMipLevel,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
                loadOp: 'clear',
                storeOp: 'store',
              },
            ],
          };

          const pass = encoder.beginRenderPass(renderPassDescriptor);
          pass.setPipeline(pipeline);
          pass.setBindGroup(0, bindGroup);
-          pass.draw(6);
+          // 3つの頂点、1つのインスタンス、最初のインスタンス（instance_index）= レイヤーを描画します
+          pass.draw(3, 1, 0, layer);
          pass.end();
        }
      }

      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    };
  })();
</pre>
<p>これで、ミップマップ生成コードは互換モードで動作し、コアWebGPUでも引き続き動作します。</p>
<p>ただし、この例を機能させるには、他にもいくつか更新する必要があります。</p>
<p>ソースを渡してテクスチャを作成する<code class="notranslate" translate="no">createTextureFromSources</code>という関数があります。コアでは6層の<code class="notranslate" translate="no">'2d'</code>テクスチャをキューブマップとして表示できるため、常に<code class="notranslate" translate="no">'2d'</code>テクスチャを作成していました。代わりに、viewDimensionやdimensionを渡せるようにして、テクスチャを作成するときに互換モードにどのように表示するかを伝えられるようにする必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function textureViewDimensionToDimension(viewDimension) {
+   switch (viewDimension) {
+      case '1d': return '1d';
+      case '3d': return '3d';
+      default: return '2d';
+    }
+  }

  function createTextureFromSources(device, sources, options = {}) {
+    const viewDimension = options.viewDimension ??
+      getDefaultViewDimensionForTexture(options.dimension, sources.length);
+    const dimension = options.dimension ?? textureViewDimensionToDimension(viewDimension);
    // すべてのソースが同じサイズであると仮定し、幅と高さには最初のソースのみを使用します
    const source = sources[0];
    const texture = device.createTexture({
      format: 'rgba8unorm',
      mipLevelCount: options.mips ? numMipLevels(source.width, source.height) : 1,
      size: [source.width, source.height, sources.length],
      usage: GPUTextureUsage.TEXTURE_BINDING |
             GPUTextureUsage.COPY_DST |
             GPUTextureUsage.RENDER_ATTACHMENT,
+      dimension,
+      textureBindingViewDimension: viewDimension,
    });
    copySourcesToTexture(device, texture, sources, options);
    return texture;
  }
</pre>
<p>また、<code class="notranslate" translate="no">copySourcesToTexture</code>を更新して<code class="notranslate" translate="no">viewDimension</code>を取得し、<code class="notranslate" translate="no">generateMips</code>に渡す必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function copySourcesToTexture(device, texture, sources, {flipY, viewDimension} = {}) {
    sources.forEach((source, layer) =&gt; {
      device.queue.copyExternalImageToTexture(
        { source, flipY, },
        { texture, origin: [0, 0, layer] },
        { width: source.width, height: source.height },
      );
    });
    if (texture.mipLevelCount &gt; 1) {
+      viewDimension = viewDimension ??
+        getDefaultViewDimensionForTexture(texture.dimension, sources.length);
+      generateMips(device, texture, viewDimension);
-      generateMips(device, texture);
    }
  }
</pre>
<p>そして、<code class="notranslate" translate="no">createTextureFromSources</code>の呼び出しを更新して、事前にキューブマップが必要であることを伝える必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const texture = await createTextureFromSources(
-      device, faceCanvases, {mips: true, flipY: false});
+      device, faceCanvases, {mips: true, flipY: false, viewDimension: 'cube'});
</pre>
<p>この例を互換モードで実行するには、この記事の冒頭で説明したように要求する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
-  const adapter = await navigator.gpu?.requestAdapter()
+  const adapter = await navigator.gpu?.requestAdapter({
+    featureLevel: 'compatibility',
+  });
  const device = await adapter?.requestDevice();

  ...
</pre>
<p>これで、キューブマップのサンプルは互換モードで動作します。</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-compatibility-mode-generatemips.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-compatibility-mode-generatemips.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

<p></p>
<p>これで、互換モードに対応した<code class="notranslate" translate="no">generateMips</code>ができました。このサイトのどの例でも使用できます。コアモードと互換モードの両方で動作します。互換モードでは、キューブマップが必要な場合や、1層の2D配列が必要な場合は<code class="notranslate" translate="no">viewDimension</code>を渡す必要があります。コアWebGPUでは、渡しても渡さなくてもかまいません。問題ありません。</p>
<h1 id="マイナーな制限と制約">マイナーな制限と制約</h1>
<p>以下は、<em>ほとんど</em>のプログラムが遭遇する可能性の低い制限と制約です。</p>
<ul>
<li>
<h2 id="カラーブレンディングは、すべてのカラーターゲットで一致する必要があります。">カラーブレンディングは、すべてのカラーターゲットで一致する必要があります。</h2>
<p>コアでは、レンダーパイプラインを作成するときに、各カラーターゲットでブレンディング設定を指定できます。<a href="webgpu-transparency.html">ブレンディングと透明度に関する記事</a>でブレンディング設定を使用しました。互換モードでは、単一のパイプライン内のすべてのカラーターゲットにわたるすべての設定が同じでなければなりません。</p>
</li>
<li>
<h2 id="copytexturetobufferとcopytexturetotextureは、圧縮テクスチャでは機能しません。"><code class="notranslate" translate="no">copyTextureToBuffer</code>と<code class="notranslate" translate="no">copyTextureToTexture</code>は、圧縮テクスチャでは機能しません。</h2>
</li>
<li>
<h2 id="copytexturetotextureは、マルチサンプルテクスチャでは機能しません。"><code class="notranslate" translate="no">copyTextureToTexture</code>は、マルチサンプルテクスチャでは機能しません。</h2>
</li>
<li>
<h2 id="cube-arrayはサポートされていません。"><code class="notranslate" translate="no">cube-array</code>はサポートされていません。</h2>
</li>
<li>
<h2 id="テクスチャのビューは、単一の描画ディスパッチ呼び出しでアスペクトまたはミップレベルが異なってはなりません。">テクスチャのビューは、単一の描画/ディスパッチ呼び出しでアスペクトまたはミップレベルが異なってはなりません。</h2>
<p>コアWebGPUでは、テクスチャの複数のテクスチャビューを異なるミップレベルに作成し、同じ描画呼び出しで使用できます。これは一般的ではありません。この制限は<code class="notranslate" translate="no">TEXTURE_BINDING</code>の使用法、つまりバインドグループを介したテクスチャの使用に関するものであることに注意してください。上記のミップマップ生成コードで行ったように、<code class="notranslate" translate="no">RENDER_ATTACHMENT</code>として別のビューを使用することはできます。</p>
</li>
<li>
<h2 id="builtinsample_maskとbuiltinsample_indexはサポートされていません。"><code class="notranslate" translate="no">@builtin(sample_mask)</code>と<code class="notranslate" translate="no">@builtin(sample_index)</code>はサポートされていません。</h2>
</li>
<li>
<h2 id="rg32uint、rg32sint、rg32floatテクスチャフォーマットは、ストレージテクスチャとして使用できません。"><code class="notranslate" translate="no">rg32uint</code>、<code class="notranslate" translate="no">rg32sint</code>、<code class="notranslate" translate="no">rg32float</code>テクスチャフォーマットは、ストレージテクスチャとして使用できません。</h2>
</li>
<li>
<h2 id="depthclampbiasは0でなければなりません。"><code class="notranslate" translate="no">depthClampBias</code>は0でなければなりません。</h2>
<p>これは、レンダーパイプラインを作成するときの設定です。</p>
</li>
<li>
<h2 id="interpolationlinearとinterpolation-sampleはサポートされていません。"><code class="notranslate" translate="no">@interpolation(linear)</code>と<code class="notranslate" translate="no">@interpolation(..., sample)</code>はサポートされていません。</h2>
<p>これらは、<a href="../webgpu-inter-stage-variables.html#a-interpolate">ステージ間変数に関する記事</a>で簡単に触れました。</p>
</li>
<li>
<h2 id="interpolateflatとinterpolateflat-firstはサポートされていません。"><code class="notranslate" translate="no">@interpolate(flat)</code>と<code class="notranslate" translate="no">@interpolate(flat, first)</code>はサポートされていません。</h2>
<p>互換モードでは、フラット補間が必要な場合は<code class="notranslate" translate="no">@interpolate(flat, either)</code>を使用する必要があります。<code class="notranslate" translate="no">either</code>は、フラグメントシェーダーに渡される値が、描画される三角形または線の最初または最後の頂点のいずれかの値になる可能性があることを意味します。</p>
<p>これが問題にならないことは一般的です。頂点シェーダーからフラグメントシェーダーにフラット補間で何かを渡す最も一般的なユースケースは、通常、モデルごと、マテリアルごと、またはインスタンスごとのタイプの値です。たとえば、上記のミップマップ生成コードでは、<code class="notranslate" translate="no">instance_index</code>をフラグメントシェーダーに渡すために上記のフラット補間を使用しました。これは三角形のすべての頂点で同じになるため、<code class="notranslate" translate="no">@interpolate(flat, either)</code>で問題なく機能します。</p>
</li>
<li>
<h2 id="テクスチャフォーマットは再解釈できません。">テクスチャフォーマットは再解釈できません。</h2>
<p>コアWebGPUでは、<code class="notranslate" translate="no">'rgba8unorm'</code>テクスチャを作成し、<code class="notranslate" translate="no">'rgba8unorm-srgb'</code>テクスチャとして表示したり、その逆を行ったり、他の<code class="notranslate" translate="no">'-srgb'</code>フォーマットとそれに対応する非<code class="notranslate" translate="no">'-srgb'</code>フォーマットを表示したりできます。互換モードではこれは許可されていません。テクスチャを作成したフォーマットが、使用できる唯一のフォーマットです。</p>
</li>
<li>
<h2 id="bgra8unorm-srgbはサポートされていません。"><code class="notranslate" translate="no">bgra8unorm-srgb</code>はサポートされていません。</h2>
</li>
<li>
<h2 id="rgba16floatおよびr32floatテクスチャはマルチサンプリングできません。"><code class="notranslate" translate="no">rgba16float</code>および<code class="notranslate" translate="no">r32float</code>テクスチャはマルチサンプリングできません。</h2>
</li>
<li>
<h2 id="すべての整数テクスチャフォーマットはマルチサンプリングできません。">すべての整数テクスチャフォーマットはマルチサンプリングできません。</h2>
</li>
<li>
<h2 id="depthorarraylayersはtexturebindingviewdimensionと互換性がなければなりません。"><code class="notranslate" translate="no">depthOrArrayLayers</code>は<code class="notranslate" translate="no">textureBindingViewDimension</code>と互換性がなければなりません。</h2>
<p>これは、<code class="notranslate" translate="no">textureBindingViewDimension: '2d'</code>とマークされたテクスチャは<code class="notranslate" translate="no">depthOrArrayLayers: 1</code>（デフォルト）でなければならないことを意味します。<code class="notranslate" translate="no">textureBindingViewDimension: 'cube'</code>とマークされたテクスチャは<code class="notranslate" translate="no">depthOrArrayLayers: 6</code>でなければなりません。</p>
</li>
<li>
<h2 id="textureloadは深度テクスチャでは機能しません。"><code class="notranslate" translate="no">textureLoad</code>は深度テクスチャでは機能しません。</h2>
<p>「深度テクスチャ」とは、WGSLで<code class="notranslate" translate="no">texture_depth</code>、<code class="notranslate" translate="no">texture_depth_2d_array</code>、または<code class="notranslate" translate="no">texture_depth_cube</code>で参照されるテクスチャです。これらは互換モードでは<code class="notranslate" translate="no">textureLoad</code>で使用できません。ß</p>
<p>一方、<code class="notranslate" translate="no">textureLoad</code>は<code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>、<code class="notranslate" translate="no">texture_2d_array&lt;f32&gt;</code>、<code class="notranslate" translate="no">texture_cube&lt;f32&gt;</code>で使用でき、深度フォーマットを持つテクスチャはこれらのバインディングにバインドできます。</p>
</li>
<li>
<h2 id="深度テクスチャは、非比較サンプラーでは使用できません。">深度テクスチャは、非比較サンプラーでは使用できません。</h2>
<p>繰り返しになりますが、「深度テクスチャ」とは、WGSLで<code class="notranslate" translate="no">texture_depth</code>、<code class="notranslate" translate="no">texture_depth_2d_array</code>、または<code class="notranslate" translate="no">texture_depth_cube</code>で参照されるテクスチャです。これらは互換モードでは非比較サンプラーでは使用できません。</p>
<p>これは、事実上、<code class="notranslate" translate="no">texture_depth</code>、<code class="notranslate" translate="no">texture_depth_2d_array</code>、および<code class="notranslate" translate="no">texture_depth_cube</code>は、互換モードでは<code class="notranslate" translate="no">textureSampleCompare</code>、<code class="notranslate" translate="no">textureSampleCompareLevel</code>、および<code class="notranslate" translate="no">textureGatherCompare</code>でのみ使用できることを意味します。</p>
<p>一方、深度フォーマットを使用するテクスチャを<code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>、<code class="notranslate" translate="no">texture_2d_array&lt;f32&gt;</code>、および<code class="notranslate" translate="no">texture_cube&lt;f32&gt;</code>バインディングにバインドできます。ただし、非フィルタリングサンプラーを使用する必要があるという通常の制限に従います。</p>
</li>
<li>
<h2 id="テクスチャとサンプラーの組み合わせはより制限されています。">テクスチャとサンプラーの組み合わせはより制限されています。</h2>
<p>コアでは、16以上のテクスチャと16以上のサンプラーをバインドし、シェーダーで256以上のすべての組み合わせを使用できます。</p>
<p>互換モードでは、単一のステージで合計16の組み合わせしか使用できません。</p>
<p>実際のルールはもう少し複雑です。疑似コードで詳しく説明します。</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">maxCombinationsPerStage =
   min(device.limits.maxSampledTexturesPerShaderStage, device.limits.maxSamplersPerShaderStage)
for each stage of the pipeline:
  sum = 0
  for each texture binding in the pipeline layout which is visible to that stage:
    sum += max(1, number of texture sampler combos for that texture binding)
  for each external texture binding in the pipeline layout which is visible to that stage:
    sum += 1 // for LUT texture + LUT sampler
    sum += 3 * max(1, number of external_texture sampler combos) // for Y+U+V
  if sum &gt; maxCombinationsPerStage
    generate a validation error.
</pre>
</li>
<li>
<h2 id="互換モードでは、一部のデフォルトの制限が低くなっています。">互換モードでは、一部のデフォルトの制限が低くなっています。</h2>
<table>
<thead>
<tr>
<th style="text-align:left">制限</th>
<th style="text-align:right">互換</th>
<th style="text-align:right">コア</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxColorAttachments</code></td>
<td style="text-align:right">4</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeWorkgroupSizeX</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeWorkgroupSizeY</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxInterStageShaderVariables</code></td>
<td style="text-align:right">15</td>
<td style="text-align:right">16</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxTextureDimension1D</code></td>
<td style="text-align:right">4096</td>
<td style="text-align:right">8192</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxTextureDimension2D</code></td>
<td style="text-align:right">4096</td>
<td style="text-align:right">8192</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxUniformBufferBindingSize</code></td>
<td style="text-align:right">16384</td>
<td style="text-align:right">65536</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxVertexAttributes</code></td>
<td style="text-align:right">16<sup>a</sup></td>
<td style="text-align:right">16</td>
</tr>
</tbody>
</table>
<p>(a) 互換モードでは、<code class="notranslate" translate="no">@builtin(vertex_index)</code>および/または<code class="notranslate" translate="no">@builtin(instance_index)</code>を使用すると、それぞれが属性としてカウントされます。</p>
<p>もちろん、アダプターはこれらのいずれかに対してより高い制限をサポートしている場合があります。</p>
</li>
<li>
<h2 id="4つの新しい制限があります。">4つの新しい制限があります。</h2>
<ul>
<li><code class="notranslate" translate="no">maxStorageBuffersInVertexStage</code>（デフォルト0）</li>
<li><code class="notranslate" translate="no">maxStorageTexturesInVertexStage</code>（デフォルト0）</li>
<li><code class="notranslate" translate="no">maxStorageBuffersInFragmentStage</code>（デフォルト4）</li>
<li><code class="notranslate" translate="no">maxStorageTexturesInFragmentStage</code>（デフォルト4）</li>
</ul>
<p>他の制限と同様に、アダプターを要求するときにアダプターがサポートするものを確認し、必要に応じてデフォルトよりも高い値を要求できます。</p>
<p>上記のように、約45％のデバイスは、頂点シェーダーで<code class="notranslate" translate="no">0</code>のストレージバッファとストレージテクスチャをサポートしています。</p>
</li>
</ul>
<h1 id="互換モードからコアへのアップグレード">互換モードからコアへのアップグレード</h1>
<p>互換モードは、オプトインするように設計されています。上記の制限でアプリケーションを設計できる場合は、互換モードを要求します。そうでない場合は、デフォルトのコアを要求します。デバイスがコアを処理できない場合は、アダプターを返しません。</p>
<p>一方、アプリを互換モードで機能するように設計し、ユーザーがコアWebGPUをサポートするデバイスを持っている場合は、すべてのコア機能を利用することもできます。</p>
<p>これを行うには、互換モードアダプターを要求し、<code class="notranslate" translate="no">core-features-and-limits</code>機能を確認して有効にします。アダプターに存在し、デバイスで要求した場合、デバイスはコアデバイスになり、上記の制限は適用されません。</p>
<p>例：</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const hasCore = adapter.features.has('core-features-and-limits');
const device = await adapter.requestDevice({
  requiredFeatures: [
    ...(hasCore ? ['core-features-and-limits'] : []),
  ],
});
</pre>
<p><code class="notranslate" translate="no">hasCore</code>がtrueの場合、上記の制限と制約は適用されません。</p>
<p>デバイスがコアか互換かを確認したい他のコードは、デバイスの機能を確認する必要があることに注意してください。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const isCore = device.features.has('core-features-and-limits');
</pre>
<p>これは、コアデバイスでは常にtrueになります。</p>
<blockquote>
<p>注：2025年3月11日の時点で、一部のブラウザはまだWebGPUを完全にリリースしておらず、実装に<code class="notranslate" translate="no">'core'features-and'limits'</code>を追加していません。まもなく更新されるはずです。</p>
</blockquote>
<h1 id="互換モードのテスト">互換モードのテスト</h1>
<p>互換モードをサポートするブラウザでは、（冒頭で行ったように）<code class="notranslate" translate="no">'core-features-and-limits'</code>を要求せずに、アプリケーションが制限に従っていることをテストできます。制限と制約が適用されていることを確認できるように、実際に互換デバイスがあることを確認することをお勧めします。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const device = await adapter.requestDevice();

const isCompatibilityMode = !device.features.has('core-features-and-limits');
</pre>
<p>これは、アプリがこれらの古いデバイスで実行されるかどうかをテストする良い方法です。</p>
<blockquote>
<p>注：2025年3月11日の時点で、一部のブラウザはまだWebGPUを完全にリリースしておらず、実装に<code class="notranslate" translate="no">'core'features-and'limits'</code>を追加していません。まもなく更新されるはずです。</p>
</blockquote>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-compatibility-mode.html">English
    </option><option value="/webgpu/lessons/es/webgpu-compatibility-mode.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compatibility-mode.html" selected="">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compatibility-mode.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compatibility-mode.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compatibility-mode.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compatibility-mode.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-fundamentals.html">基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">inter-stage変数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-uniforms.html">ユニフォーム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-buffers.html">ストレージバッファ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-vertex-buffers.html">頂点バッファ</a></li>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-textures.html">テクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-importing-textures.html">画像の読み込み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-textures-external-video.html">ビデオの使用</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cube-maps.html">キューブマップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-storage-textures.html">ストレージテクスチャ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multisampling.html">マルチサンプリング / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ja/webgpu-constants.html">定数</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-memory-layout.html">構造体とメモリレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-transparency.html">透明度とブレンディング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">バインドグループレイアウト</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-copying-data.html">データのコピー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-limits-and-features.html">オプション機能と制限</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-timing.html">タイミングパフォーマンス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-how-it-works.html">仕組み</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compatibility-mode.html">互換モード</a></li>
        </ul>
  <li>3Dの数学</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-translation.html">平行移動</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-rotation.html">回転</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scale.html">スケール</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-math.html">行列演算</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-orthographic-projection.html">正射影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-perspective-projection.html">透視投影</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-cameras.html">カメラ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-matrix-stacks.html">行列スタック</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-scene-graphs.html">シーングラフ</a></li>
        </ul>
  <li>ライト</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-lighting-directional.html">指向性ライティング</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-point.html">点光源</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-lighting-spot.html">スポットライト</a></li>
        </ul>
  <li>テクニック</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-large-triangle-to-cover-clip-space.html">大きなクリップ空間の三角形</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-environment-maps.html">環境マップ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-skybox.html">スカイボックス</a></li>
        </ul>
  <li>ポストプロセッシング</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-post-processing.html">基本的なCRTエフェクト</a></li>
        </ul>
        </ul>
  <li>コンピュートシェーダ</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-compute-shaders.html">コンピュートシェーダーの基本</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram.html">画像ヒストグラム</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-compute-shaders-histogram-part-2.html">画像ヒストグラム パート2</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-multiple-canvases.html">複数のキャンバス</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-points.html">ポイント</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-from-webgl.html">WebGLからWebGPUへ</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-optimization.html">速度と最適化</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-debugging.html">デバッグとエラー</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-resources.html">リソース / 参考文献</a></li>
<li><a href="/webgpu/lessons/ja/webgpu-wgsl-function-reference.html">WGSL 関数リファレンス</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL オフセット計算機</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/webgpu/webgpufundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 互換モード`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>