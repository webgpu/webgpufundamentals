<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-compute-shaders.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPU에서 컴퓨트 셰이더를 사용하는 방법에 대해 알아봅시다.">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_ko.jpg">

<meta property="og:title" content="WebGPU 컴퓨트 셰이더 기초">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_ko.jpg">
<meta property="og:description" content="WebGPU에서 컴퓨트 셰이더를 사용하는 방법에 대해 알아봅시다.">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 컴퓨트 셰이더 기초">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html">
<meta name="twitter:description" content="WebGPU에서 컴퓨트 셰이더를 사용하는 방법에 대해 알아봅시다.">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html",
      "inLanguage":"ko",
      "name":"WebGPU 컴퓨트 셰이더 기초",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-compute-shaders.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 컴퓨트 셰이더 기초</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-compute-shaders.html">English
    </option><option value="/webgpu/lessons/es/webgpu-compute-shaders.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compute-shaders.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compute-shaders.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compute-shaders.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-compute-shaders.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compute-shaders.html">简体中文
</option></select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 컴퓨트 셰이더 기초</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 문서는 <a href="webgpu-fundamentals.html">WebGPU 기초</a> 문서에서부터 이어집니다.
저희는 컴퓨트 셰이더의 기초를 배우고, 실제 문제를 해결하는 예제를 살펴볼 것입니다.</p>
<p>이전 문서에서 숫자를 두배로 늘려주는 아주 간단한 컴퓨트 셰이더를 만들어봤습니다.</p>
<p>아래가 바로 그 내용이었죠.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

@compute @workgroup_size(1) fn computeSomething(
  @builtin(global_invocation_id) id: vec3&lt;u32&gt;
) {
  let i = id.x;
  data[i] = data[i] * 2.0;
}
</pre>
<p>그런 다음 이 컴퓨트 셰이더를 다음과 같이 효율적으로 실행했습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  ...
  pass.dispatchWorkgroups(count);
</pre>
<p>이 작업 그룹(workgroup)의 정의에 대해 살펴볼 필요가 있습니다.</p>
<p>하나의 작업 그룹을 스레드의 작은 묶음으로 생각하셔도 좋습니다.
각 스레드는 병렬로 실행됩니다. 작업 그룹의 크기는 WGSL에서 정적으로 정의해야 합니다.
작업 그룹의 크기는 3차원으로 정의되지만, 기본값은 1입니다.
따라서 <code class="notranslate" translate="no">@workgroup_size(1)</code>은 <code class="notranslate" translate="no">@workgroup_size(1, 1, 1)</code>과 동일합니다.</p>
<p><a id="a-local-invocation-id"></a>만약 작업 그룹을 <code class="notranslate" translate="no">@workgroup_size(3, 4, 2)</code>로 정의한다면, 이는 총 3 * 4 * 2개의 스레드를 정의하는 것으로, 다르게 말하자면 24개의 스레드로 구성된 작업 그룹을 정의하는 것입니다.</p>
<div class="webgpu_center">
  <img src="../resources/gpu-workgroup.svg" style="width: 500px;">
  <div>작업 그룹 내 각 스레드의 <code class="notranslate" translate="no">local_invocation_id</code></div>
</div>
<p><a id="a-workgroup-id"></a>만약 저희가 <code class="notranslate" translate="no">pass.dispatchWorkgroups(4, 3, 2)</code>를 호출한다면, 24개의 스레드를 가진 한 작업 그룹을 총 4 * 3 * 2번 (24번), 총 576개의 스레드로 실행합니다.</p>
<div class="webgpu_center">
  <img src="../resources/gpu-workgroup-dispatch.svg" style="width: 500px;">
  <div>디스패치된 작업 그룹의 <code class="notranslate" translate="no">workgroup_id</code></div>
</div>
<p>저희가 만든 컴퓨트 셰이더의 각 "실행(invocation)"에서는 다음과 같은 빌트인 변수들을 사용할 수 있습니다.</p>
<ul>
<li>
<p><code class="notranslate" translate="no">local_invocation_id</code>: 작업 그룹 내 스레드의 고유한 ID입니다.</p>
<p><a href="#a-local-invocation-id">위의 다이어그램을 다시 살펴보세요</a>.</p>
</li>
<li>
<p><code class="notranslate" translate="no">workgroup_id</code>: 작업 그룹의 고유한 ID입니다.</p>
<p>한 작업 그룹의 모든 스레드는 동일한 작업 그룹 ID를 갖게됩니다.</p>
<p><a href="#a-workgroup-id">위의 다이어그램을 다시 살펴보세요</a>.</p>
</li>
<li>
<p><code class="notranslate" translate="no">global_invocation_id</code>: 각 스레드의 고유한 ID입니다.</p>
<p>이는 다음과 같이 생각할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">global_invocation_id = workgroup_id * workgroup_size + local_invocation_id
</pre>
</li>
<li>
<p><code class="notranslate" translate="no">num_workgroups</code>: <code class="notranslate" translate="no">pass.dispatchWorkgroups</code>로 전달하는 값입니다.</p>
</li>
<li>
<p><code class="notranslate" translate="no">local_invocation_index</code>: 스레드의 선형화된(linearized) ID입니다.</p>
<p>이는 다음과 같이 생각할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">rowSize = workgroup_size.x
sliceSize = rowWidth * workgroup_size.y
local_invocation_index =
      local_invocation_id.x +
      local_invocation_id.y * rowSize +
      local_invocation_id.z * sliceSize
</pre>
</li>
</ul>
<p>이 값들을 사용하는 예시를 하나 만들어봅시다. 각 호출마다 버퍼에 값을 쓰고, 그 값을 출력해보겠습니다.</p>
<p>아래는 작성한 셰이더입니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const dispatchCount = [4, 3, 2];
const workgroupSize = [2, 3, 4];

// 배열 내 모든 요소들을 곱합니다.
const arrayProd = arr =&gt; arr.reduce((a, b) =&gt; a * b);

const numThreadsPerWorkgroup = arrayProd(workgroupSize);

const code = `
// NOTE!: vec3u은 4바이트씩 패딩됩니다.
@group(0) @binding(0) var&lt;storage, read_write&gt; workgroupResult: array&lt;vec3u&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; localResult: array&lt;vec3u&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; globalResult: array&lt;vec3u&gt;;

@compute @workgroup_size(${workgroupSize}) fn computeSomething(
    @builtin(workgroup_id) workgroup_id : vec3&lt;u32&gt;,
    @builtin(local_invocation_id) local_invocation_id : vec3&lt;u32&gt;,
    @builtin(global_invocation_id) global_invocation_id : vec3&lt;u32&gt;,
    @builtin(local_invocation_index) local_invocation_index: u32,
    @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;
) {
  // workgroup_index는 local_invocation_index와 비슷하지만,
  // 작업 그룹 내 스레드가 아닌, 작업 그룹을 대상으로 하는 인덱스라는 점이 다릅니다.
  // 이는 빌트인 변수로 존재하지 않기 때문에, 직접 계산합니다.

  let workgroup_index =  
     workgroup_id.x +
     workgroup_id.y * num_workgroups.x +
     workgroup_id.z * num_workgroups.x * num_workgroups.y;

  // global_invocation_index는 local_invocation_index와 비슷하지만,
  // 디스패치된 모든 작업 그룹의 모든 호출에 걸쳐 선형적이라는 점이 다릅니다.
  // 이는 빌트인 변수로 존재하지 않기 때문에, 직접 계산합니다.

  let global_invocation_index =
     workgroup_index * ${numThreadsPerWorkgroup} +
     local_invocation_index;

  // 이제 버퍼에 각 빌트인 변수들을 쓸 수 있습니다.
  workgroupResult[global_invocation_index] = workgroup_id;
  localResult[global_invocation_index] = local_invocation_id;
  globalResult[global_invocation_index] = global_invocation_id;
`;
</pre>
<p>여기서는 JavaScript의 템플릿 리터럴을 사용하여 <code class="notranslate" translate="no">workgroupSize</code> 변수를 통해 작업 그룹의 크기를 설정했습니다.
이는 결국 셰이더에 하드코딩됩니다.</p>
<p>이제 셰이더가 생겼으니, 그 결과를 저장할 3개의 버퍼를 만들 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const numWorkgroups = arrayProd(dispatchCount);
  const numResults = numWorkgroups * numThreadsPerWorkgroup;
  const size = numResults * 4 * 4;  // vec3f * u32

  let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC;
  const workgroupBuffer = device.createBuffer({size, usage});
  const localBuffer = device.createBuffer({size, usage});
  const globalBuffer = device.createBuffer({size, usage});
</pre>
<p>이전에 언급했듯이, 스토리지 버퍼를 곧장 JavaScript로 매핑할 수는 없기 때문에, 이를 매핑해 줄 버퍼가 추가로 필요합니다.
스토리지 버퍼에서의 결과를 복사하여 매핑이 가능한 결과 버퍼에 저장한 다음, 그 결과를 읽어와야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  usage = GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST;
  const workgroupReadBuffer = device.createBuffer({size, usage});
  const localReadBuffer = device.createBuffer({size, usage});
  const globalReadBuffer = device.createBuffer({size, usage});
</pre>
<p>이제 바인드그룹을 만들어 스토리지 버퍼들을 모두 바인드합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: workgroupBuffer }},
      { binding: 1, resource: { buffer: localBuffer }},
      { binding: 2, resource: { buffer: globalBuffer }},
    ],
  });
</pre>
<p>이전 예제와 동일하게, 인코더와 컴퓨트 패스 인코더를 실행한 다음 명령을 추가하여 컴퓨트 셰이더를 실행합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 계산을 수행하기 위한 명령을 인코딩합니다.
  const encoder = device.createCommandEncoder({ label: 'compute builtin encoder' });
  const pass = encoder.beginComputePass({ label: 'compute builtin pass' });

  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(...dispatchCount);
  pass.end();
</pre>
<p>스토리지 버퍼로부터 매핑 가능한 결과 버퍼에 이를 복사합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  encoder.copyBufferToBuffer(workgroupBuffer, 0, workgroupReadBuffer, 0, size);
  encoder.copyBufferToBuffer(localBuffer, 0, localReadBuffer, 0, size);
  encoder.copyBufferToBuffer(globalBuffer, 0, globalReadBuffer, 0, size);
</pre>
<p>그런 다음 인코더를 종료하고 명령 버퍼를 제출합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 인코딩을 완료하고 명령을 제출합니다.
  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);
</pre>
<p>이전과 마찬가지로, 결과를 읽기 위해서는 버퍼를 매핑하고 준비가 되면 해당 내용의 typed array 뷰를 가져옵니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 결과를 읽어옵니다.
   await Promise.all([
    workgroupReadBuffer.mapAsync(GPUMapMode.READ),
    localReadBuffer.mapAsync(GPUMapMode.READ),
    globalReadBuffer.mapAsync(GPUMapMode.READ),
  ]);

  const workgroup = new Uint32Array(workgroupReadBuffer.getMappedRange());
  const local = new Uint32Array(localReadBuffer.getMappedRange());
  const global = new Uint32Array(globalReadBuffer.getMappedRange());
</pre>
<blockquote>
<p>중요: 여기서 3개의 버퍼를 매핑하고, <code class="notranslate" translate="no">await Promise.all</code>을 사용하여 모든 버퍼가 사용 가능할 때까지 기다립니다.
마지막 버퍼만 기다리는 것은 <em>불가능</em>합니다. 반드시 모든 3개의 버퍼를 기다려야 합니다.</p>
</blockquote>
<p>마침내 결과를 출력할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const get3 = (arr, i) =&gt; {
    const off = i * 4;
    return `${arr[off]}, ${arr[off + 1]}, ${arr[off + 2]}`;
  };

  for (let i = 0; i &lt; numResults; ++i) {
    if (i % numThreadsPerWorkgroup === 0) {
      log(`\
 ---------------------------------------
 global                 local     global   dispatch: ${i / numThreadsPerWorkgroup}
 invoc.    workgroup    invoc.    invoc.
 index     id           id        id
 ---------------------------------------`);
    }
    log(` ${i.toString().padStart(3)}:      ${get3(workgroup, i)}      ${get3(local, i)}   ${get3(global, i)}`)
  }
}

function log(...args) {
  const elem = document.createElement('pre');
  elem.textContent = args.join(' ');
  document.body.appendChild(elem);
}
</pre>
<p>아래는 그 결과입니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-compute-shaders-builtins.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-compute-shaders-builtins.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>이 빌트인 변수들은 일반적으로 <code class="notranslate" translate="no">pass.dispatchWorkgroups</code>의 호출마다 컴퓨트 셰이더의 각 스레드에 대해 변경되는 유일한 입력값입니다.
따라서 주어지는 <code class="notranslate" translate="no">...id</code> 빌트인들을 입력값으로 사용하여 원하는 작업을 수행하는 컴퓨트 셰이더 함수를 설계하는 방법을 파악해야 합니다.</p>
<h2 id="작업-그룹의-크기">작업 그룹의 크기</h2>
<p>작업 그룹의 크기는 어떻게 정해야 할까요? 이는 종종 나오는 질문입니다.
그냥 항상 <code class="notranslate" translate="no">@workgroup_size(1, 1, 1)</code>을 사용하고, <code class="notranslate" translate="no">pass.dispatchWorkgroups</code>의 매개변수들만으로 실행할 반복 횟수를 결정하면 더 쉽지 않을까요?</p>
<p>그 이유는 한 작업 그룹 내 여러 개의 스레드가 개별적인 디스패치보다 빠르기 때문입니다.</p>
<p>우선, 작업 그룹의 스레드는 종종 락스텝(lockstep)으로 실행되기 때문에, 여기서 16개의 스레드를 실행하는 것은 1개의 스레드를 실행하는 것과 동일한 속도로 실행됩니다.</p>
<p>WebGPU의 기본 제한은 다음과 같습니다.</p>
<ul>
<li><code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code>: 256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeX</code>: 256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeY</code>:	256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeZ</code>:	64</li>
</ul>
<p>위에서 확인할 수 있듯, 가장 앞의 <code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code>는 <code class="notranslate" translate="no">@workgroup_size</code>의 3개 매개변수의 곱이 256보다 큰 수가 될 수 없다는 것을 의미합니다.</p>
<p>이는 다시 말해, 다음과 같습니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">   @workgroup_size(256, 1, 1)   // ok
   @workgroup_size(128, 2, 1)   // ok
   @workgroup_size(16, 16, 1)   // ok
   @workgroup_size(16, 16, 2)   // bad 16 * 16 * 2 = 512
</pre>
<p>안타깝게도, "완벽한 크기"는 GPU에 따라 다르며, WebGPU는 이를 제공할 수 없습니다.
다른 크기를 선택해야 하는 특별한 이유가 없는 한, <strong>WebGPU는 일반적으로 작업 그룹 크기를 64로 선택할 것을 권장</strong>합니다.
대부분의 GPU는 64개의 작업을 락스텝으로 효율적으로 실행할 수 있습니다.
더 높은 숫자를 선택했지만 GPU가 빠른 경로로 이를 처리할 수 없다면, 느린 경로를 선택하게 됩니다.
반면, GPU가 처리할 수 있는 숫자보다 낮은 숫자를 선택하면 최대 성능을 얻을 수 없습니다.</p>
<h2 id="컴퓨트-셰이더에서의-경쟁race">컴퓨트 셰이더에서의 경쟁(Race)</h2>
<p>WebGPU에서 흔히 발생하는 실수는 경쟁 상태(race condition)를 처리하지 않는 것입니다.
경쟁 상태란 여러 스레드가 동시에 실행되는 상황에서 사실상 어느 쪽이 먼저 또는 마지막으로 끝날지 경쟁하는 상황입니다.</p>
<p>아래와 같은 컴퓨트 셰이더가 있다고 해봅시다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; result: array&lt;f32&gt;;

@compute @workgroup_size(32) fn computeSomething(
    @builtin(local_invocation_id) local_invocation_id : vec3&lt;u32&gt;,
) {
  result[0] = local_invocation_id.x;
`;
</pre>
<p>이것이 읽기 어렵다면, 다음의 JavaScript 코드와 비슷합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const result = [];
for (let i = 0; i &lt; 32; ++i) {
  result[0] = i;
}
</pre>
<p>JavaScript의 경우, 코드가 전부 실행되면 <code class="notranslate" translate="no">result[0]</code>은 분명히 31입니다.
하지만 컴퓨트 셰이더의 경우 셰이더의 32개의 반복이 모두 병렬로 실행됩니다.
가장 마지막에 완료되는 것이 곧 <code class="notranslate" translate="no">result[0]</code>의 값이 됩니다.
어떤 것이 마지막으로 실행되는지는 정의되어 있지 않습니다.</p>
<p>규격(spec)을 살펴보자면:</p>
<blockquote>
<p>WebGPU는 다음에 대한 보장을 제공하지 않습니다:</p>
<ul>
<li>
<p>서로 다른 작업 그룹의 호출이 동시에 실행되는지에 대한 여부를 보장하지 않습니다.
즉, 한번에 두 개 이상의 작업 그룹이 실행된다고 가정할 수 없습니다.</p>
</li>
<li>
<p>작업 그룹의 호출이 실행되기 시작하면 다른 작업 그룹의 실행이 차단되는지에 대한 여부를 보장하지 않습니다.
즉, 한 번에 하나의 작업 그룹만 실행된다고 가정할 수 없습니다.
작업 그룹이 실행되는 동안, 구현(implementation)은 다른 작업 그룹이나 대기 중인지만 차단되지 않은 다른 작업도 동시에 실행하도록 선택할 수 있습니다.</p>
</li>
<li>
<p>특정 작업 그룹의 호출이 다른 작업 그룹의 호출보다 먼저 실행되기 시작하는지의 여부를 보장하지 않습니다.
즉, 작업 그룹이 특정 순서로 실행된다고 가정할 수 없습니다.</p>
</li>
</ul>
</blockquote>
<p>추후 예제를 통해 이 문제를 처리하는 몇 가지 방법을 살펴보겠습니다.
지금까지의 두 예제들은 모두 각 컴퓨트 셰이더의 반복이 다른 반복에 영향을 받지 않는 작업을 수행하기 때문에 경쟁 상태가 발생하지 않습니다.</p>
<p>추가 예제: TBD</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-compute-shaders.html">English
    </option><option value="/webgpu/lessons/es/webgpu-compute-shaders.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compute-shaders.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compute-shaders.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compute-shaders.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-compute-shaders.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compute-shaders.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">스테이지간 변수(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">스토리지 버퍼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">정점 버퍼</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">이미지 로딩</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">비디오 사용하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">큐브맵(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">상수(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">데이터 메모리 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">데이터 복사하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">선택적 기능(optional feature)과 제한(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">동작 방식</a></li>
        </ul>
  <li>3D 수학</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>컴퓨트 셰이더</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">컴퓨트 셰이더 기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>질문이 있나요? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>에 물어보세요.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">제안</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">요청 사항</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">이슈</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">버그</a>
</div>
<div class="lesson-comment-notes">
   코드 블럭의 경우 <b>&lt;pre&gt;&lt;code&gt;</b>코드<b>&lt;/code&gt;&lt;/pre&gt;</b>을 사용하세요.
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 컴퓨트 셰이더 기초`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님<br> 당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여에 감사드립니다.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>