<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-timing.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPU에서의 타이밍 작업">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-timing_ko.jpg">

<meta property="og:title" content="WebGPU 타이밍 성능">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-timing_ko.jpg">
<meta property="og:description" content="WebGPU에서의 타이밍 작업">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 타이밍 성능">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html">
<meta name="twitter:description" content="WebGPU에서의 타이밍 작업">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-timing_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-timing_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html",
      "inLanguage":"ko",
      "name":"WebGPU 타이밍 성능",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-timing.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 타이밍 성능</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-timing.html">English
    </option><option value="/webgpu/lessons/es/webgpu-timing.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-timing.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-timing.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-timing.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-timing.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-timing.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-timing.html">简体中文
</option></select>


    <a href="#toc">목차</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 타이밍 성능</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>성능 측정을 하고 싶은 다양한 것들이 있습니다. 우리는 다음 3가지를 측정해 볼 것입니다:</p>
<ul>
<li>초당 프레임 수 (fps)</li>
<li>프레임당 JavaScript에서 소요된 시간</li>
<li>프레임당 GPU에서 소요된 시간</li>
</ul>
<p>먼저, <a href="webgpu-vertex-buffers.html">정점 버퍼에 관한 글</a>의 원 예제를 가져와서,
작업에 걸리는 시간의 변화를 쉽게 볼 수 있도록 애니메이션을 만들어 보겠습니다.</p>
<p>그 예제에는 3개의 정점 버퍼가 있었습니다. 하나는 원의 정점 위치와 밝기를 위한 것이었습니다.
또 하나는 원의 오프셋과 색상을 포함하는 것으로 인스턴스 별로 정적이었습니다.
그리고 마지막 하나는 렌더링할 때마다 변경되는 것으로, 사용자가 창 크기를 변경할 때
원의 종횡비를 유지하여 타원이 아닌 원으로 유지하기 위한 스케일이었습니다.</p>
<p>우리는 원들이 움직이도록 애니메이션을 만들고 싶으므로 오프셋을 스케일과 같은 버퍼로 옮기겠습니다.
먼저 렌더링 파이프라인을 변경하여 오프셋을 스케일과 같은 버퍼로 이동합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'per vertex color',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: 2 * 4 + 4, // 2 floats, 4 bytes each + 4 bytes
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
            {shaderLocation: 4, offset: 8, format: 'unorm8x4'},   // perVertexColor
          ],
        },
        {
-          arrayStride: 4 + 2 * 4, // 4 bytes + 2 floats, 4 bytes each
+          arrayStride: 4, // 4 bytes
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 1, offset: 0, format: 'unorm8x4'},   // color
-            {shaderLocation: 2, offset: 4, format: 'float32x2'},  // offset
          ],
        },
        {
-          arrayStride: 2 * 4, // 2 floats, 4 bytes each
+          arrayStride: 4 * 4, // 4 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
-            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
+            {shaderLocation: 2, offset: 0, format: 'float32x2'},   // offset
-            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
+            {shaderLocation: 3, offset: 8, format: 'float32x2'},   // scale
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>그런 다음 정점 버퍼를 설정하는 부분을 변경하여 오프셋을 스케일과 비슷한 코드로 만듭니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 2개의 정점 버퍼 생성
  const staticUnitSize =
-    4 +     // color is 4 bytes
-    2 * 4;  // offset is 2 32bit floats (4bytes each)
+    4;     // color is 4 bytes
  const changingUnitSize =
-    2 * 4;  // scale is 2 32bit floats (4bytes each)
+    2 * 4 + // offset is 2 32bit floats (4bytes each)
+    2 * 4;  // scale is 2 32bit floats (4bytes each)
  const staticVertexBufferSize = staticUnitSize * kNumObjects;
  const changingVertexBufferSize = changingUnitSize * kNumObjects;

  const staticVertexBuffer = device.createBuffer({
    label: 'static vertex for objects',
    size: staticVertexBufferSize,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

  const changingVertexBuffer = device.createBuffer({
    label: 'changing storage for objects',
    size: changingVertexBufferSize,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

  // float32 인덱스에서 다양한 유니폼 값에 대한 오프셋
  const kColorOffset = 0;
-  const kOffsetOffset = 1;
+
-  const kScaleOffset = 0;
+  const kOffsetOffset = 0;
+  const kScaleOffset = 2;

  {
    const staticVertexValuesU8 = new Uint8Array(staticVertexBufferSize);
-    const staticVertexValuesF32 = new Float32Array(staticVertexValuesU8.buffer);
    for (let i = 0; i &lt; kNumObjects; ++i) {
      const staticOffsetU8 = i * staticUnitSize;
-      const staticOffsetF32 = staticOffsetU8 / 4;

      // 한 번만 설정되므로 지금 설정합니다.
      staticVertexValuesU8.set(        // set the color
          [rand() * 255, rand() * 255, rand() * 255, 255],
          staticOffsetU8 + kColorOffset);

-      staticVertexValuesF32.set(      // set the offset
-          [rand(-0.9, 0.9), rand(-0.9, 0.9)],
-          staticOffsetF32 + kOffsetOffset);

      objectInfos.push({
        scale: rand(0.2, 0.5),
+        offset: [rand(-0.9, 0.9), rand(-0.9, 0.9)],
+        velocity: [rand(-0.1, 0.1), rand(-0.1, 0.1)],
      });
    }
-    device.queue.writeBuffer(staticVertexBuffer, 0, staticVertexValuesF32);
+    device.queue.writeBuffer(staticVertexBuffer, 0, staticVertexValuesU8);
  }
</pre>
<p>렌더링 시에는 속도에 따라 원의 오프셋을 업데이트한 다음 GPU에 업로드할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const euclideanModulo = (x, a) =&gt; x - a * Math.floor(x / a);

+  let then = 0;
-  function render() {
  function render(now) {
+    now *= 0.001;  // 초 단위로 변환
+    const deltaTime = now - then;
+    then = now;

...
      // 각 객체의 스케일 설정
-    objectInfos.forEach(({scale}, ndx) =&gt; {
-      const offset = ndx * (changingUnitSize / 4);
-      vertexValues.set([scale / aspect, scale], offset + kScaleOffset); // set the scale
+    objectInfos.forEach(({scale, offset, veloctiy}, ndx) =&gt; {
+      // -1.5 에서 1.5 까지
+      offset[0] = euclideanModulo(offset[0] + velocity[0] * deltaTime + 1.5, 3) - 1.5;
+      offset[1] = euclideanModulo(offset[1] + velocity[1] * deltaTime + 1.5, 3) - 1.5;

+      const off = ndx * (changingUnitSize / 4);
+      vertexValues.set(offset, off + kOffsetOffset);
      vertexValues.set([scale / aspect, scale], off + kScaleOffset);
    });

...

+    requestAnimationFrame(render);
  }
+  requestAnimationFrame(render);

  const observer = new ResizeObserver(entries =&gt; {
    for (const entry of entries) {
      const canvas = entry.target;
      const width = entry.contentBoxSize[0].inlineSize;
      const height = entry.contentBoxSize[0].blockSize;
      canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
      canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
-      // 다시 그리기
-      render();
    }
  });
  observer.observe(canvas);
</pre>
<p>또한 rAF 루프<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>로 전환했습니다.</p>
<p><a id="a-euclidianModulo"></a>위의 코드는 오프셋을 업데이트하기 위해 <code class="notranslate" translate="no">euclideanModulo</code>를 사용합니다.
<code class="notranslate" translate="no">euclideanModulo</code>는 나머지로 항상 양수를 반환합니다. 한편, <code class="notranslate" translate="no">%</code> 연산자는 입력값과 같은 부호의 나머지를 반환합니다.
예를 들어</p>
<div class="webgpu_center">
  <div class="center">
    <div class="data-table center" data-table="{
  &quot;cols&quot;: [&quot;value&quot;, &quot;% operator&quot;, &quot;euclideanModulo&quot;],
  &quot;classNames&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],
  &quot;rows&quot;: [
    [ &quot;0.3&quot;, &quot;0.3&quot;, &quot;0.3&quot; ],
    [ &quot;2.3&quot;, &quot;0.3&quot;, &quot;0.3&quot; ],
    [ &quot;4.3&quot;, &quot;0.3&quot;, &quot;0.3&quot; ],
    [ &quot;-1.7&quot;, &quot;-1.7&quot;, &quot;0.3&quot; ],
    [ &quot;-3.7&quot;, &quot;-1.7&quot;, &quot;0.3&quot; ]
  ]
}">
     </div>
  </div>
  <div>modulo 2 of % vs euclideanModulo</div>
</div>
<p>다르게 말하면, 다음은 <code class="notranslate" translate="no">%</code> 연산자 대 <code class="notranslate" translate="no">euclideanModulo</code>의 그래프입니다.</p>
<div class="webgpu_center">
  <img style="width: 700px" src="../resources/euclidean-modulo.svg">
  <div>euclideanModule(v, 2)</div>
</div>
<div class="webgpu_center">
  <img style="width: 700px" src="../resources/modulo.svg">
  <div>v % 2</div>
</div>
<p>따라서 위의 코드는 클립 공간에 있는 오프셋을 가져와 1.5를 더합니다. 그런 다음 3으로 <code class="notranslate" translate="no">euclideanModulo</code>를 취하면 0.0에서 3.0 사이의 숫자가 나오고, 여기서 1.5를 뺍니다. 이렇게 하면 -1.5에서 +1.5 사이의 숫자가 유지되고 반대쪽으로 래핑됩니다. 원들이 화면을 벗어날 때까지 래핑되지 않도록 -1.5에서 +1.5를 사용합니다. <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>원을 몇개나 그릴지 조정할 수 있도록 해보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const kNumObjects = 100;
+  const kNumObjects = 10000;


...

  const settings = {
    numObjects: 100,
  };

  const gui = new GUI();
  gui.add(settings, 'numObjects', 0, kNumObjects, 1);

  ...

    // 각 객체의 스케일과 오프셋 설정
-    objectInfos.forEach(({scale, offset, veloctiy}, ndx) =&gt; {
+    for (let ndx = 0; ndx &lt; settings.numObjects; ++ndx) {
+      const {scale, offset, velocity} = objectInfos[ndx];

      // -1.5 에서 1.5
      offset[0] = euclideanModulo(offset[0] + velocity[0] * deltaTime + 1.5, 3) - 1.5;
      offset[1] = euclideanModulo(offset[1] + velocity[1] * deltaTime + 1.5, 3) - 1.5;

      const off = ndx * (changingUnitSize / 4);
      vertexValues.set(offset, off + kOffsetOffset);
      vertexValues.set([scale / aspect, scale], off + kScaleOffset);
-    });
+    }

    // 모든 오프셋과 스케일을 한 번에 업로드
-    device.queue.writeBuffer(changingVertexBuffer, 0, vertexValues);
+    device.queue.writeBuffer(
        changingVertexBuffer, 0,
        vertexValues, 0, settings.numObjects * changingUnitSize / 4);

-    pass.draw(numVertices, kNumObjects);
+    pass.draw(numVertices, settings.numObjects);
</pre>
<p>이제 애니메이션이 되는 무언가가 생겼고, 원의 수를 설정하여 얼마나 많은 작업이 수행되는지 조정할 수 있습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-timing-animated.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-timing-animated.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>여기에 초당 프레임 수(fps)와 JavaScript에서 소요된 시간을 추가해 보겠습니다.</p>
<p>먼저 이 정보를 표시할 방법이 필요하므로 캔버스 위에 위치한 <code class="notranslate" translate="no">&lt;pre&gt;</code> 요소를 추가해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">  &lt;body&gt;
    &lt;canvas&gt;&lt;/canvas&gt;
+    &lt;pre id="info"&gt;&lt;/pre&gt;
  &lt;/body&gt;
</pre>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">html, body {
  margin: 0;       /* remove the default margin          */
  height: 100%;    /* make the html,body fill the page   */
}
canvas {
  display: block;  /* make the canvas act like a block   */
  width: 100%;     /* make the canvas fill its container */
  height: 100%;
}
+#info {
+  position: absolute;
+  top: 0;
+  left: 0;
+  margin: 0;
+  padding: 0.5em;
+  background-color: rgba(0, 0, 0, 0.8);
+  color: white;
+}
</pre>
<p>우리는 이미 초당 프레임 수를 표시하는 데 필요한 데이터를 가지고 있습니다. 위에서 계산한 <code class="notranslate" translate="no">deltaTime</code>입니다.</p>
<p>JavaScript 시간의 경우 <code class="notranslate" translate="no">requestAnimationFrame</code>이 시작된 시간과 종료된 시간을 기록할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  let then = 0;
  function render(now) {
    now *= 0.001;  // 초 단위로 변환
    const deltaTime = now - then;
    then = now;

+    const startTime = performance.now();

    ...

+    const jsTime = performance.now() - startTime;

+    infoElem.textContent = `\
+fps: ${(1 / deltaTime).toFixed(1)}
+js: ${jsTime.toFixed(1)}ms
+`;

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>이렇게 하면 처음 두 가지 시간 측정치를 얻을 수 있습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-timing-with-fps-js-time.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-timing-with-fps-js-time.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<h2 id="gpu-시간-측정"><a id="a-timestamp-query"></a> GPU 시간 측정</h2>
<p>WebGPU는 GPU에서 작업이 얼마나 걸리는지 확인하기 위한 <strong>선택적</strong> <code class="notranslate" translate="no">'timestamp-query'</code> 기능을 제공합니다.
선택적 기능이므로 <a href="webgpu-limits-and-features.html">제한 및 기능에 관한 글</a>에서 다룬 것처럼 존재하는지 확인하고 요청해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
-  const device = await adapter?.requestDevice();
+  const canTimestamp = adapter.features.has('timestamp-query');
+  const device = await adapter?.requestDevice({
+    requiredFeatures: [
+      ...(canTimestamp ? ['timestamp-query'] : []),
+     ],
+  });
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }
</pre>
<p>위에서 어댑터가 <code class="notranslate" translate="no">'timestamp-query'</code> 기능을 지원하는지에 따라 <code class="notranslate" translate="no">canTimestamp</code>를 true 또는 false로 설정했습니다. 지원한다면 장치를 생성할 때 해당 기능을 요구합니다.</p>
<p>기능이 활성화되면 렌더 패스나 컴퓨트 패스에 대해 WebGPU에 <em>타임스탬프</em>를 요청할 수 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>을 만들고 컴퓨트 또는 렌더 패스에 추가하여 이를 수행합니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>은 사실상 쿼리 결과의 배열입니다. WebGPU에 배열의 어느 요소에 패스가 시작된 시간을 기록할지, 어느 요소에 패스가 끝난 시간을 기록할지 알려줍니다. 그런 다음 해당 타임스탬프를 버퍼에 복사하고 버퍼를 매핑하여 결과를 읽을 수 있습니다.<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>먼저 쿼리 세트를 생성합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const querySet = device.createQuerySet({
     type: 'timestamp',
     count: 2,
  });
</pre>
<p>시작 및 종료 타임스탬프를 모두 쓸 수 있도록 count는 최소 2여야 합니다.</p>
<p>querySet 정보를 액세스할 수 있는 데이터로 변환하기 위한 버퍼가 필요합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const resolveBuffer = device.createBuffer({
    size: querySet.count * 8,
    usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
  });
</pre>
<p>querySet의 각 요소는 8바이트를 차지합니다.
<code class="notranslate" translate="no">QUERY_RESOLVE</code> 플래그를 지정해야 하며, 결과를 JavaScript에서 다시 읽으려면 결과를 매핑 가능한 버퍼로 복사할 수 있도록 <code class="notranslate" translate="no">COPY_SRC</code> 플래그가 필요합니다.</p>
<p>마지막으로 결과를 읽기 위한 매핑 가능한 버퍼를 생성합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const resultBuffer = device.createBuffer({
    size: resolveBuffer.size,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });
</pre>
<p>기능이 존재하는 경우에만 이러한 것들을 생성하도록 코드를 감싸야 합니다. 그렇지 않으면 <code class="notranslate" translate="no">'timestamp'</code> querySet을 만들려고 할 때 오류가 발생합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const { querySet, resolveBuffer, resultBuffer } = (() =&gt; {
+    if (!canTimestamp) {
+      return {};
+    }

    const querySet = device.createQuerySet({
       type: 'timestamp',
       count: 2,
    });
    const resolveBuffer = device.createBuffer({
      size: querySet.count * 8,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
    });
    const resultBuffer = device.createBuffer({
      size: resolveBuffer.size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
+    return {querySet, resolveBuffer, resultBuffer };
+  })();
</pre>
<p>사용할 querySet과 시작 및 종료 타임스탬프를 쓸 querySet의 요소 인덱스를 렌더 패스 디스크립터에 지정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass with timing',
    colorAttachments: [
      {
        // view: &lt;- 렌더링할 때 채워짐
        clearValue: [0.3, 0.3, 0.3, 1],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    ...(canTimestamp &amp;&amp; {
      timestampWrites: {
        querySet,
        beginningOfPassWriteIndex: 0,
        endOfPassWriteIndex: 1,
      },
    }),
  };
</pre>
<p>위에서 기능이 존재하면 renderPassDescriptor에 <code class="notranslate" translate="no">timestampWrites</code> 섹션을 추가하고
querySet을 전달한 다음 시작을 세트의 요소 0에, 종료를 요소 1에 쓰도록 지시합니다.</p>
<p>패스를 종료한 후 <code class="notranslate" translate="no">resolveQuerySet</code>을 호출해야 합니다. 이것은 쿼리 결과를 가져와 버퍼에 넣습니다.
querySet, 해결을 시작할 쿼리 세트의 첫 번째 인덱스, 해결할 항목 수, 해결할 버퍼, 결과를 저장할 버퍼의
오프셋을 전달합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.end();

+    if (canTimestamp) {
+      encoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);
+    }
</pre>
<p>또한 <code class="notranslate" translate="no">resolveBuffer</code>를 <code class="notranslate" translate="no">resultsBuffer</code>로 복사하여 매핑하고 JavaScript에서 결과를 볼 수 있도록 하고 싶습니다. 하지만 문제가 있습니다. <code class="notranslate" translate="no">resultsBuffer</code>가 매핑된 동안에는 거기로 복사할 수 없습니다. 다행히 버퍼에는 매핑 상태를 확인할 수 있는 <code class="notranslate" translate="no">mapState</code> 속성이 있습니다. 시작 값인 <code class="notranslate" translate="no">unmapped</code>로 설정되어 있으면 안전하게 복사할 수 있습니다. 다른 값으로는 <code class="notranslate" translate="no">mapAsync</code>를 호출하는 순간의 값인 <code class="notranslate" translate="no">'pending'</code>과 <code class="notranslate" translate="no">mapAsync</code>가 해결된 이후의 값인 <code class="notranslate" translate="no">'mapped'</code>가 있습니다. <code class="notranslate" translate="no">unmap</code>한 후에는 다시 <code class="notranslate" translate="no">'unmapped'</code>로 돌아갑니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    if (canTimestamp) {
      encoder.resolveQuerySet(querySet, 0, 2, resolveBuffer, 0);
+      if (resultBuffer.mapState === 'unmapped') {
+        encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
+      }
    }
</pre>
<p>커맨드 버퍼를 제출한 후 <code class="notranslate" translate="no">resultBuffer</code>를 매핑할 수 있습니다. 위와 마찬가지로 <code class="notranslate" translate="no">'unmapped'</code>일 때만 매핑하고 싶습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let gpuTime = 0;

   ...

   function render(now) {

    ...

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

+    if (canTimestamp &amp;&amp; resultBuffer.mapState === 'unmapped') {
+      resultBuffer.mapAsync(GPUMapMode.READ).then(() =&gt; {
+        const times = new BigUint64Array(resultBuffer.getMappedRange());
+        gpuTime = Number(times[1] - times[0]);
+        resultBuffer.unmap();
+      });
+    }
</pre>
<p>쿼리 세트 결과는 나노초 단위이며 64비트 정수로 저장됩니다. JavaScript에서 읽으려면
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array"><code class="notranslate" translate="no">BigUint64Array</code></a> 타입 배열 뷰를 사용할 수 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array"><code class="notranslate" translate="no">BigUint64Array</code></a>를 사용하려면
특별한 주의가 필요합니다. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array"><code class="notranslate" translate="no">BigUint64Array</code></a>에서 요소를 읽을 때 타입은 <code class="notranslate" translate="no">number</code>가 아니라 <code class="notranslate" translate="no">bigint</code>이므로
많은 수학 함수를 사용할 수 없습니다. 또한 숫자로 변환할 때 <code class="notranslate" translate="no">number</code>는 53비트 크기의 정수만 정확히
저장할 수 있므로 정밀도가 손실될 수 있습니다. 따라서 먼저 2개의 <code class="notranslate" translate="no">bigint</code>를 뺄셈하여 <code class="notranslate" translate="no">bigint</code> 값을 얻습니다.
그런 다음 그 값을 <code class="notranslate" translate="no">number</code>로 변환하면 정상적으로 사용할 수 있습니다.</p>
<p>위의 코드에서는 매핑되지 않았을 때만 <code class="notranslate" translate="no">resultBuffer</code>에 결과를 복사하고 있습니다.
즉, 일부 프레임에서만 시간을 읽게 됩니다. 아마도 두 프레임마다 한번씩이 되겠지만,
<code class="notranslate" translate="no">mapAsync</code>가 해결될 때까지 얼마나 걸릴지에 대한 엄격한 보장은 없습니다.
그래서, <code class="notranslate" translate="no">gpuTime</code> 변수에 업데이트된 값을 기록해두고, 아무때나 최근 값을 읽기로 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    infoElem.textContent = `\
fps: ${(1 / deltaTime).toFixed(1)}
js: ${jsTime.toFixed(1)}ms
gpu: ${canTimestamp ? `${(gpuTime / 1000).toFixed(1)}µs` : 'N/A'}
`;
</pre>
<p>그리고 이것으로 WebGPU에서 GPU 시간을 얻습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-timing-with-timestamp.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-timing-with-timestamp.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>화면에 표시되는 숫자가 너무 자주 바뀌어서 읽기 어렵습니다. 이를 해결하는 한 가지 방법은
롤링 평균을 계산하는 것입니다. 다음은 롤링 평균을 계산하는 데 도움이 되는 클래스입니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// 참고: 쿼리가 종료 시간보다 큰 시작 시간을 반환할 수 있는 타임스탬프 쿼리에 사용됩니다.
// 그런 경우 값이 음수가 될수 있지만, 음수 값은 무시합니다.
// 참조: https://gpuweb.github.io/gpuweb/#timestamp
class NonNegativeRollingAverage {
  #total = 0;
  #samples = [];
  #cursor = 0;
  #numSamples;
  constructor(numSamples = 30) {
    this.#numSamples = numSamples;
  }
  addSample(v) {
    if (!Number.isNaN(v) &amp;&amp; Number.isFinite(v) &amp;&amp; v &gt;= 0) {
      this.#total += v - (this.#samples[this.#cursor] || 0);
      this.#samples[this.#cursor] = v;
      this.#cursor = (this.#cursor + 1) % this.#numSamples;
    }
  }
  get() {
    return this.#total / this.#samples.length;
  }
}
</pre>
<p>값의 배열과 합계를 유지합니다. 새 값이 추가되면 새 값을 배열에 추가하고 가장 오래된 값을 합계에서 뺍니다.</p>
<p>다음과 같이 사용할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const fpsAverage = new NonNegativeRollingAverage();
+const jsAverage = new NonNegativeRollingAverage();
+const gpuAverage = new NonNegativeRollingAverage();

function render(now) {
  ...

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    if (canTimestamp &amp;&amp; resultBuffer.mapState === 'unmapped') {
      resultBuffer.mapAsync(GPUMapMode.READ).then(() =&gt; {
        const times = new BigUint64Array(resultBuffer.getMappedRange());
        gpuTime = Number(times[1] - times[0]);
+        gpuAverage.addSample(gpuTime / 1000);
        resultBuffer.unmap();
      });
    }

    const jsTime = performance.now() - startTime;

+    fpsAverage.addSample(1 / deltaTime);
+    jsAverage.addSample(jsTime);

    infoElem.textContent = `\
-fps: ${(1 / deltaTime).toFixed(1)}
-js: ${jsTime.toFixed(1)}ms
-gpu: ${canTimestamp ? `${(gpuTime / 1000).toFixed(1)}µs` : 'N/A'}
+fps: ${fpsAverage.get().toFixed(1)}
+js: ${jsAverage.get().toFixed(1)}ms
+gpu: ${canTimestamp ? `${gpuAverage.get().toFixed(1)}µs` : 'N/A'}
`;

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}
</pre>
<p>이제 숫자가 좀 더 안정적입니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-timing-with-timestamp-w-average.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-timing-with-timestamp-w-average.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<h2 id="헬퍼-사용"><a id="a-timing-helper"></a> 헬퍼 사용</h2>
<p>저는 이 모든 것이 조금 지루하고 뭔가 잘못하기 쉬운 것 같습니다. querySet과 2개의 버퍼, 총 3가지를 만들어야 했습니다. renderPassDescriptor를 변경해야 했습니다. 결과를 resolve 처리하고 매핑 가능한 버퍼로 복사해야 했습니다.</p>
<p>덜 지루하게 만드는 한 가지 방법은 타이밍을 수행하는 데 도움이 되는 클래스를 만드는 것입니다. 다음은 이러한 문제 중 일부를 해결하는 데 도움이 될 수 있는 헬퍼의 예입니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function assert(cond, msg = '') {
  if (!cond) {
    throw new Error(msg);
  }
}

// 커맨드 버퍼가 실행되기 전에 결과를 읽으려고 시도하면 오류를 생성할 수 있도록
// 커맨드 버퍼를 추적합니다.
const s_unsubmittedCommandBuffer = new Set();

/* global GPUQueue */
GPUQueue.prototype.submit = (function(origFn) {
  return function(commandBuffers) {
    origFn.call(this, commandBuffers);
    commandBuffers.forEach(cb =&gt; s_unsubmittedCommandBuffer.delete(cb));
  };
})(GPUQueue.prototype.submit);

// 참조 https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
export default class TimingHelper {
  #canTimestamp;
  #device;
  #querySet;
  #resolveBuffer;
  #resultBuffer;
  #commandBuffer;
  #resultBuffers = [];
  // 상태는 'free', 'need resolve', 'wait for result'일 수 있습니다.
  #state = 'free';

  constructor(device) {
    this.#device = device;
    this.#canTimestamp = device.features.has('timestamp-query');
    if (this.#canTimestamp) {
      this.#querySet = device.createQuerySet({
         type: 'timestamp',
         count: 2,
      });
      this.#resolveBuffer = device.createBuffer({
        size: this.#querySet.count * 8,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
      });
    }
  }

  #beginTimestampPass(encoder, fnName, descriptor) {
    if (this.#canTimestamp) {
      assert(this.#state === 'free', 'state not free');
      this.#state = 'need resolve';

      const pass = encoder[fnName]({
        ...descriptor,
        ...{
          timestampWrites: {
            querySet: this.#querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
          },
        },
      });

      const resolve = () =&gt; this.#resolveTiming(encoder);
      const trackCommandBuffer = (cb) =&gt; this.#trackCommandBuffer(cb);
      pass.end = (function(origFn) {
        return function() {
          origFn.call(this);
          resolve();
        };
      })(pass.end);

      encoder.finish = (function(origFn) {
        return function() {
          const cb = origFn.call(this);
          trackCommandBuffer(cb);
          return cb;
        };
      })(encoder.finish);

      return pass;
    } else {
      return encoder[fnName](descriptor);
    }
  }

  beginRenderPass(encoder, descriptor = {}) {
    return this.#beginTimestampPass(encoder, 'beginRenderPass', descriptor);
  }

  beginComputePass(encoder, descriptor = {}) {
    return this.#beginTimestampPass(encoder, 'beginComputePass', descriptor);
  }

  #trackCommandBuffer(cb) {
    if (!this.#canTimestamp) {
      return;
    }
    assert(this.#state === 'need finish', 'you must call encoder.finish');
    this.#commandBuffer = cb;
    s_unsubmittedCommandBuffer.add(cb);
    this.#state = 'wait for result';
  }

  #resolveTiming(encoder) {
    if (!this.#canTimestamp) {
      return;
    }
    assert(
      this.#state === 'need resolve',
      'you must use timerHelper.beginComputePass or timerHelper.beginRenderPass',
    );
    this.#state = 'need finish';

    this.#resultBuffer = this.#resultBuffers.pop() || this.#device.createBuffer({
      size: this.#resolveBuffer.size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });

    encoder.resolveQuerySet(this.#querySet, 0, this.#querySet.count, this.#resolveBuffer, 0);
    encoder.copyBufferToBuffer(this.#resolveBuffer, 0, this.#resultBuffer, 0, this.#resultBuffer.size);
  }

  async getResult() {
    if (!this.#canTimestamp) {
      return 0;
    }
    assert(
      this.#state === 'wait for result',
      'you must call encoder.finish and submit the command buffer before you can read the result',
    );
    assert(!!this.#commandBuffer); // 내부 검사
    assert(
      !s_unsubmittedCommandBuffer.has(this.#commandBuffer),
      'you must submit the command buffer before you can read the result',
    );
    this.#commandBuffer = undefined;
    this.#state = 'free';

    const resultBuffer = this.#resultBuffer;
    await resultBuffer.mapAsync(GPUMapMode.READ);
    const times = new BigUint64Array(resultBuffer.getMappedRange());
    const duration = Number(times[1] - times[0]);
    resultBuffer.unmap();
    this.#resultBuffers.push(resultBuffer);
    return duration;
  }
}
</pre>
<p>assert는 이 클래스를 잘못 사용하지 않도록 돕기 위한 것입니다.
예를 들어 패스를 종료했지만 해결하지 않거나, 해결하고 결과를 읽으려고 시도했지만 제출하지 않은 경우입니다.</p>
<p>이 클래스를 사용하면 이전에 있었던 코드의 많은 부분을 제거할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const canTimestamp = adapter.features.has('timestamp-query');
  const device = await adapter?.requestDevice({
    requiredFeatures: [
      ...(canTimestamp ? ['timestamp-query'] : []),
     ],
  });
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }

+  const timingHelper = new TimingHelper(device);

  ...

-  const { querySet, resolveBuffer, resultBuffer } = (() =&gt; {
-    if (!canTimestamp) {
-      return {};
-    }
-
-    const querySet = device.createQuerySet({
-       type: 'timestamp',
-       count: 2,
-    });
-    const resolveBuffer = device.createBuffer({
-      size: querySet.count * 8,
-      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
-    });
-    const resultBuffer = device.createBuffer({
-      size: resolveBuffer.size,
-      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
-    });
-    return {querySet, resolveBuffer, resultBuffer };
-  })();

  ...

  function render(now) {

    ...

-    const pass = encoder.beginRenderPass(renderPassDescriptor);
+    const pass = timingHelper.beginRenderPass(encoder, renderPassDescriptor);

    ...

    pass.end();

-    if (canTimestamp) {
-      encoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);
-      if (resultBuffer.mapState === 'unmapped') {
-        encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
-      }
-    }

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

+    timingHelper.getResult().then(gpuTime =&gt; {
+        gpuAverage.addSample(gpuTime / 1000);
+    });

    ...
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-timing-with-timing-helper.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-timing-with-timing-helper.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">TimingHelper</code> 클래스에 대한 몇 가지 사항:</p>
<ul>
<li>
<p>장치를 생성할 때 여전히 <code class="notranslate" translate="no">'timestamp-query'</code> 기능을 수동으로 요청해야 하지만, 기능 존재 여부에 따르는 처리는 클래스가 수행행합니다.</p>
</li>
<li>
<p><code class="notranslate" translate="no">timerHelper.beginRenderPass</code> 또는 <code class="notranslate" translate="no">timerHelper.beginComputePass</code>를 호출하면 패스 디스크립터에 적절한 속성이 자동으로 추가됩니다. 또한 <code class="notranslate" translate="no">end</code> 함수가 쿼리를 자동으로 resolve 하는 패스 인코더를 반환합니다.</p>
</li>
<li>
<p>잘못 사용하면 불평하도록 설계되었습니다.</p>
</li>
<li>
<p>1개의 패스만 처리합니다.</p>
<p>여기에는 많은 타협이 있으며 더 많은 탐색 없이는 무엇이 최선인지 명확하지 않습니다.</p>
<p>여러 패스를 처리하는 클래스가 유용할 수 있지만, 이상적으로는 패스당 1개의 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>이 아니라 모든 패스를 처리할 충분한 공간이 있는 단일 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>을 사용하는 것이 좋습니다.</p>
<p>하지만 그렇게 하려면 사용자가 사용할 최대 패스 수를 미리 알려주도록 해야 합니다. 또는 작은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>으로 시작하여 늘려가려면,
이전 것을 삭제하고 더 큰 새 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>을 만드는 더 복잡한 코드를 만들어야 합니다. 그렇게 하더라도 적어도 1 프레임 동안은 여러 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet"><code class="notranslate" translate="no">GPUQuerySet</code></a>을 처리해야 합니다.</p>
<p>그 모든 것이 과도해 보여서 지금은 하나의 패스를 처리하도록 만들고, 변경이 필요해지면 이 코드를 기반으로 구축할 수 있도록 하는 것이 최선인 것 같습니다.</p>
</li>
</ul>
<p><code class="notranslate" translate="no">NoTimingHelper</code>를 만들 수도 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class NoTimingHelper {
  constructor() { }
  beginRenderPass(encoder, descriptor = {}) {
    return encoder.beginTimestampPass(descriptor);
  }

  beginComputePass(encoder, descriptor = {}) {
    return encoder.beginComputePass(descriptor);
  }
  async getResult() { return 0; }
}
</pre>
<p>너무 많은 코드를 변경하지 않고도 타이밍을 추가하고 끌 수 있도록 만드는 한 가지 가능한 방법입니다.</p>
<p>어쨌든 저는 <code class="notranslate" translate="no">TimingHelper</code> 클래스를 사용하여 <a href="webgpu-compute-shaders-histogram.html">컴퓨트 쉐이더를 사용하여 이미지 히스토그램을 계산하는 방법에 대한 글</a>의 다양한 예제 시간을 측정했습니다.
다음은 그 목록입니다. 비디오 예제만 지속적으로 실행되므로 아마도 가장 좋은 예일 것입니다.</p>
<ul>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-video-w-timing.html">4채널 비디오 히스토그램</a></li>
</ul>
<p>나머지는 한 번만 실행되고 결과를 JavaScript 콘솔에 출력합니다.</p>
<ul>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-4ch-optimized-more-w-timing.html">reduce를 사용한 청크당 4채널 워크그룹 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-4ch-race-fixed-w-timing.html">픽셀당 4채널 워크그룹 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-4ch-javascript-w-timing.html">4채널 JavaScript 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-optimized-more-w-timing.html">reduce를 사용한 청크당 1채널 워크그룹 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-optimized-w-timing.html">sum을 사용한 청크당 1채널 워크그룹 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-race-fixed-w-timing.html">픽셀당 1채널 워크그룹 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-slow-w-timing.html">1채널 단일 코어 히스토그램</a></li>
<li><a target="_blank" href="../../webgpu-compute-shaders-histogram-javascript-w-timing.html">1채널 JavaScript 히스토그램</a></li>
</ul>
<h1 id="중요-timestamp-query-결과는-webgpu-구현체에-따라-다를-수-있음"><a id="a-implementation-defined"></a> 중요: <code class="notranslate" translate="no">timestamp-query</code> 결과는 WebGPU 구현체에 따라 다를 수 있음</h1>
<p>위 내용들을 디버깅 및 기술 비교에 사용할 수는 있지만 사실상 모든 사용자에게서 유사한 결과를 반환한다고는 신뢰할 수 없음을 의미합니다.
상대적인 결과조차 가정할 수 없습니다. 서로 다른 GPU는 서로 다른 방식으로 작동하며 패스 전체에서 렌더링 및 컴퓨팅을 최적화할 수 있습니다.
즉, 한 머신에서는 첫 번째 패스가 100개를 그리는 데 200µs가 걸리고 두 번째 패스도 200개를 그리는 데 200µs가 걸릴 수 있지만,
다른 GPU는 처음 100개를 그리는 데 100µs가 걸리고 두 번째 100개를 그리는 데 200µs가 걸릴 수 있으므로
첫 번째 GPU는 상대적 차이가 0µs인 반면 두 번째 GPU는 두 GPU 모두 같은 것을 그리도록 요청받았음에도 불구하고 상대적 차이가 100µs였습니다.</p>
<h1 id="중요-timestamp-query-결과는-성능의-좋은-척도가-아님"><a id="a-implementation-defined"></a> 중요: <code class="notranslate" translate="no">timestamp-query</code> 결과는 성능의 좋은 척도가 아님</h1>
<p>타임스탬프 쿼리는 전체 성능을 결정하는 다른 많은 요소가 있으므로 성능의 좋은 척도가 아닙니다. 구체적인 예를 들어보겠습니다. 우리는 <a href="webgpu-importing-textures.html#a-generating-mips-on-the-gpu">텍스처로 이미지 로드에 관한 글</a>에서 렌더 패스 기반 밉맵 생성기를 작성했습니다.
저는 컴퓨트 패스 기반 밉맵 생성기도 작성했습니다. timestamp-query를 사용하여 둘 다 시간을 측정했을 때 컴퓨트 패스 방식이 렌더 패스 기반 방식보다 5배 빠르다고 나왔습니다. 야호! 하지만 그 후 처리량 테스트로 전환했습니다. timestamp-query를 사용하는 대신 초당 60프레임으로 밉맵을 생성할 2048x2048 텍스처의 수를 늘릴 수 있는 테스트를 작성했습니다. 프레임 속도가 60fps 아래로 떨어질 때까지 숫자를 늘렸습니다. 이 방법을 사용하면 렌더 패스 방식이 한 머신에서는 컴퓨트 패스 방식보다 20% 빠르고 다른 머신에서는 8% 더 빠른 것으로 나타났습니다.</p>
<p>요점은 timestamp-query만 단독으로 사용하여 무언가가 얼마나 빨리 실행될지 알 수 없다는 것입니다.</p>
<div class="webgpu_bottombar">기본적으로 <code class="notranslate" translate="no">'timestamp-query'</code> 시간 값은 100µ초로 양자화됩니다. Chrome에서 <a href="chrome://flags/#enable-webgpu-developer-features" target="_blank">about:flags</a>의 <a href="chrome://flags/#enable-webgpu-developer-features" target="_blank">"enable-webgpu-developer-features"</a>를 활성화하면 시간 값이 양자화되지 않을 수 있습니다. 이렇게 하면 이론적으로 더 정확한 타이밍을 얻을 수 있습니다. 즉, 일반적인 상황에서 100µ초로 양자화된 값 정도면 쉐이더 성능 비교에 충분하다는 뜻입니다.
</div>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><code class="notranslate" translate="no">rAF</code>는 <code class="notranslate" translate="no">requestAnimationFrame</code>의 약자입니다. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>이것은 원의 반지름이 0.5보다 작은 경우에만 작동합니다. 크기 체크를 복잡하게 하느라 코드를 크게 부풀리고 싶지는 않습니다. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>쿼리 결과를 매핑 가능한 버퍼로 복사하는 것은 JavaScript에서 값을 읽기 위한 목적일 뿐입니다. 사용 사례에서 결과가 GPU에만 있어도 그만인 경우(예: 다른 무언가에 대한 입력으로), 결과를 매핑 가능한 버퍼로 복사할 필요가 없습니다. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-timing.html">English
    </option><option value="/webgpu/lessons/es/webgpu-timing.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-timing.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-timing.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-timing.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-timing.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-timing.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-timing.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">스테이지간 변수(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">스토리지 버퍼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">정점 버퍼</a></li>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">이미지 로딩</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">비디오 사용하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">큐브맵(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">스토리지 텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">멀티 샘플링 / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">상수(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">데이터 메모리 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">바인드 그룹 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">데이터 복사하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">선택적 기능(optional feature)과 제한(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">타이밍 성능</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">동작 방식</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D 수학</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>후처리</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-post-processing.html">Basic CRT Effect</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-image-adjustments.html">Image Adjustments</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-1dlut.html">1D Lookup Table (LUT)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-3dlut.html">3D Lookup Table (LUT)</a></li>
        </ul>
        </ul>
  <li>컴퓨트 셰이더</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">컴퓨트 셰이더 기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">리소스 / 참고자료</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>질문이 있나요? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>에 물어보세요.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">제안</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">요청 사항</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">이슈</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">버그</a>
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 타이밍 성능`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님<br> 당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여에 감사드립니다.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/js/prettify.js"></script>
<script src="/webgpu/lessons/resources/js/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>