<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-bind-group-layouts.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="명시적 바인드 그룹 레이아웃">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_ko.jpg">

<meta property="og:title" content="WebGPU 바인드 그룹 레이아웃">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_ko.jpg">
<meta property="og:description" content="명시적 바인드 그룹 레이아웃">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 바인드 그룹 레이아웃">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html">
<meta name="twitter:description" content="명시적 바인드 그룹 레이아웃">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html",
      "inLanguage":"ko",
      "name":"WebGPU 바인드 그룹 레이아웃",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-bind-group-layouts.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 바인드 그룹 레이아웃</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-bind-group-layouts.html">English
    </option><option value="/webgpu/lessons/es/webgpu-bind-group-layouts.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-bind-group-layouts.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-bind-group-layouts.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-bind-group-layouts.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-bind-group-layouts.html">简体中文
</option></select>


    <a href="#toc">목차</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 바인드 그룹 레이아웃</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>바인드 그룹 레이아웃은 WebGPU가 바인드 그룹을 계산 및 렌더 파이프라인과 쉽고 효율적으로 일치시키기 위해 사용됩니다.</p>
<h2 id="동작-방식">동작 방식:</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUComputePipeline"><code class="notranslate" translate="no">GPUComputePipeline</code></a>이나 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPURenderPipeline"><code class="notranslate" translate="no">GPURenderPipeline</code></a>과 같은 파이프라인은 0개 이상의 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>을 정의하는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>을 사용합니다. 각 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>은 특정 그룹 인덱스에 할당됩니다.</p>
<div class="webgpu_center"><img src="../resources/webgpu-bind-group-layouts.svg" style="width: 900px;"></div>
<p>바인드 그룹은 각각 특정 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>으로 생성됩니다.</p>
<p><code class="notranslate" translate="no">draw</code>나 <code class="notranslate" translate="no">dispatchWorkgroups</code>를 호출할 때, WebGPU는 현재 파이프라인의 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>에 있는 각 그룹 인덱스에 대한 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>이 <code class="notranslate" translate="no">setBindGroup</code>으로 설정된 현재 바인딩된 바인드 그룹과 일치하는지만 확인하면 됩니다. 이 확인은 매우 간단합니다. 대부분의 세부 확인은 바인드 그룹을 생성할 때 발생합니다. 이렇게 하면 실제로 그리거나 계산할 때 확인할 것이 거의 남지 않습니다.</p>
<p>이 웹사이트의 대부분 샘플처럼 <code class="notranslate" translate="no">layout: 'auto'</code>로 파이프라인을 생성하면, 파이프라인은 자체 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>을 생성하고 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>을 자동으로 채웁니다.</p>
<p><code class="notranslate" translate="no">layout: 'auto'</code>를 사용하지 <strong>않는</strong> 두 가지 주요 이유가 있습니다.</p>
<ol>
<li>
<p><strong>기본 <code class="notranslate" translate="no">'auto'</code> 레이아웃과 다른 레이아웃을 원할 경우</strong></p>
<p>예를 들어, 텍스처로 <code class="notranslate" translate="no">rgba32float</code>을 사용하고 싶지만, 시도할 때 오류가 발생하는 경우입니다. (아래 참조)</p>
</li>
<li>
<p><strong>하나의 바인드 그룹을 여러 개의 파이프라인에서 사용하고 싶을 경우</strong></p>
<p><code class="notranslate" translate="no">layout: 'auto'</code>로 파이프라인에서 만들어진 bindGroupLayout에서 만든 바인드 그룹은 다른 파이프라인에서 사용할 수 없습니다.</p>
</li>
</ol>
<h2 id="layout-auto와-다른-바인드-그룹-레이아웃-사용하기---rgba32float"><a id="a-rgba32float"></a> <code class="notranslate" translate="no">layout: 'auto'</code>와 다른 바인드 그룹 레이아웃 사용하기 - <code class="notranslate" translate="no">'rgba32float'</code></h2>
<p>바인드 그룹 레이아웃이 자동으로 생성되는 규칙은 <a href="https://www.w3.org/TR/webgpu/#abstract-opdef-default-pipeline-layout">사양에 자세히 설명되어 있습니다</a>. 하지만 한 가지 예로…</p>
<p><code class="notranslate" translate="no">rgba32float</code> 텍스처를 사용하고 싶다고 가정해 봅시다. <a href="webgpu-textures.html">텍스처에 대한 글의 첫 번째 텍스처 사용 예제</a>를 가져와서 거꾸로 된 5x7 텍셀 'F’를 그렸습니다. 이를 <code class="notranslate" translate="no">rgba32float</code> 텍스처를 사용하도록 업데이트해 보겠습니다.</p>
<p>변경 사항은 다음과 같습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kTextureWidth = 5;
  const kTextureHeight = 7;
-  const _ = [255,   0,   0, 255];  // red
-  const y = [255, 255,   0, 255];  // yellow
-  const b = [  0,   0, 255, 255];  // blue
-  const textureData = new Uint8Array([
+  const _ = [1, 0, 0, 1];  // red
+  const y = [1, 1, 0, 1];  // yellow
+  const b = [0, 0, 1, 1];  // blue
+  const textureData = new Float32Array([
    b, _, _, _, _,
    _, y, y, y, _,
    _, y, _, _, _,
    _, y, y, _, _,
    _, y, _, _, _,
    _, y, _, _, _,
    _, _, _, _, _,
  ].flat());

  const texture = device.createTexture({
    label: 'yellow F on red',
    size: [kTextureWidth, kTextureHeight],
-    format: 'rgba8unorm',
+    format: 'rgba32float',
    usage:
      GPUTextureUsage.TEXTURE_BINDING |
      GPUTextureUsage.COPY_DST,
  });
  device.queue.writeTexture(
      { texture },
      textureData,
-      { bytesPerRow: kTextureWidth * 4 },
+      { bytesPerRow: kTextureWidth * 4 * 4 },
      { width: kTextureWidth, height: kTextureHeight },
  );

</pre>
<p>실행하면 오류가 발생합니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-rgba32float-broken.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-rgba32float-broken.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>제가 테스트한 브라우저에서 받은 오류는 다음과 같습니다.</p>
<blockquote>
<ul>
<li>WebGPU GPUValidationError: [Texture “yellow F on red”]의 지원되는 샘플 유형(UnfilterableFloat) 중 어느 것도 예상 샘플 유형(Float)과 일치하지 않습니다.`<br></li>
<li>entries[1]을 샘플링된 텍스처로 유효성 검사하는 동안. 예상 항목 레이아웃: {sampleType: TextureSampleType::Float, viewDimension: 2, multisampled: 0}`<br></li>
<li>[BindGroupDescriptor]를 [BindGroupLayout (unlabeled)]에 대해 유효성 검사하는 동안`<br></li>
<li>[Device].CreateBindGroup([BindGroupDescriptor])를 호출하는 동안`</li>
</ul>
</blockquote>
<p>이게 무슨 일일까요? <code class="notranslate" translate="no">rgba32float</code>(및 모든 <code class="notranslate" translate="no">xxx32float</code>) 텍스처는 기본적으로 필터링할 수 없습니다. 필터링 가능하게 만드는 <a href="webgpu-limits-and-features.html">선택적 기능</a>이 있지만, 이 기능은 모든 곳에서 사용 가능하지 않을 수 있습니다. 특히 2024년 현재 모바일 장치에서 그럴 가능성이 높습니다.</p>
<p>기본적으로 다음과 같이 <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>로 바인딩을 선언할 때:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;
</pre>
<p>그리고 파이프라인을 생성할 때 <code class="notranslate" translate="no">layout: 'auto'</code>를 사용하면 WebGPU는 필터링 가능한 텍스처를 특별히 요구하는 바인드 그룹 레이아웃을 생성합니다. 필터링할 수 없는 텍스처를 바인딩하려고 하면 오류가 발생합니다.</p>
<p>필터링할 수 없는 텍스처를 사용하려면 바인드 그룹 레이아웃을 수동으로 생성해야 합니다.</p>
<p><a href="../resources/wgsl-offset-computer.html">여기</a>에 셰이더를 붙여넣으면 자동 레이아웃을 생성해주는 도구가 있습니다. 위 예제의 셰이더를 붙여넣으면 다음과 같이 나옵니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayoutDescriptors = [
  {
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
          type: "filtering",
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false,
        },
      },
    ],
  },
];
</pre>
<p>이것은 <a href="https://www.w3.org/TR/webgpu/#dictdef-gpubindgrouplayoutdescriptor"><code class="notranslate" translate="no">GPUBindGroupLayoutDescriptor</code></a>의 배열입니다. 위에서 볼 수 있듯이 바인드 그룹은 <code class="notranslate" translate="no">sampleType: "float"</code>을 사용합니다. 이는 <code class="notranslate" translate="no">'rgba8unorm'</code>의 유형이지만 <code class="notranslate" translate="no">'rgba32float'</code>의 유형은 아닙니다. 특정 텍스처 형식이 작동하는 샘플 유형은 <a href="https://www.w3.org/TR/webgpu/#texture-format-caps">스펙 문서의 이 표</a>에서 읽을 수 있습니다.</p>
<p>예제를 수정하려면 텍스처 바인딩과 샘플러 바인딩을 모두 조정해야 합니다. 샘플러 바인딩은 <code class="notranslate" translate="no">'non-filtering'</code> 샘플러로 변경해야 합니다. 텍스처 바인딩은 <code class="notranslate" translate="no">'unfilterable-float'</code>으로 변경해야 합니다.</p>
<p>따라서 먼저 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>을 생성해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
*          type: 'non-filtering',
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
*          sampleType: 'unfilterable-float',
          viewDimension: '2d',
          multisampled: false,
        },
      },
    ],
  });
</pre>
<p>두 가지 변경 사항이 위에 표시되어 있습니다.</p>
<p>그런 다음 파이프라인에서 사용하는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>의 배열인 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>을 생성해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });
</pre>
<p><code class="notranslate" translate="no">createPipelineLayout</code>은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a> 배열이 있는 객체를 받습니다. 그룹 인덱스 순서대로 정렬되므로 첫 번째 항목은 <code class="notranslate" translate="no">@group(0)</code>, 두 번째 항목은 <code class="notranslate" translate="no">@group(1)</code>이 됩니다. 하나를 건너뛰려면 비어 있거나 정의되지 않은 요소를 추가해야 합니다.</p>
<p>마지막으로 파이프라인을 생성할 때 파이프라인 레이아웃을 전달합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded textured quad pipeline',
-    layout: 'auto',
+    layout: pipelineLayout,
    vertex: {
      module,
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>이제 예제가 다시 작동하지만 <code class="notranslate" translate="no">rgba32float</code> 텍스처를 사용합니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-rgba32float-fixed.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-rgba32float-fixed.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>참고: 이 예제가 작동하는 이유는 위에서 unfilterable-float 를 받도록 바인드 그룹 레이아웃을 만들었기 때문이기도 하지만, 예제가 <code class="notranslate" translate="no">'nearest'</code> 필터링만 사용하는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUSampler"><code class="notranslate" translate="no">GPUSampler</code></a>를 사용하기 때문이기도 합니다. <code class="notranslate" translate="no">magFilter</code>, <code class="notranslate" translate="no">minFilter</code>, <code class="notranslate" translate="no">mipmapFilter</code> 중에 하나라도 <code class="notranslate" translate="no">'linear'</code>로 설정했다면, <code class="notranslate" translate="no">'non-filtering'</code> 샘플러 바인딩에 <code class="notranslate" translate="no">'filtering'</code> 샘플러를 사용하려고 했다는 오류가 발생했을 것입니다.</p>
<h2 id="layout-auto와-다른-바인드-그룹-레이아웃-사용하기---동적-오프셋"><code class="notranslate" translate="no">layout: 'auto'</code>와 다른 바인드 그룹 레이아웃 사용하기 - 동적 오프셋</h2>
<p>기본적으로 바인드 그룹을 만들고 uniform 또는 storage 버퍼를 바인딩하면 전체 버퍼가 바인딩됩니다. 바인드 그룹을 생성할 때 오프셋과 길이를 전달할 수도 있습니다. 두 경우 모두 일단 설정되면 변경할 수 없습니다.</p>
<p>WebGPU에는 <code class="notranslate" translate="no">setBindGroup</code>을 호출할 때 오프셋을 변경할 수 있는 옵션이 있습니다. 이 기능을 사용하려면 바인드 그룹 레이아웃을 수동으로 생성하고 나중에 설정하려는 각 바인딩에 대해 <code class="notranslate" translate="no">hasDynamicOffsets: true</code>를 설정해야 합니다.</p>
<p><a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">기초에 대한 글</a>의 간단한 계산 예제를 사용하겠습니다. 동일한 버퍼에 두 세트의 값을 추가하고, 동적 오프셋을 사용하여 어느 세트를 사용할지 선택하도록 바꿔봅니다.</p>
<p>먼저 셰이더를 다음과 같이 변경해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; a: array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; b: array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; dst: array&lt;f32&gt;;

@compute @workgroup_size(1) fn computeSomething(
  @builtin(global_invocation_id) id: vec3u
) {
  let i = id.x;
  dst[i] = a[i] + b[i];
}
</pre>
<p><code class="notranslate" translate="no">a</code>와 <code class="notranslate" translate="no">b</code>를 더해서 <code class="notranslate" translate="no">dst</code>에 쓰는 것을 볼 수 있습니다.</p>
<p>다음으로 바인드 그룹 레이아웃을 만들어 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
      {
        binding: 2,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
    ],
  });
</pre>
<p>모두 <code class="notranslate" translate="no">hasDynamicStorage: true</code>로 표시되어 있습니다.</p>
<p>이제 이를 사용하여 파이프라인을 만들어 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });

  const pipeline = device.createComputePipeline({
-    label: 'double compute pipeline',
-    layout: 'auto',
+    label: 'add elements compute pipeline',
+    layout: pipelineLayout,
    compute: {
      module,
    },
  });
</pre>
<p>버퍼를 설정해 봅시다. 오프셋은 256의 배수여야 하므로<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, 256 * 3 바이트 크기의 버퍼를 만들어 최소 3개의 유효한 오프셋(0, 256, 512)을 갖도록 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const input = new Float32Array([1, 3, 5]);
+  const input = new Float32Array(64 * 3);
+  input.set([1, 3, 5]);
+  input.set([11, 12, 13], 64);

  // 계산을 담을 GPU 버퍼 생성
  // 입력 및 출력
  const workBuffer = device.createBuffer({
    label: 'work buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  // 입력 데이터를 해당 버퍼에 복사
  device.queue.writeBuffer(workBuffer, 0, input);
</pre>
<p>위 코드는 <code class="notranslate" translate="no">64 * 3</code>개의 32비트 부동 소수점 배열을 만듭니다. 이는 768바이트입니다.</p>
<p>원래 예제는 동일한 버퍼에서 읽고 썼으므로 동일한 버퍼를 3번 바인딩합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 계산에 사용할 버퍼를 셰이더에 알리기 위한
  // bindGroup 설정
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
-      { binding: 0, resource: { buffer: workBuffer } },
+      { binding: 0, resource: { buffer: workBuffer, size: 256 } },
+      { binding: 1, resource: { buffer: workBuffer, size: 256 } },
+      { binding: 2, resource: { buffer: workBuffer, size: 256 } },
    ],
  });
</pre>
<p>참고로, 크기를 지정해야 합니다. 그렇지 않으면 전체 버퍼의 크기로 기본 설정됩니다. 그런 다음 오프셋 &gt; 0을 설정하면 범위를 벗어난 버퍼 부분을 지정하게 되므로 오류가 발생합니다.</p>
<p><code class="notranslate" translate="no">setBindGroup</code>에서 이제 동적 오프셋이 있는 각 버퍼에 대해 하나의 오프셋을 전달합니다. 바인드 그룹 레이아웃의 3개 항목 모두를 <code class="notranslate" translate="no">hasDynamicOffset: true</code>로 표시했으므로 바인딩 슬롯 순서대로 3개의 오프셋이 필요합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  ...
  pass.setPipeline(pipeline);
-  pass.setBindGroup(0, bindGroup);
+  pass.setBindGroup(0, bindGroup, [0, 256, 512]);
  pass.dispatchWorkgroups(3);
  pass.end();
</pre>
<p>마지막으로 결과를 표시하도록 코드를 변경해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  console.log(input);
-  console.log(result);
+  console.log('a', input.slice(0, 3));
+  console.log('b', input.slice(64, 64 + 3));
+  console.log('dst', result.slice(128, 128 + 3));
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-dynamic-offsets.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-dynamic-offsets.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>동적 오프셋을 사용하는 것은 비동적 오프셋보다 약간 느립니다. 그 이유는 비동적 오프셋의 경우 오프셋과 크기가 버퍼 범위 내에 있는지 여부가 바인드 그룹을 생성할 때 확인되기 때문입니다. 동적 오프셋의 경우 <code class="notranslate" translate="no">setBindGroup</code>을 호출할 때까지 해당 확인을 할 수 없습니다. <code class="notranslate" translate="no">setBindGroup</code>을 수백 번만 호출하는 경우 그 차이는 중요하지 않을 수 있습니다. <code class="notranslate" translate="no">setBindGroup</code>을 수천 번 호출하는 경우 더 눈에 띌 수 있습니다.</p>
<h2 id="하나-이상의-파이프라인에서-바인드-그룹-사용하기"><a id="a-sharing-bind-groups"></a> 하나 이상의 파이프라인에서 바인드 그룹 사용하기</h2>
<p>바인드 그룹 레이아웃을 수동으로 생성하는 또 다른 이유는 동일한 바인드 그룹을 둘 이상의 파이프라인에서 사용할 수 있도록 하기 위함입니다.</p>
<p>흔하게 바인드 그룹을 재사용하게 되는 경우는 그림자가 있는 기본 3D 장면 렌더러입니다.</p>
<p>기본 3D 장면 렌더러에서는 바인딩을 다음과 같이 분리하는 것이 일반적입니다.</p>
<ul>
<li>global <sup>전역</sup> (원근 및 뷰 행렬 등)</li>
<li>material <sup>재질</sup> (텍스처, 색상)</li>
<li>local <sup>지역</sup> (모델 행렬 등)</li>
</ul>
<p>그런 다음 다음과 같이 렌더링합니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">setBindGroup(0, globalsBG)
for each material
  setBindGroup(1, materialBG)
  for each object that uses material
    setBindGroup(2, localBG)
    draw(...)
</pre>
<p><a href="webgpu-shadows.html">그림자</a>를 추가할 때, 먼저 그림자 맵 파이프라인으로 그림자 맵을 그려야 합니다. 그리기 파이프라인과 그림자 맵 렌더링 파이프라인에서 작동하는 별도의 바인드 그룹을 사용하는 대신, 하나의 바인드 그룹 세트를 만들고 두 경우 모두 동일한 것을 사용하는 것이 훨씬 쉽습니다.</p>
<p>비록 <a href="webgpu-shadows.html">그림자에 대한 글</a>이 공유 바인드 그룹을 사용하지만, 단순히 이 용도의 예제로서 보여주기에는 다소 코드 크기가 큽니다.
<a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">기초에 대한 글</a>의 간단한 계산 예제를 다시 가져와서 하나의 바인드 그룹으로 2개의 계산 파이프라인을 사용하도록 만들겠습니다.</p>
<p>먼저 3을 더하는 기능을 가진 셰이더 모듈을 추가해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
+  const moduleTimes2 = device.createShaderModule({
    label: 'doubling compute module',
    code: /* wgsl */ `
      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        let i = id.x;
        data[i] = data[i] * 2.0;
      }
    `,
  });

+  const modulePlus3 = device.createShaderModule({
+    label: 'adding 3 compute module',
+    code: /* wgsl */ `
+      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;
+
+      @compute @workgroup_size(1) fn computeSomething(
+        @builtin(global_invocation_id) id: vec3u
+      ) {
+        let i = id.x;
+        data[i] = data[i] + 3.0;
+      }
+    `,
+  });
</pre>
<p>그런 다음 2개의 파이프라인이 동일한 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroup"><code class="notranslate" translate="no">GPUBindGroup</code></a>을 공유하기 위해서 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>과 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>을 생성해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          minBindingSize: 0,
        },
      },
    ],
  });

  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });
</pre>
<p>이제 파이프라인을 생성할 때 이것들을 사용합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const pipeline = device.createComputePipeline({
+  const pipelineTimes2 = device.createComputePipeline({
    label: 'doubling compute pipeline',
-    layout: 'auto',
+    layout: pipelineLayout,
    compute: {
      module: moduleTimes2,
    },
  });

+  const pipelinePlus3 = device.createComputePipeline({
+    label: 'plus 3 compute pipeline',
+    layout: pipelineLayout,
+    compute: {
+      module: modulePlus3,
+    },
+  });
</pre>
<p>바인드 그룹을 설정할 때 <code class="notranslate" translate="no">bindGroupLayout</code>을 직접 사용해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 계산에 사용할 버퍼를 셰이더에 알리기 위한
  // bindGroup 설정
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
-    layout: pipeline.getBindGroupLayout(0),
+    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: workBuffer } },
    ],
  });
</pre>
<p>마지막으로 두 파이프라인을 모두 사용해 보겠습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // 계산을 수행할 명령 인코딩
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
-  pass.setPipeline(pipeline);
+  pass.setPipeline(pipelineTimes2);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(input.length);
+  pass.setPipeline(pipelinePlus3);
+  pass.dispatchWorkgroups(input.length);
  pass.end();
</pre>
<p>결과는 하나의 바인드 그룹으로 2를 곱하고 3을 더하는 것입니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-multiple-pipelines.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-multiple-pipelines.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>별로 흥미롭지는 않지만 적어도 작동하고 간단한 예제입니다.</p>
<p>바인드 그룹 레이아웃을 수동으로 만들지 여부는 전적으로 사용자에게 달려 있습니다. 위 예제에서는 각 파이프라인에 대해 하나씩 2개의 바인드 그룹을 만드는 것이 더 쉬웠을 것입니다.</p>
<p>간단한 상황에서는 바인드 그룹 레이아웃을 수동으로 만들 필요가 없는 경우가 많지만, WebGPU 프로그램이 더 복잡해지면 바인드 그룹 레이아웃 만들기가 필요해지는 때가 올수도 있습니다.</p>
<h2 id="바인드-그룹-레이아웃-참고-사항"><a id="a-bind-group-layout-notes"></a> 바인드 그룹 레이아웃 참고 사항:</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a> 생성에 대한 몇 가지 참고 사항:</p>
<ul>
<li>
<h2 id="각-항목은-어떤-binding에-대한-것인지-선언해야-합니다">각 항목은 어떤 <code class="notranslate" translate="no">binding</code>에 대한 것인지 선언해야 합니다.</h2>
</li>
<li>
<h2 id="각-항목은-어떤-스테이지에서-보일지-선언해야-합니다">각 항목은 어떤 스테이지에서 보일지 선언해야 합니다.</h2>
<p>위 예제에서는 하나의 가시성만 선언했습니다. 예를 들어, 정점 셰이더와 프래그먼트 셰이더 모두에서 바인드 그룹을 참조하고 싶다면 다음을 사용합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX
</pre>
<p>또는 세 스테이지 모두:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   visibility: GPUShaderStage.COMPUTE |
               GPUShaderStage.FRAGMENT | 
               GPUShaderStage.VERTEX
</pre>
</li>
<li>
<h2 id="몇-가지-기본값이-있습니다">몇 가지 기본값이 있습니다.</h2>
<p><code class="notranslate" translate="no">texture:</code> 바인딩의 기본값은 다음과 같습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  sampleType: 'float',
  viewDimension: '2d',
  multisampled: false,
}
</pre>
<p><code class="notranslate" translate="no">sampler:</code> 바인딩의 기본값은 다음과 같습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  type: 'filtering',
}
</pre>
<p>즉, 가장 일반적인 샘플러 및 텍스처 사용에서 다음과 같이 샘플러 및 텍스처 항목을 선언할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayout = device.createBindGroupLayout({
  entries: [
    {
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {},  // 기본값 사용
    },
    {
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {},  // 기본값 사용
    },
  ],
});
</pre>
</li>
<li>
<h2 id="버퍼-항목은-가능하면-minbindingsize를-선언해야-합니다">버퍼 항목은 가능하면 <code class="notranslate" translate="no">minBindingSize</code>를 선언해야 합니다.</h2>
<p>버퍼 바인딩을 선언할 때 <code class="notranslate" translate="no">minBindingSize</code>를 지정할 수 있습니다.</p>
<p>좋은 예는 uniform을 위한 구조체를 만드는 것입니다. 예를 들어 <a href="webgpu-uniforms.html">uniform에 대한 글</a>에서 이 구조체를 사용했습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  scale: vec2f,
  offset: vec2f,
};

@group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
</pre>
<p>32바이트가 필요하므로 다음과 같이 <code class="notranslate" translate="no">minBindingSize</code>를 선언해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayout = device.createBindGroupLayout({
  entries: [
    {
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: 'uniform',
        minBindingSize: 32,
      },
    },
  ],
});
</pre>
<p><code class="notranslate" translate="no">minBindingSize</code>를 선언하는 이유는 WebGPU가 <code class="notranslate" translate="no">createBindGroup</code>을 호출할 때 버퍼 크기/오프셋이 올바른 크기인지 확인하도록 하기 위함입니다. <code class="notranslate" translate="no">minBindingSize</code>를 설정하지 않으면 WebGPU는 draw 혹은 dispatchWorkgroups 호출 시점에 파이프라인의 버퍼가 올바른 크기인지 확인해야 합니다. 모든 그리기 호출을 확인하는 것은 바인드 그룹을 생성할 때 한 번 확인하는 것보다 느립니다.</p>
<p>반면에, 위 예제에서 숫자를 두 배로 만드는 storage 버퍼를 사용했을 때는 <code class="notranslate" translate="no">minBindingSize</code>를 선언하지 않았습니다. 이는 storage 버퍼가 <code class="notranslate" translate="no">array</code>로 선언되었기 때문에 전달하는 값의 수에 따라 다른 크기의 버퍼를 바인딩할 수 있기 때문입니다.</p>
</li>
</ul>
<p><a href="https://www.w3.org/TR/webgpu/#dictdef-gpubindgrouplayoutentry">스펙 문서의 이 부분</a>은 바인드 그룹 레이아웃을 만들기 위한 모든 옵션을 자세히 설명합니다.</p>
<p><a href="https://toji.dev/webgpu-best-practices/bind-groups">이 글</a> 또한 바인드 그룹 및 바인드 그룹 레이아웃에 대한 몇 가지 조언을 제공합니다.</p>
<p><a href="https://greggman.github.io/webgpu-utils">이 라이브러리</a>는 구조체 크기와 기본 바인드 그룹 레이아웃을 계산해 줍니다.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>장치가 더 작은 오프셋을 지원할 수도 있습니다. <a href="webgpu-limits-and-features.html">제한 및 기능</a>의 <code class="notranslate" translate="no">minStorageBufferOffsetAlignment</code> 또는 <code class="notranslate" translate="no">minUniformBufferOffsetAlignment</code>를 참조하세요. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-bind-group-layouts.html">English
    </option><option value="/webgpu/lessons/es/webgpu-bind-group-layouts.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-bind-group-layouts.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-bind-group-layouts.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-bind-group-layouts.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-bind-group-layouts.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">스테이지간 변수(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">스토리지 버퍼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">정점 버퍼</a></li>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">이미지 로딩</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">비디오 사용하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">큐브맵(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">스토리지 텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">멀티 샘플링 / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">상수(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">데이터 메모리 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">바인드 그룹 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">데이터 복사하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">선택적 기능(optional feature)과 제한(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">타이밍 성능</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">동작 방식</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D 수학</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>후처리</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-post-processing.html">Basic CRT Effect</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-image-adjustments.html">Image Adjustments</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-1dlut.html">1D Lookup Table (LUT)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-3dlut.html">3D Lookup Table (LUT)</a></li>
        </ul>
        </ul>
  <li>컴퓨트 셰이더</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">컴퓨트 셰이더 기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">리소스 / 참고자료</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>질문이 있나요? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>에 물어보세요.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">제안</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">요청 사항</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">이슈</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">버그</a>
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 바인드 그룹 레이아웃`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님<br> 당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여에 감사드립니다.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/js/prettify.js"></script>
<script src="/webgpu/lessons/resources/js/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>