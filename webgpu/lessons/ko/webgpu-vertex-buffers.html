<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-vertex-buffers.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="정점 데이터를 셰이더로 전달하기">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_ko.jpg">

<meta property="og:title" content="WebGPU 정점 버퍼">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_ko.jpg">
<meta property="og:description" content="정점 데이터를 셰이더로 전달하기">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 정점 버퍼">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html">
<meta name="twitter:description" content="정점 데이터를 셰이더로 전달하기">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html",
      "inLanguage":"ko",
      "name":"WebGPU 정점 버퍼",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-vertex-buffers.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 정점 버퍼</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-vertex-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-vertex-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-vertex-buffers.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-vertex-buffers.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-vertex-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-vertex-buffers.html">简体中文
</option></select>


    <a href="#toc">목차</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 정점 버퍼</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><a href="webgpu-storage-buffers.html">이전 글</a>에서 우리는 정점 데이터를
스토리지 버퍼에 넣고 내장변수(builtin) <code class="notranslate" translate="no">vertex_index</code>를 사용해 인덱싱했습니다.
이러한 방법이 유명해지고 있긴 하지만, 전통적으로 정점 데이터를 정점 셰이더로
넘기는 방법은 정점 버퍼와 어트리뷰트(attribute)를 사용하는 방법입니다.</p>
<p>정점 버퍼는 다른 WebGPU 버퍼들과 다를 바 없습니다. 데이터를 저장하죠.
차이점이라면 정점 셰이더에서 직접 접근하지 않는다는 점입니다.
대신에, WebGPU에게 어떤 데이터가 버퍼에 있고, 어떤 구조로 저장되어 있는지 알려줍니다.
그런 다음 데이터를 버퍼로부터 가져와 전달해줍니다.</p>
<p><a href="webgpu-storage-buffers.html">지난 글</a>의 마지막 예제를 가져와서,
스토리지 버퍼 대신에 정점 버퍼를 사용하도록 수정해 보겠습니다.</p>
<p>먼저 셰이더부터 정점 버퍼로부터 정점 데이터를 가져오도록 수정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  offset: vec2f,
};

struct OtherStruct {
  scale: vec2f,
};

+struct Vertex {
+  @location(0) position: vec2f,
+};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
-@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;

@vertex fn vs(
-  @builtin(vertex_index) vertexIndex : u32,
+  vert: Vertex,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
-      pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+      vert.position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
  vsOut.color = ourStruct.color;
  return vsOut;
}

...
</pre>
<p>보신 것처럼 수정된 것이 별로 없습니다.
정점 데이터를 정의하는 <code class="notranslate" translate="no">Vertex</code> 구조체를 선언하였습니다.
중요한 부분은 position 필드를 <code class="notranslate" translate="no">@location(0)</code>로 선언한 부분입니다.</p>
<p>그리고 렌더 파이프라인을 만들 때, WebGPU에게 어떻게 <code class="notranslate" translate="no">@location(0)</code>에게 데이터를 전달해야 하는지 알려주어야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'vertex buffer pipeline',
    layout: 'auto',
    vertex: {
      module,
+      buffers: [
+        {
+          arrayStride: 2 * 4, // 2개 부동소수점 각각 4바이트
+          attributes: [
+            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
+          ],
+        },
+      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p><a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpipelinedescriptor"><code class="notranslate" translate="no">pipeline</code> 기술자(descriptor)</a>의 <a href="https://www.w3.org/TR/webgpu/#dictdef-gpuvertexstate"><code class="notranslate" translate="no">vertex</code></a>에 <code class="notranslate" translate="no">buffers</code> 배열을 추가하였습니다.
이는 하나 이상의 정점 버퍼로부터 데이터를 어떻게 가져올지를 명시합니다.
우리의 유일한 버퍼에 대해 <code class="notranslate" translate="no">arrayStride</code>를 바이트 단위로 명시하였습니다.
이 경우 <em>stride</em>는 버퍼에서 하나의 정점 데이터를 얻기 위해 얼마만큼의 바이트를 읽어야 하는지를 의미합니다.</p>
<div class="webgpu_center"><img src="../resources/vertex-buffer-one.svg" style="width: 1024px;"></div>
<p>우리 데이터는 <code class="notranslate" translate="no">vec2f</code>이므로 두 개의 float32 숫자이고, <code class="notranslate" translate="no">arrayStride</code>를 8로 설정합니다.</p>
<p>다음으로 어트리뷰트의 배열을 정의합니다. 지금은 요소가 하나입니다.
<code class="notranslate" translate="no">shaderLocation: 0</code>이 <code class="notranslate" translate="no">Vertex</code> 구조체의 <code class="notranslate" translate="no">location(0)</code>에 해당합니다.
<code class="notranslate" translate="no">offset: 0</code>은 이 어트리뷰트의 데이터가 정점 버퍼의 0바이트부터 시작한다는 의미입니다.
마지막으로 <code class="notranslate" translate="no">format: 'float32x2'</code>는 WebGPU가 버퍼로부터 두 개의 32비트 부동소수점으로 숫자를 읽어오라는 의미입니다.</p>
<p>버퍼의 usages를 <code class="notranslate" translate="no">STORAGE</code>에서 <code class="notranslate" translate="no">VERTEX</code>로 수정하고 바인드 그룹에서 제거합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const vertexStorageBuffer = device.createBuffer({
-    label: 'storage buffer vertices',
-    size: vertexData.byteLength,
-    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
-  });
+  const vertexBuffer = device.createBuffer({
+    label: 'vertex buffer vertices',
+    size: vertexData.byteLength,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
+  });
+  device.queue.writeBuffer(vertexBuffer, 0, vertexData);

  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: staticStorageBuffer }},
      { binding: 1, resource: { buffer: changingStorageBuffer }},
-      { binding: 2, resource: { buffer: vertexStorageBuffer }},
    ],
  });
</pre>
<p>그리고 그리기 시점에는 WebGPU에게 어떤 정점 버퍼를 사용할지 명시해주어야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
+    pass.setVertexBuffer(0, vertexBuffer);
</pre>
<p>여기서 <code class="notranslate" translate="no">0</code>은 위 렌더 파이프라인의 <code class="notranslate" translate="no">buffers</code> 배열의 요소를 가리키는 인덱스입니다.</p>
<p>이렇게 하면 정점에 대해 스토리지 버퍼에서 정점 버퍼로 바꾸는 과정이 완료됩니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>드로우 커맨드가 실행되는 시점의 상태는 아래 그림과 같을겁니다.</p>
<div class="webgpu_center"><img src="../resources/webgpu-draw-diagram-vertex-buffer.svg" style="width: 960px;"></div>
<p>어트리뷰트의 <code class="notranslate" translate="no">format</code> 필드는 아래 타입 중 하나입니다.</p>
<div class="webgpu_center data-table">
  <style>
    .vertex-type {
      text-align: center;
    }
  </style>
  <div>
  <table class="vertex-type">
    <thead>
     <tr>
      <th>Vertex format</th>
      <th>Data type</th>
      <th>Components</th>
      <th>Byte size</th>
      <th>Example WGSL type</th>
     </tr>
    </thead>
    <tbody>
      <tr><td><code class="notranslate" translate="no">"uint8x2"</code></td><td>unsigned int </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec2u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint8x4"</code></td><td>unsigned int </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec4u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint8x2"</code></td><td>signed int </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec2i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint8x4"</code></td><td>signed int </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec4i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm8x2"</code></td><td>unsigned normalized </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec2f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm8x4"</code></td><td>unsigned normalized </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec4f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm8x2"</code></td><td>signed normalized </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec2f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm8x4"</code></td><td>signed normalized </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec4f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint16x2"</code></td><td>unsigned int </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec2u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint16x4"</code></td><td>unsigned int </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec4u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint16x2"</code></td><td>signed int </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec2i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint16x4"</code></td><td>signed int </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec4i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm16x2"</code></td><td>unsigned normalized </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec2f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm16x4"</code></td><td>unsigned normalized </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec4f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm16x2"</code></td><td>signed normalized </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec2f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm16x4"</code></td><td>signed normalized </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec4f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float16x2"</code></td><td>float </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f16&gt;</code>, <code class="notranslate" translate="no">vec2h</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float16x4"</code></td><td>float </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f16&gt;</code>, <code class="notranslate" translate="no">vec4h</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32"</code></td><td>float </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">f32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x2"</code></td><td>float </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec2f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x3"</code></td><td>float </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec3f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x4"</code></td><td>float </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code>, <code class="notranslate" translate="no">vec4f</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32"</code></td><td>unsigned int </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">u32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x2"</code></td><td>unsigned int </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec2u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x3"</code></td><td>unsigned int </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec3u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x4"</code></td><td>unsigned int </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code>, <code class="notranslate" translate="no">vec4u</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32"</code></td><td>signed int </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">i32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x2"</code></td><td>signed int </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec2i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x3"</code></td><td>signed int </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec3i</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x4"</code></td><td>signed int </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code>, <code class="notranslate" translate="no">vec4i</code></td></tr>
    </tbody>
  </table>
  </div>
</div>
<h2 id="정점-버퍼를-사용한-인스턴싱"><a id="a-instancing"></a>정점 버퍼를 사용한 인스턴싱</h2>
<p>어트리뷰트는 정점별(per vertex)이나 인스턴스별(per instance)로 확장될 수 있습니다.
인스턴스별로 확장하는 것은 이전에 <code class="notranslate" translate="no">otherStructs[instanceIndex]</code>와 <code class="notranslate" translate="no">ourStructs[instanceIndex]</code>에서처럼 <code class="notranslate" translate="no">@builtin(instance_index)</code>로부터 <code class="notranslate" translate="no">instanceIndex</code>의 값을 가져오는 것과 동일합니다.</p>
<p>이전과 동일한 작업을 하기 위해 스토리지 버퍼 대신 정점 버퍼를 사용해 봅시다.
먼저 셰이더 쪽에서 스토리지 버퍼 대신 정점 어트리뷰를 사용하도록 수정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-struct OurStruct {
-  color: vec4f,
-  offset: vec2f,
-};
-
-struct OtherStruct {
-  scale: vec2f,
-};

struct Vertex {
  @location(0) position: vec2f,
+  @location(1) color: vec4f,
+  @location(2) offset: vec2f,
+  @location(3) scale: vec2f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

-@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
-@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;

@vertex fn vs(
  vert: Vertex,
-  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
-  let otherStruct = otherStructs[instanceIndex];
-  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
-  vsOut.position = vec4f(
-      vert.position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
-  vsOut.color = ourStruct.color;
+  vsOut.position = vec4f(
+      vert.position * vert.scale + vert.offset, 0.0, 1.0);
+  vsOut.color = vert.color;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color;
}
</pre>
<p>이제 렌더 파이프라인을, 해당 어트리뷰트들에 데이터를 어떻게 전달할건지를 알려주기 위해 수정해야 합니다.
최소한의 수정만 하기 위해 스토리지 버퍼에서 만든 데이터를 거의 그대로 사용할 것입니다.
하나의 버퍼에는 각 인스턴스의 <code class="notranslate" translate="no">color</code>와 <code class="notranslate" translate="no">offset</code> 값을, 하나의 버퍼에는 <code class="notranslate" translate="no">scale</code> 값을 갖도록 하려 총 두 개의 버퍼를 사용할 것입니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'flat colors',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
          ],
        },
+        {
+          arrayStride: 6 * 4, // 6 floats, 4 bytes each
+          stepMode: 'instance',
+          attributes: [
+            {shaderLocation: 1, offset:  0, format: 'float32x4'},  // color
+            {shaderLocation: 2, offset: 16, format: 'float32x2'},  // offset
+          ],
+        },
+        {
+          arrayStride: 2 * 4, // 2 floats, 4 bytes each
+          stepMode: 'instance',
+          attributes: [
+            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
+          ],
+        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p><code class="notranslate" translate="no">buffers</code> 배열에 두 개 요소를 추가하여 총 세 개의 버퍼를 갖게 되었습니다.
즉 WebGPU에 데이터를 세 개 버퍼로 전달할 것임을 알려준 것입니다.</p>
<p>두 개의 새로운 요소의 <code class="notranslate" translate="no">stepMode</code>를 <code class="notranslate" translate="no">instance</code>로 설정하였습니다.
이는 이 어트리뷰트는 인스턴스별로 새로운 값을 얻어온다는 의미입니다.
기본값은 <code class="notranslate" translate="no">stepMode: 'vertex'</code>인데 이는 정점별로 새로운 값을 얻어오는 것입니다 (그리고 각 인스턴스에서는 처음부터 읽기 시작).</p>
<p>두 개의 버퍼가 있습니다. <code class="notranslate" translate="no">scale</code>만 가지고 있는 버퍼는 간단합니다.
<code class="notranslate" translate="no">position</code> 값을 갖는 버퍼와 마찬가지로 정점마다 두 개의 32비트 부동소수점 값을 갖습니다.</p>
<p><code class="notranslate" translate="no">color</code>와 <code class="notranslate" translate="no">offset</code>을 갖는 다른 버퍼는 아래와 같이 데이터가 엮어지게 될겁니다.</p>
<div class="webgpu_center"><img src="../resources/vertex-buffer-f32x4-f32x2.svg" style="width: 1024px;"></div>
<p>따라서 위해서 다음 데이터를 얻기 위해 건너야 하는 바이트인 <code class="notranslate" translate="no">arrayStride</code>를 <code class="notranslate" translate="no">6 * 4</code>, 즉 여섯 개의 32비트 부동소수점(4바이트)로 설정하였습니다.
<code class="notranslate" translate="no">color</code>는 0바이트부터 읽기 시작하지만 <code class="notranslate" translate="no">offset</code>은 16바이트부터 읽기 시작해야 합니다.</p>
<p>다음으로 버퍼를 설정하는 코드를 수정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // create 2 storage buffers
  const staticUnitSize =
    4 * 4 + // color is 4 32bit floats (4bytes each)
-    2 * 4 + // offset is 2 32bit floats (4bytes each)
-    2 * 4;  // padding
+    2 * 4;  // offset is 2 32bit floats (4bytes each)

  const changingUnitSize =
    2 * 4;  // scale is 2 32bit floats (4bytes each)
*  const staticVertexBufferSize = staticUnitSize * kNumObjects;
*  const changingVertexBufferSize = changingUnitSize * kNumObjects;

*  const staticVertexBuffer = device.createBuffer({
*    label: 'static vertex for objects',
*    size: staticVertexBufferSize,
-    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

*  const changingVertexBuffer = device.createBuffer({
*    label: 'changing vertex for objects',
*    size: changingVertexBufferSize,
-    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

</pre>
<p>정점 어트리뷰트는 스토리지 버퍼의 구조체와 동일한 패딩(padding) 제약을 갖지는 않으니 여기서는 패딩은 필요 없습니다.
이 외에는 <code class="notranslate" translate="no">STORAGE</code>를 <code class="notranslate" translate="no">VERTEX</code>로 수정한 것 밖에는 없습니다 (변수 이름도</p>
<p>이제 스토리지 버퍼는 사용하지 않으니 바인드그룹도 사용할 필요가 없습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const bindGroup = device.createBindGroup({
-    label: 'bind group for objects',
-    layout: pipeline.getBindGroupLayout(0),
-    entries: [
-      { binding: 0, resource: { buffer: staticStorageBuffer }},
-      { binding: 1, resource: { buffer: changingStorageBuffer }},
-    ],
-  });
</pre>
<p>마지막으로, 바인드그룹을 설정할 필요는 없지만 정점 버퍼 설정은 해 주어야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
+    pass.setVertexBuffer(1, staticVertexBuffer);
+    pass.setVertexBuffer(2, changingVertexBuffer);

    ...
-    pass.setBindGroup(0, bindGroup);
    pass.draw(numVertices, kNumObjects);

    pass.end();
</pre>
<p>여기서 <code class="notranslate" translate="no">setVertexBuffer</code>의 첫 번째 매개변수가 파이프라인에서의 <code class="notranslate" translate="no">buffers</code> 배열의 요소와 대응됩니다.</p>
<p>이로써 이전과 동일한 결과를, 스토리지 버퍼 없이 정점 버퍼만을 사용해서 얻을 수 있습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-instanced-colors"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-instanced-colors" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>정점별 색상을 위한 또다른 어트리뷰트를 재미로 추가해 봅시다. 먼저 셰이더를 수정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
  @location(1) color: vec4f,
  @location(2) offset: vec2f,
  @location(3) scale: vec2f,
+  @location(4) perVertexColor: vec3f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@vertex fn vs(
  vert: Vertex,
) -&gt; VSOutput {
  var vsOut: VSOutput;
  vsOut.position = vec4f(
      vert.position * vert.scale + vert.offset, 0.0, 1.0);
-  vsOut.color = vert.color;
+  vsOut.color = vert.color * vec4f(vert.perVertexColor, 1);
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color;
}
</pre>
<p>그리고 파이프라인을 업데이트하여 어떻게 데이터를 전달할 것인지 명시합니다.
perVertexColor 데이터를 아래와 같이 엮을 것입니다.</p>
<div class="webgpu_center"><img src="../resources/vertex-buffer-mixed.svg" style="width: 1024px;"></div>
<p>따라서 <code class="notranslate" translate="no">arrayStride</code>가 우리의 새로운 데이터를 포함하도록 수정되어야 하고, 새로운 어트리뷰트를 추가해야 합니다.
두 개의 32비트 부동소수점을 건너뛴 뒤에 데이터가 시작하므로 <code class="notranslate" translate="no">offset</code>은 8바이트입니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'per vertex color',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: 2 * 4, // 2 floats, 4 bytes each
+          arrayStride: 5 * 4, // 5 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
+            {shaderLocation: 4, offset: 8, format: 'float32x3'},  // perVertexColor
          ],
        },
        {
          arrayStride: 6 * 4, // 6 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 1, offset:  0, format: 'float32x4'},  // color
            {shaderLocation: 2, offset: 16, format: 'float32x2'},  // offset
          ],
        },
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>원을 그리는 정점을 생성하는 코드를 수정하여 바깥쪽 정점은 어두운 색, 안쪽 정점은 밝은 색이 되도록 수정합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // subdivision마다 두 개의 삼각형, 삼각형마다 세 개의 정점, 각 정점은 (xyrgb) 세 개의 값
  const numVertices = numSubdivisions * 3 * 2;
-  const vertexData = new Float32Array(numVertices * 2);
+  const vertexData = new Float32Array(numVertices * (2 + 3));

  let offset = 0;
-  const addVertex = (x, y) =&gt; {
+  const addVertex = (x, y, r, g, b) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
+    vertexData[offset++] = r;
+    vertexData[offset++] = g;
+    vertexData[offset++] = b;
  };

+  const innerColor = [1, 1, 1];
+  const outerColor = [0.1, 0.1, 0.1];

  // 2 triangles per subdivision
  //
  // 0--1 4
  // | / /|
  // |/ / |
  // 2 3--5
  for (let i = 0; i &lt; numSubdivisions; ++i) {
    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;

    const c1 = Math.cos(angle1);
    const s1 = Math.sin(angle1);
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);

    // first triangle
-    addVertex(c1 * radius, s1 * radius);
-    addVertex(c2 * radius, s2 * radius);
-    addVertex(c1 * innerRadius, s1 * innerRadius);
+    addVertex(c1 * radius, s1 * radius, ...outerColor);
+    addVertex(c2 * radius, s2 * radius, ...outerColor);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-
-    // second triangle
-    addVertex(c1 * innerRadius, s1 * innerRadius);
-    addVertex(c2 * radius, s2 * radius);
-    addVertex(c2 * innerRadius, s2 * innerRadius);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
+    addVertex(c2 * radius, s2 * radius, ...outerColor);
+    addVertex(c2 * innerRadius, s2 * innerRadius, ...innerColor);
  }

  return {
    vertexData,
    numVertices,
  };
}
</pre>
<p>이렇게 하면 아래와 같은 원을 그릴 수 있습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-per-vertex-colors.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-per-vertex-colors.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<h2 id="wgsl의-어트리뷰트와-자바스크립트-어트리뷰트가-매칭될-필요는-없습니다"><a id="a-default-values"></a>WGSL의 어트리뷰트와 자바스크립트 어트리뷰트가 매칭될 필요는 없습니다</h2>
<p>위에서 <code class="notranslate" translate="no">perVertexColor</code> 어트리뷰트를 <code class="notranslate" translate="no">vec3f</code> 타입으로 아래와 같이 선언했습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
  @location(1) color: vec4f,
  @location(2) offset: vec2f,
  @location(3) scale: vec2f,
*  @location(4) perVertexColor: vec3f,
};
</pre>
<p>그리고 아래와 같이 사용했죠.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@vertex fn vs(
  vert: Vertex,
) -&gt; VSOutput {
  var vsOut: VSOutput;
  vsOut.position = vec4f(
      vert.position * vert.scale + vert.offset, 0.0, 1.0);
*  vsOut.color = vert.color * vec4f(vert.perVertexColor, 1);
  return vsOut;
}
</pre>
<p><code class="notranslate" translate="no">vec4f</code>로 선언하고 아래와 같이 사용할 수도 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Vertex {
  @location(0) position: vec2f,
  @location(1) color: vec4f,
  @location(2) offset: vec2f,
  @location(3) scale: vec2f,
-  @location(4) perVertexColor: vec3f,
+  @location(4) perVertexColor: vec4f,
};

...

@vertex fn vs(
  vert: Vertex,
) -&gt; VSOutput {
  var vsOut: VSOutput;
  vsOut.position = vec4f(
      vert.position * vert.scale + vert.offset, 0.0, 1.0);
-  vsOut.color = vert.color * vec4f(vert.perVertexColor, 1);
+  vsOut.color = vert.color * vert.perVertexColor;
  return vsOut;
}
</pre>
<p>그리고 나머지는 수정하지 않습니다. 자바스크립트 쪽을 보면 우리는 여전히 정점별로 세 개의 부동소수점으로 데이터를 전달하는 것을 볼 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    {
      arrayStride: 5 * 4, // 5 floats, 4 bytes each
      attributes: [
        {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
*        {shaderLocation: 4, offset: 8, format: 'float32x3'},  // perVertexColor
      ],
    },
</pre>
<p>셰이더에서 어트리뷰트는 항상 네 개의 값을 가지기 때문에 이와 같이 해도 문제 없습니다.
기본값은 <code class="notranslate" translate="no">0, 0, 0, 1</code>이고, 우리가 전달하지 않은 요소에 대해서는 이러한 기본값을 사용합니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-per-vertex-colors-3-in-4-out.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-per-vertex-colors-3-in-4-out.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<h2 id="공간-절약을-위한-정규화된normalized-값의-사용"><a id="a-normalized-attributes"></a>공간 절약을 위한 정규화된(normalized) 값의 사용</h2>
<p>색상값으로 32비트 부동소수점 값을 사용했습니다.
각 <code class="notranslate" translate="no">perVertexColor</code>는 세 개의 값이니, 정점별로 총 12바이트를 사용하고 있습니다.
<code class="notranslate" translate="no">color</code>는 네 개의 값이니 인스턴스별로는 16바이트입니다.</p>
<p>8비트 값을 사용하여 이를 최적화 하고 WebGPU에게 0 ↔ 255 값을 0.0 ↔ 1.0로 정규화해서 사용하라고 할 수 있습니다.</p>
<p>사용 가능한 어트리뷰트 포맷 목록을 보면 8비트 3개는 없지만 <code class="notranslate" translate="no">'unorm8x4'</code>가 있으니 이를 사용합시다.</p>
<p>먼저 정점을 생성하는 코드를 수정해서, 나중에 정규화될 색상 데이터를 8비트 값으로 출력하게 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
-  // 2 triangles per subdivision, 3 verts per tri, 5 values (xyrgb) each.
+  // 2 triangles per subdivision, 3 verts per tri
  const numVertices = numSubdivisions * 3 * 2;
-  const vertexData = new Float32Array(numVertices * (2 + 3));
+  // 2 32-bit values for position (xy) and 1 32-bit value for color (rgb_)
+  // The 32-bit color value will be written/read as 4 8-bit values
+  const vertexData = new Float32Array(numVertices * (2 + 1));
+  const colorData = new Uint8Array(vertexData.buffer);

  let offset = 0;
+  let colorOffset = 8;
  const addVertex = (x, y, r, g, b) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
-    vertexData[offset++] = r;
-    vertexData[offset++] = g;
-    vertexData[offset++] = b;
+    offset += 1;  // skip the color
+    colorData[colorOffset++] = r * 255;
+    colorData[colorOffset++] = g * 255;
+    colorData[colorOffset++] = b * 255;
+    colorOffset += 9;  // skip extra byte and the position
  };
</pre>
<p><code class="notranslate" translate="no">vertexData</code> 데이터와 동일한 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code class="notranslate" translate="no">Uint8Array</code></a> 뷰(view)인 <code class="notranslate" translate="no">colorData</code>를 만들었습니다.</p>
<p>그리고 <code class="notranslate" translate="no">colorData</code>에 0 ↔ 1를 0 ↔ 255로 확장하여 색상값을 넣습니다.</p>
<p>이 데이터의 메모리 레이아웃은 아래와 같습니다.</p>
<div class="webgpu_center"><img src="../resources/vertex-buffer-f32x2-u8x4.svg" style="width: 1024px;"></div>
<p>인스턴스별 데이터로 업데이트해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNumObjects = 100;
  const objectInfos = [];

  // create 2 vertex buffers
  const staticUnitSize =
-    4 * 4 + // color is 4 32bit floats (4bytes each)
+    4 +     // color is 4 bytes
    2 * 4;  // offset is 2 32bit floats (4bytes each)
  const changingUnitSize =
    2 * 4;  // scale is 2 32bit floats (4bytes each)
  const staticVertexBufferSize = staticUnitSize * kNumObjects;
  const changingVertexBufferSize = changingUnitSize * kNumObjects;

  const staticVertexBuffer = device.createBuffer({
    label: 'static vertex for objects',
    size: staticVertexBufferSize,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

  const changingVertexBuffer = device.createBuffer({
    label: 'changing storage for objects',
    size: changingVertexBufferSize,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });

  // offsets to the various uniform values in float32 indices
  const kColorOffset = 0;
-  const kOffsetOffset = 4;
+  const kOffsetOffset = 1;

  const kScaleOffset = 0;

  {
-    const staticVertexValues = new Float32Array(staticVertexBufferSize / 4);
+    const staticVertexValuesU8 = new Uint8Array(staticVertexBufferSize);
+    const staticVertexValuesF32 = new Float32Array(staticVertexValuesU8.buffer);
    for (let i = 0; i &lt; kNumObjects; ++i) {
-      const staticOffset = i * (staticUnitSize / 4);
+      const staticOffsetU8 = i * staticUnitSize;
+      const staticOffsetF32 = staticOffsetU8 / 4;

      // These are only set once so set them now
-      staticVertexValues.set([rand(), rand(), rand(), 1], staticOffset + kColorOffset);        // set the color
-      staticVertexValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], staticOffset + kOffsetOffset);      // set the offset
+      staticVertexValuesU8.set(        // set the color
+          [rand() * 255, rand() * 255, rand() * 255, 255],
+          staticOffsetU8 + kColorOffset);
+
+      staticVertexValuesF32.set(      // set the offset
+          [rand(-0.9, 0.9), rand(-0.9, 0.9)],
+          staticOffsetF32 + kOffsetOffset);

      objectInfos.push({
        scale: rand(0.2, 0.5),
      });
    }
-    device.queue.writeBuffer(staticVertexBuffer, 0, staticVertexValues);
+    device.queue.writeBuffer(staticVertexBuffer, 0, staticVertexValuesF32);
  }
</pre>
<p>인스턴스별 데이터의 레이아웃은 아래와 같습니다.</p>
<div class="webgpu_center"><img src="../resources/vertex-buffer-u8x4-f32x2.svg" style="width: 1024px;"></div>
<p>이제 파이프라인을 수정하여 데이터를 8비트 부호없는 정수로 가져오고 0 ↔ 1로 정규화하도록 해야 하고, offset과 stride로 새로운 크기에 맞춰 수정해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'per vertex color',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
-          arrayStride: 5 * 4, // 5 floats, 4 bytes each
+          arrayStride: 2 * 4 + 4, // 2 floats, 4 bytes each + 4 bytes
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
-            {shaderLocation: 4, offset: 8, format: 'float32x3'},  // perVertexColor
+            {shaderLocation: 4, offset: 8, format: 'unorm8x4'},   // perVertexColor
          ],
        },
        {
-          arrayStride: 6 * 4, // 6 floats, 4 bytes each
+          arrayStride: 4 + 2 * 4, // 4 bytes + 2 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
-            {shaderLocation: 1, offset:  0, format: 'float32x4'},  // color
-            {shaderLocation: 2, offset: 16, format: 'float32x2'},  // offset
+            {shaderLocation: 1, offset: 0, format: 'unorm8x4'},   // color
+            {shaderLocation: 2, offset: 4, format: 'float32x2'},  // offset
          ],
        },
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          stepMode: 'instance',
          attributes: [
            {shaderLocation: 3, offset: 0, format: 'float32x2'},   // scale
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>이렇게 하여 공간을 조금 아꼈습니다. 이전에는 정점별로 20바이트를 사용했으나 이제는 12바이트만을 사용합니다. 40%의 절약이죠.
그리고 인스턴스별로는 24바이트를 사용했는데 12바이트를 사용하니 50% 절약입니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-8bit-colors.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-8bit-colors.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>구조체를 꼭 사용할 필요는 없다는 점을 명심하세요. 아래와 같이 해도 잘 동작합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-WGSL" translate="no">@vertex fn vs(
-  vert: Vertex,
+  @location(0) position: vec2f,
+  @location(1) color: vec4f,
+  @location(2) offset: vec2f,
+  @location(3) scale: vec2f,
+  @location(4) perVertexColor: vec3f,
) -&gt; VSOutput {
  var vsOut: VSOutput;
-  vsOut.position = vec4f(
-      vert.position * vert.scale + vert.offset, 0.0, 1.0);
-  vsOut.color = vert.color * vec4f(vert.perVertexColor, 1);
+  vsOut.position = vec4f(
+      position * scale + offset, 0.0, 1.0);
+  vsOut.color = color * vec4f(perVertexColor, 1);
  return vsOut;
}
</pre>
<p>WebGPU가 신경쓰는 것은 오직 우리가 셰이더에서 <code class="notranslate" translate="no">locations</code>로 명시한 것들에 대해 API를 통해 제대로 데이터를 전달했는지 뿐입니다.</p>
<h2 id="인덱스index-버퍼"><a id="a-index-buffers"></a>인덱스(index) 버퍼</h2>
<p>마지막으로 다룰 것은 인덱스 버퍼입니다.
인덱스 버퍼는 정점의 처리와 사용 순서를 명시합니다.</p>
<p><code class="notranslate" translate="no">draw</code>를 아래와 같은 순서로 정점을 처리하는 것으로 생각할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">0, 1, 2, 3, 4, 5, .....
</pre>
<p>인덱스 버퍼를 사용하면 순서를 바꿀 수 있습니다.</p>
<p>원을 그릴 때 subdivision마다 6개의 정점을 만들고 있는데 사실 그 중 두 개는 동일한 정점입니다.</p>
<div class="webgpu_center"><img src="../resources/vertices-non-indexed.svg" style="width: 400px"></div>  
<p>이제, 정점은 네 개만 생성하고 대신 그 네 개의 정점을 여섯 번 사용하도록 할 것입니다.
이는 WebGPU에게 아래와 같은 순서로 그리도록 인덱스를 명시함으로써 가능합니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">0, 1, 2, 2, 1, 3, ...
</pre>
<div class="webgpu_center"><img src="../resources/vertices-indexed.svg" style="width: 400px"></div>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
-  // 2 triangles per subdivision, 3 verts per tri
-  const numVertices = numSubdivisions * 3 * 2;
+  // 2 vertices at each subdivision, + 1 to wrap around the circle.
+  const numVertices = (numSubdivisions + 1) * 2;
  // 2 32-bit values for position (xy) and 1 32-bit value for color (rgb)
  // The 32-bit color value will be written/read as 4 8-bit values
  const vertexData = new Float32Array(numVertices * (2 + 1));
  const colorData = new Uint8Array(vertexData.buffer);

  let offset = 0;
  let colorOffset = 8;
  const addVertex = (x, y, r, g, b) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
    offset += 1;  // skip the color
    colorData[colorOffset++] = r * 255;
    colorData[colorOffset++] = g * 255;
    colorData[colorOffset++] = b * 255;
    colorOffset += 9;  // skip extra byte and the position
  };
  const innerColor = [1, 1, 1];
  const outerColor = [0.1, 0.1, 0.1];

-  // 2 triangles per subdivision
-  //
-  // 0--1 4
-  // | / /|
-  // |/ / |
-  // 2 3--5
-  for (let i = 0; i &lt; numSubdivisions; ++i) {
-    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
-    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;
-
-    const c1 = Math.cos(angle1);
-    const s1 = Math.sin(angle1);
-    const c2 = Math.cos(angle2);
-    const s2 = Math.sin(angle2);
-
-    // first triangle
-    addVertex(c1 * radius, s1 * radius, ...outerColor);
-    addVertex(c2 * radius, s2 * radius, ...outerColor);
-    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-
-    // second triangle
-    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-    addVertex(c2 * radius, s2 * radius, ...outerColor);
-    addVertex(c2 * innerRadius, s2 * innerRadius, ...innerColor);
-  }
+  // 2 triangles per subdivision
+  //
+  // 0  2  4  6  8 ...
+  //
+  // 1  3  5  7  9 ...
+  for (let i = 0; i &lt;= numSubdivisions; ++i) {
+    const angle = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
+
+    const c1 = Math.cos(angle);
+    const s1 = Math.sin(angle);
+
+    addVertex(c1 * radius, s1 * radius, ...outerColor);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
+  }

+  const indexData = new Uint32Array(numSubdivisions * 6);
+  let ndx = 0;
+
+  // 1st tri  2nd tri  3rd tri  4th tri
+  // 0 1 2    2 1 3    2 3 4    4 3 5
+  //
+  // 0--2        2     2--4        4  .....
+  // | /        /|     | /        /|
+  // |/        / |     |/        / |
+  // 1        1--3     3        3--5  .....
+  for (let i = 0; i &lt; numSubdivisions; ++i) {
+    const ndxOffset = i * 2;
+
+    // first triangle
+    indexData[ndx++] = ndxOffset;
+    indexData[ndx++] = ndxOffset + 1;
+    indexData[ndx++] = ndxOffset + 2;
+
+    // second triangle
+    indexData[ndx++] = ndxOffset + 2;
+    indexData[ndx++] = ndxOffset + 1;
+    indexData[ndx++] = ndxOffset + 3;
+  }

  return {
    vertexData,
    colorData,
+    indexData,
    numVertices: indexData.length,
  };
}
</pre>
<p>그리고 인덱스 버퍼를 만듭니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const { vertexData, numVertices } = createCircleVertices({
+  const { vertexData, indexData, numVertices } = createCircleVertices({
    radius: 0.5,
    innerRadius: 0.25,
  });
  const vertexBuffer = device.createBuffer({
    label: 'vertex buffer',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
+  const indexBuffer = device.createBuffer({
+    label: 'index buffer',
+    size: indexData.byteLength,
+    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
+  });
+  device.queue.writeBuffer(indexBuffer, 0, indexData);
</pre>
<p>usage를 <code class="notranslate" translate="no">INDEX</code>로 설정한 것에 주목하세요.</p>
<p>그리고 그리기 시점에는 인덱스 버퍼를 명시해 줍니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.setVertexBuffer(1, staticVertexBuffer);
    pass.setVertexBuffer(2, changingVertexBuffer);
+    pass.setIndexBuffer(indexBuffer, 'uint32');
</pre>
<p>버퍼가 32비트 부호없는 정수 인덱스기 때문에 <code class="notranslate" translate="no">'uint32'</code>를 전달해야 합니다.
16비트 부호없는 정수를 사용할 수도 있는데 이 경우에는 <code class="notranslate" translate="no">'uint16'</code>를 전달합니다.</p>
<p>그리고 <code class="notranslate" translate="no">draw</code> 대신 <code class="notranslate" translate="no">drawIndexed</code>를 호출해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    pass.draw(numVertices, kNumObjects);
+    pass.drawIndexed(numVertices, kNumObjects);
</pre>
<p>이렇게 하면 공간을 절약할 수 있고(33%), 그만큼의 처리 시간도 절약할 수 있는데
정점 셰이더에서 정점에 대한 계산을 수행할 때 GPU가 이미 계산된 값을 재사용 할 수 있기 때문입니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-index-buffer.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-index-buffer.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p><a href="webgpu-storage-buffers.html">이전 글</a>의 예제에서 스토리지 버퍼와 인덱스 버퍼를 사용할 수도 있었음을 명심하세요.
이러한 경우 <code class="notranslate" translate="no">@builtin(vertex_index)</code>로 넘어오는 값은 인덱스 버퍼의 인덱스 순서와 같습니다.</p>
<p>다음으로 <a href="webgpu-textures.html">텍스처</a>에 대해 다뤄보겠습니다.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-vertex-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-vertex-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-vertex-buffers.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-vertex-buffers.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-vertex-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-vertex-buffers.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">스테이지간 변수(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">스토리지 버퍼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">정점 버퍼</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">이미지 로딩</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">비디오 사용하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">큐브맵(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">상수(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">데이터 메모리 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">데이터 복사하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">선택적 기능(optional feature)과 제한(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">동작 방식</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D 수학</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>컴퓨트 셰이더</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">컴퓨트 셰이더 기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>질문이 있나요? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>에 물어보세요.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">제안</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">요청 사항</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">이슈</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">버그</a>
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 정점 버퍼`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님<br> 당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여에 감사드립니다.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>