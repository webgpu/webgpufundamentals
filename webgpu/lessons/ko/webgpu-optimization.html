<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-optimization.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPUì—ì„œ ë” ë¹ ë¥´ê²Œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-optimization_ko.jpg">

<meta property="og:title" content="WebGPU ì†ë„ì™€ ìµœì í™”">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-optimization_ko.jpg">
<meta property="og:description" content="WebGPUì—ì„œ ë” ë¹ ë¥´ê²Œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU ì†ë„ì™€ ìµœì í™”">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html">
<meta name="twitter:description" content="WebGPUì—ì„œ ë” ë¹ ë¥´ê²Œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-optimization_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-optimization_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html",
      "inLanguage":"ko",
      "name":"WebGPU ì†ë„ì™€ ìµœì í™”",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-optimization.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU ì†ë„ì™€ ìµœì í™”</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-optimization.html">English
    </option><option value="/webgpu/lessons/es/webgpu-optimization.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-optimization.html">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-optimization.html" selected="">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-optimization.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-optimization.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-optimization.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-optimization.html">ç®€ä½“ä¸­æ–‡
</option></select>


    <a href="#toc">ëª©ì°¨</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU ì†ë„ì™€ ìµœì í™”</h1>
  </div>
  <div id="need-newer-webgpu" style="display: none">
    <div>This browser is missing a few WebGPU features. Please update your browser.</div>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>ì´ ì‚¬ì´íŠ¸ì˜ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œëŠ” ê°€ëŠ¥í•œ í•œ ì´í•´í•˜ê¸° ì‰½ê²Œ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
ì¦‰, ì‘ë™í•˜ê³  ì •í™•í•˜ì§€ë§Œ WebGPUì—ì„œ ë¬´ì–¸ê°€ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê°€ì¥ íš¨ìœ¨ì ì¸ ë°©ë²•ì„
ë°˜ë“œì‹œ ë³´ì—¬ì£¼ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ë˜í•œ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ì‘ì—…ì— ë”°ë¼ ìˆ˜ë§ì€ ìµœì í™”
ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.</p>
<p>ì´ ê¸€ì—ì„œëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ìµœì í™” ë°©ë²•ì„ ë‹¤ë£¨ê³  ëª‡ ê°€ì§€ ë‹¤ë¥¸ ë°©ë²•ì— ëŒ€í•´
ë…¼ì˜í•  ê²ƒì…ë‹ˆë‹¤. ë¶„ëª…íˆ ë§í•˜ìë©´, ì œ ìƒê°ì—ëŠ” <strong>ì¼ë°˜ì ìœ¼ë¡œ ì´ ì •ë„ê¹Œì§€ í• 
í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤. WebGPUë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œëŠ” ìˆ˜ë°± ê°œì˜ ë¬¼ì²´ë¥¼ ê·¸ë¦¬ë¯€ë¡œ
ì´ëŸ¬í•œ ìµœì í™”ì˜ ì´ì ì„ ì‹¤ì œë¡œ ì–»ì§€ ëª»í•  ê²ƒì…ë‹ˆë‹¤</strong>. ê·¸ë˜ë„ ë” ë¹ ë¥´ê²Œ ë§Œë“œëŠ”
ë°©ë²•ì„ ì•„ëŠ” ê²ƒì€ í•­ìƒ ì¢‹ìŠµë‹ˆë‹¤.</p>
<p>ê¸°ë³¸ ì›ì¹™: <strong>ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì´ ì ì„ìˆ˜ë¡, WebGPUì— ìš”ì²­í•˜ëŠ” ì‘ì—…ì´ ì ì„ìˆ˜ë¡
ë” ë¹ ë¥´ê²Œ ì‹¤í–‰ë©ë‹ˆë‹¤.</strong></p>
<p>ì§€ê¸ˆê¹Œì§€ì˜ ê±°ì˜ ëª¨ë“  ì˜ˆì œì—ì„œ ì—¬ëŸ¬ ë„í˜•ì„ ê·¸ë¦´ ë•Œ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.</p>
<ul>
<li>
<p>ì´ˆê¸°í™” ì‹œ:</p>
<ul>
<li>ê·¸ë¦¬ë ¤ëŠ” ê° ë¬¼ì²´ì— ëŒ€í•´
<ul>
<li>ìœ ë‹ˆí¼ ë²„í¼ ìƒì„±</li>
<li>í•´ë‹¹ ë²„í¼ë¥¼ ì°¸ì¡°í•˜ëŠ” bindGroup ìƒì„±</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ë Œë”ë§ ì‹œ:</p>
<ul>
<li>ì¸ì½”ë”ì™€ ë Œë” íŒ¨ìŠ¤ ì‹œì‘</li>
<li>ê·¸ë¦¬ë ¤ëŠ” ê° ë¬¼ì²´ì— ëŒ€í•´
<ul>
<li>ì´ ê°ì²´ì˜ ìœ ë‹ˆí¼ ê°’ìœ¼ë¡œ íƒ€ì… ë°°ì—´ ì—…ë°ì´íŠ¸</li>
<li>íƒ€ì… ë°°ì—´ì„ ì´ ê°ì²´ì˜ ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬</li>
<li>í•„ìš”í•œ ê²½ìš° íŒŒì´í”„ë¼ì¸, ì •ì  ë° ì¸ë±ìŠ¤ ë²„í¼ ì„¤ì •</li>
<li>ì´ ê°ì²´ì˜ bindGroup(s)ì„ ë°”ì¸ë”©í•˜ëŠ” ëª…ë ¹ ì¸ì½”ë”©</li>
<li>ê·¸ë¦¬ê¸° ëª…ë ¹ ì¸ì½”ë”©</li>
</ul>
</li>
<li>ë Œë” íŒ¨ìŠ¤ ì¢…ë£Œ, ì¸ì½”ë” ì™„ë£Œ, ì»¤ë§¨ë“œ ë²„í¼ ì œì¶œ</li>
</ul>
</li>
</ul>
<p>ìœ„ì˜ ë‹¨ê³„ë¥¼ ë”°ë¥´ëŠ” ìµœì í™”í•  ìˆ˜ ìˆëŠ” ì˜ˆì œë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<p>ì°¸ê³ ë¡œ, ì´ê²ƒì€ ê°€ì§œ ì˜ˆì œì…ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ë‹¨ì§€ ë§ì€ íë¸Œë¥¼ ê·¸ë¦´ ê²ƒì´ê³ ,
ë”°ë¼ì„œ <a href="webgpu-storage-buffers.html#a-instancing">ìŠ¤í† ë¦¬ì§€ ë²„í¼</a>ì™€
<a href="webgpu-vertex-buffers.html#a-instancing">ì •ì  ë²„í¼</a>ì— ê´€í•œ ê¸€ì—ì„œ
ë‹¤ë£¬ <em>ì¸ìŠ¤í„´ì‹±</em>ì„ ì‚¬ìš©í•˜ì—¬ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ê°ì²´ë¥¼
ì²˜ë¦¬í•˜ëŠ” ì½”ë“œë¡œ ë³µì¡í•˜ê²Œ ë§Œë“¤ê³  ì‹¶ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì¸ìŠ¤í„´ì‹±ì€ í”„ë¡œì íŠ¸ì—ì„œ
ë™ì¼í•œ ëª¨ë¸ì„ ë§ì´ ì‚¬ìš©í•˜ëŠ” ê²½ìš° í™•ì‹¤íˆ í›Œë¥­í•œ ìµœì í™” ë°©ë²•ì…ë‹ˆë‹¤.
ì‹ë¬¼, ë‚˜ë¬´, ë°”ìœ„, ì“°ë ˆê¸° ë“±ì€ ì¢…ì¢… ì¸ìŠ¤í„´ì‹±ì„ ì‚¬ìš©í•˜ì—¬ ìµœì í™”ë©ë‹ˆë‹¤.
ë‹¤ë¥¸ ëª¨ë¸ì˜ ê²½ìš° ëœ ì¼ë°˜ì ì…ë‹ˆë‹¤.</p>
<p>ì˜ˆë¥¼ ë“¤ì–´ í…Œì´ë¸” ì£¼ìœ„ì— 4ê°œ, 6ê°œ ë˜ëŠ” 8ê°œì˜ ì˜ìê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë©°
ì¸ìŠ¤í„´ì‹±ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ì˜ìë¥¼ ê·¸ë¦¬ëŠ” ê²ƒì´ ë” ë¹ ë¥¼ ê²ƒì…ë‹ˆë‹¤.
í•˜ì§€ë§Œ ê·¸ë¦´ ê²ƒì´ 500ê°œ ì´ìƒì¸ ëª©ë¡ì—ì„œ ì˜ìë§Œ ì˜ˆì™¸ì¸ ê²½ìš° ì–´ë–»ê²Œë“ 
ì˜ìë¥¼ ì¸ìŠ¤í„´ì‹±ì„ ì‚¬ìš©í•˜ë„ë¡ êµ¬ì„±í•˜ì§€ë§Œ ë‹¤ë¥¸ ìƒí™©ì—ì„œëŠ” ì¸ìŠ¤í„´ì‹±ì„
ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ìµœì ì˜ ë°ì´í„° êµ¬ì„±ì„ ì°¾ì•„ë‚´ëŠ” ë…¸ë ¥ì€ ì•„ë§ˆë„ ê°€ì¹˜ê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤.</p>
<p>ìœ„ ë‹¨ë½ì˜ ìš”ì ì€ ì ì ˆí•œ ê²½ìš° ì¸ìŠ¤í„´ì‹±ì„ ì‚¬ìš©í•˜ë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ë™ì¼í•œ ê²ƒì„
ìˆ˜ë°± ê°œ ì´ìƒ ê·¸ë¦´ ê²½ìš° ì¸ìŠ¤í„´ì‹±ì´ ì ì ˆí•  ê²ƒì…ë‹ˆë‹¤. ë™ì¼í•œ ê²ƒì„ ëª‡ ê°œë§Œ
ê·¸ë¦´ ê²½ìš° ê·¸ ëª‡ ê°€ì§€ë¥¼ íŠ¹ë³„íˆ ì²˜ë¦¬í•˜ëŠ” ë…¸ë ¥ì€ ì•„ë§ˆë„ ê°€ì¹˜ê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤.</p>
<p>ì–´ì¨Œë“ , ì½”ë“œê°€ ìˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©í•´ ì˜¨ ì´ˆê¸°í™” ì½”ë“œì…ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter({
    powerPreference: 'high-performance',
  });
  const device = await adapter?.requestDevice();
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }

  // ìº”ë²„ìŠ¤ì—ì„œ WebGPU ì»¨í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì™€ ì„¤ì •í•©ë‹ˆë‹¤
  const canvas = document.querySelector('canvas');
  const context = canvas.getContext('webgpu');
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device,
    format: presentationFormat,
  });
</pre>
<p>ë‹¤ìŒìœ¼ë¡œ ì…°ì´ë” ëª¨ë“ˆì„ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    code: /* wgsl */ `
      struct Uniforms {
        normalMatrix: mat3x3f,
        viewProjection: mat4x4f,
        world: mat4x4f,
        color: vec4f,
        lightWorldPosition: vec3f,
        viewWorldPosition: vec3f,
        shininess: f32,
      };

      struct Vertex {
        @location(0) position: vec4f,
        @location(1) normal: vec3f,
        @location(2) texcoord: vec2f,
      };

      struct VSOutput {
        @builtin(position) position: vec4f,
        @location(0) normal: vec3f,
        @location(1) surfaceToLight: vec3f,
        @location(2) surfaceToView: vec3f,
        @location(3) texcoord: vec2f,
      };

      @group(0) @binding(0) var diffuseTexture: texture_2d&lt;f32&gt;;
      @group(0) @binding(1) var diffuseSampler: sampler;
      @group(0) @binding(2) var&lt;uniform&gt; uni: Uniforms;

      @vertex fn vs(vert: Vertex) -&gt; VSOutput {
        var vsOut: VSOutput;
        vsOut.position = uni.viewProjection * uni.world * vert.position;

        // ë…¸ë©€ì„ ë³€í™˜í•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.normal = uni.normalMatrix * vert.normal;

        // í‘œë©´ì˜ ì›”ë“œ ìœ„ì¹˜ ê³„ì‚°
        let surfaceWorldPosition = (uni.world * vert.position).xyz;

        // í‘œë©´ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.surfaceToLight = uni.lightWorldPosition - surfaceWorldPosition;

        // í‘œë©´ì—ì„œ ë·°ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.surfaceToView = uni.viewWorldPosition - surfaceWorldPosition;

        // í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.texcoord = vert.texcoord;

        return vsOut;
      }

      @fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
        // vsOut.normalì€ ìŠ¤í…Œì´ì§€ ê°„ ë³€ìˆ˜ì´ë¯€ë¡œ
        // ë³´ê°„ë˜ì–´ ë‹¨ìœ„ ë²¡í„°ê°€ ì•„ë‹™ë‹ˆë‹¤.
        // ì •ê·œí™”í•˜ë©´ ë‹¤ì‹œ ë‹¨ìœ„ ë²¡í„°ê°€ ë©ë‹ˆë‹¤
        let normal = normalize(vsOut.normal);

        let surfaceToLightDirection = normalize(vsOut.surfaceToLight);
        let surfaceToViewDirection = normalize(vsOut.surfaceToView);
        let halfVector = normalize(
          surfaceToLightDirection + surfaceToViewDirection);

        // ë…¸ë©€ê³¼ ê´‘ì› ë°©í–¥ì˜ ë‚´ì ìœ¼ë¡œ
        // ì¡°ëª…ì„ ê³„ì‚°í•©ë‹ˆë‹¤
        let light = dot(normal, surfaceToLightDirection);

        var specular = dot(normal, halfVector);
        specular = select(
            0.0,                           // ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ ê°’
            pow(specular, uni.shininess),  // ì¡°ê±´ì´ ì°¸ì¼ ë•Œ ê°’
            specular &gt; 0.0);               // ì¡°ê±´

        let diffuse = uni.color * textureSample(diffuseTexture, diffuseSampler, vsOut.texcoord);
        // ì•ŒíŒŒê°€ ì•„ë‹Œ ìƒ‰ìƒ ë¶€ë¶„ë§Œ
        // ì¡°ëª… ê³„ì‚°
        let color = diffuse.rgb * light + specular;
        return vec4f(color, diffuse.a);
      }
    `,
  });
</pre>
<p>ì´ ì…°ì´ë” ëª¨ë“ˆì€ <a href="webgpu-lighting-point.html#a-specular">ë‹¤ë¥¸ ê³³ì—ì„œ ë‹¤ë£¬ ìŠ¤í”¼í˜ëŸ¬ í•˜ì´ë¼ì´íŠ¸ê°€ ìˆëŠ” ì  ê´‘ì›</a>ê³¼
ìœ ì‚¬í•œ ì¡°ëª…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ 3D ëª¨ë¸ì€ í…ìŠ¤ì²˜ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ í…ìŠ¤ì²˜ë¥¼ í¬í•¨í•˜ëŠ” ê²ƒì´
ê°€ì¥ ì¢‹ë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤. ê° íë¸Œì˜ ìƒ‰ìƒì„ ì¡°ì •í•  ìˆ˜ ìˆë„ë¡ í…ìŠ¤ì²˜ì— ìƒ‰ìƒì„ ê³±í•©ë‹ˆë‹¤.
ê·¸ë¦¬ê³  ì¡°ëª… ê³„ì‚°ê³¼ <a href="webgpu-perspective-projection.html">íë¸Œë¥¼ 3Dë¡œ íˆ¬ì˜</a>í•˜ëŠ” ë°
í•„ìš”í•œ ëª¨ë“  ìœ ë‹ˆí¼ ê°’ì´ ìˆìŠµë‹ˆë‹¤.</p>
<p>íë¸Œì— ëŒ€í•œ ë°ì´í„°ê°€ í•„ìš”í•˜ê³  í•´ë‹¹ ë°ì´í„°ë¥¼ ë²„í¼ì— ë„£ì–´ì•¼ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function createBufferWithData(device, data, usage) {
    const buffer = device.createBuffer({
      size: data.byteLength,
      usage: usage | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(buffer, 0, data);
    return buffer;
  }

  const positions = new Float32Array([1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]);
  const normals   = new Float32Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
  const texcoords = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
  const indices   = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);

  const positionBuffer = createBufferWithData(device, positions, GPUBufferUsage.VERTEX);
  const normalBuffer = createBufferWithData(device, normals, GPUBufferUsage.VERTEX);
  const texcoordBuffer = createBufferWithData(device, texcoords, GPUBufferUsage.VERTEX);
  const indicesBuffer = createBufferWithData(device, indices, GPUBufferUsage.INDEX);
  const numVertices = indices.length;
</pre>
<p>ë Œë” íŒŒì´í”„ë¼ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'textured model with point light w/specular highlight',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        // ìœ„ì¹˜
        {
          arrayStride: 3 * 4, // 3ê°œì˜ float
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},
          ],
        },
        // ë…¸ë©€
        {
          arrayStride: 3 * 4, // 3ê°œì˜ float
          attributes: [
            {shaderLocation: 1, offset: 0, format: 'float32x3'},
          ],
        },
        // uv
        {
          arrayStride: 2 * 4, // 2ê°œì˜ float
          attributes: [
            {shaderLocation: 2, offset: 0, format: 'float32x2'},
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
    primitive: {
      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
  });
</pre>
<p>ìœ„ì˜ íŒŒì´í”„ë¼ì¸ì€ ê° ì–´íŠ¸ë¦¬ë·°íŠ¸ ë§ˆë‹¤ 1ê°œì˜ ë²„í¼ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ìœ„ì¹˜ ë°ì´í„°ìš© í•˜ë‚˜,
ë…¸ë©€ ë°ì´í„°ìš© í•˜ë‚˜, í…ìŠ¤ì²˜ ì¢Œí‘œ(UV)ìš© í•˜ë‚˜ì…ë‹ˆë‹¤. í›„ë©´ ì œê±°ë¥¼ ìˆ˜í–‰í•˜ê³ ,
ê¹Šì´ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ë°›ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤. ëª¨ë‘ ë‹¤ë¥¸ ê¸€ì—ì„œ ë‹¤ë£¬ ë‚´ìš©ì…ë‹ˆë‹¤.</p>
<p>ìƒ‰ìƒê³¼ ë‚œìˆ˜ë¥¼ ë§Œë“œëŠ” ëª‡ ê°€ì§€ ìœ í‹¸ë¦¬í‹°ë¥¼ ì‚½ì…í•´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">/** CSS ìƒ‰ìƒ ë¬¸ìì—´ì´ ì£¼ì–´ì§€ë©´ 0ì—ì„œ 255 ì‚¬ì´ì˜ 4ê°œ ê°’ ë°°ì—´ì„ ë°˜í™˜ */
const cssColorToRGBA8 = (() =&gt; {
  const canvas = new OffscreenCanvas(1, 1);
  const ctx = canvas.getContext('2d', {willReadFrequently: true});
  return cssColor =&gt; {
    ctx.clearRect(0, 0, 1, 1);
    ctx.fillStyle = cssColor;
    ctx.fillRect(0, 0, 1, 1);
    return Array.from(ctx.getImageData(0, 0, 1, 1).data);
  };
})();

/** CSS ìƒ‰ìƒ ë¬¸ìì—´ì´ ì£¼ì–´ì§€ë©´ 0ì—ì„œ 1 ì‚¬ì´ì˜ 4ê°œ ê°’ ë°°ì—´ì„ ë°˜í™˜ */
const cssColorToRGBA = cssColor =&gt; cssColorToRGBA8(cssColor).map(v =&gt; v / 255);

/**
 * 0ì—ì„œ 1 ì‚¬ì´ì˜ ìƒ‰ì¡°, ì±„ë„, ëª…ë„ ê°’ì´ ì£¼ì–´ì§€ë©´
 * í•´ë‹¹í•˜ëŠ” CSS hsl ë¬¸ìì—´ì„ ë°˜í™˜
 */
const hsl = (h, s, l) =&gt; `hsl(${h * 360 | 0}, ${s * 100}%, ${l * 100 | 0}%)`;

/**
 * 0ì—ì„œ 1 ì‚¬ì´ì˜ ìƒ‰ì¡°, ì±„ë„, ëª…ë„ ê°’ì´ ì£¼ì–´ì§€ë©´
 * 0ì—ì„œ 1 ì‚¬ì´ì˜ 4ê°œ ê°’ ë°°ì—´ì„ ë°˜í™˜
 */
const hslToRGBA = (h, s, l) =&gt; cssColorToRGBA(hsl(h, s, l));

/**
 * minê³¼ max ì‚¬ì´ì˜ ë‚œìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * minê³¼ maxê°€ ì§€ì •ë˜ì§€ ì•Šìœ¼ë©´ 0ì—ì„œ 1 ì‚¬ì´ë¥¼ ë°˜í™˜
 * maxê°€ ì§€ì •ë˜ì§€ ì•Šìœ¼ë©´ 0ì—ì„œ min ì‚¬ì´ë¥¼ ë°˜í™˜
 */
function rand(min, max) {
  if (min === undefined) {
    max = 1;
    min = 0;
  } else if (max === undefined) {
    max = min;
    min = 0;
  }
  return Math.random() * (max - min) + min;
}

/** ë°°ì—´ì—ì„œ ë¬´ì‘ìœ„ ìš”ì†Œë¥¼ ì„ íƒ */
const randomArrayElement = arr =&gt; arr[Math.random() * arr.length | 0];
</pre>
<p>ëª¨ë‘ ë§¤ìš° ê°„ë‹¨í•©ë‹ˆë‹¤.</p>
<p>ì´ì œ ëª‡ ê°€ì§€ í…ìŠ¤ì²˜ì™€ ìƒ˜í”ŒëŸ¬ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ìº”ë²„ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê³ 
ì´ëª¨ì§€ë¥¼ ê·¸ë¦° ë‹¤ìŒ <a href="webgpu-importing-textures.html">í…ìŠ¤ì²˜ ë¡œë”©ì— ê´€í•œ ê¸€</a>ì—ì„œ
ì‘ì„±í•œ <code class="notranslate" translate="no">createTextureFromSource</code> í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤ì²˜ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const textures = [
    'ğŸ˜‚', 'ğŸ‘¾', 'ğŸ‘', 'ğŸ‘€', 'ğŸŒ', 'ğŸ›Ÿ',
  ].map(s =&gt; {
    const size = 128;
    const ctx = new OffscreenCanvas(size, size).getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, size, size);
    ctx.font = `${size * 0.9}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    const m = ctx.measureText(s);
    ctx.fillText(
      s,
      (size - m.actualBoundingBoxRight + m.actualBoundingBoxLeft) / 2,
      (size - m.actualBoundingBoxDescent + m.actualBoundingBoxAscent) / 2
    );
    return createTextureFromSource(device, ctx.canvas, {mips: true});
  });

  const sampler = device.createSampler({
    magFilter: 'linear',
    minFilter: 'linear',
    mipmapFilter: 'nearest',
  });
</pre>
<p>ë¨¸í‹°ë¦¬ì–¼(material) ì •ë³´ ì„¸íŠ¸ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ê³³ì—ì„œëŠ” ì´ë ‡ê²Œ í•˜ì§€ ì•Šì•˜ì§€ë§Œ
ì¼ë°˜ì ì¸ ì„¤ì •ì…ë‹ˆë‹¤. Unity, Unreal, Blender, Three.js, Babylon.js ëª¨ë‘
<em>ë¨¸í‹°ë¦¬ì–¼</em> ê°œë…ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ë¨¸í‹°ë¦¬ì–¼ì€ ë¬¼ì²´ì˜ ìƒ‰ìƒ,
ê´‘íƒ, ì‚¬ìš©í•  í…ìŠ¤ì²˜ ë“±ì˜ ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.</p>
<p>20ê°œì˜ "ë¨¸í‹°ë¦¬ì–¼"ì„ ë§Œë“  ë‹¤ìŒ ê° íë¸Œì— ëŒ€í•´ ë¬´ì‘ìœ„ë¡œ ë¨¸í‹°ë¦¬ì–¼ì„ ì„ íƒí•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const numMaterials = 20;
  const materials = [];
  for (let i = 0; i &lt; numMaterials; ++i) {
    const color = hslToRGBA(rand(), rand(0.5, 0.8), rand(0.5, 0.7));
    const shininess = rand(10, 120);
    materials.push({
      color,
      shininess,
      texture: randomArrayElement(textures),
      sampler,
    });
  }
</pre>
<p>ì´ì œ ê·¸ë¦¬ë ¤ëŠ” ê°ê°ì˜ ê°ì²´(íë¸Œ)ì— ëŒ€í•œ ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ìµœëŒ€ 30000ê°œë¥¼
ì§€ì›í•©ë‹ˆë‹¤. ì´ì „ì— í•´ì˜¤ë˜ ê²ƒì²˜ëŸ¼, ê° ê°ì²´ì— ëŒ€í•´ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ í•˜ë‚˜ì”© ë§Œë“¤ê³  ìœ ë‹ˆí¼ ê°’ìœ¼ë¡œ
ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆëŠ” íƒ€ì… ë°°ì—´ì„ ë§Œë“­ë‹ˆë‹¤. ë˜í•œ ê° ê°ì²´ì— ëŒ€í•´ ë°”ì¸ë“œ ê·¸ë£¹ì„
ë§Œë“­ë‹ˆë‹¤. ê·¸ë¦¬ê³  ê° ê°ì²´ë¥¼ ë°°ì¹˜í•˜ê³  ì• ë‹ˆë©”ì´ì…˜í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¬´ì‘ìœ„
ê°’ì„ ì„ íƒí•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const maxObjects = 30000;
  const objectInfos = [];

  for (let i = 0; i &lt; maxObjects; ++i) {
    const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);

    // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
    const kNormalMatrixOffset = 0;
    const kViewProjectionOffset = 12;
    const kWorldOffset = 28;
    const kColorOffset = 44;
    const kLightWorldPositionOffset = 48;
    const kViewWorldPositionOffset = 52;
    const kShininessOffset = 55;

    const normalMatrixValue = uniformValues.subarray(
        kNormalMatrixOffset, kNormalMatrixOffset + 12);
    const viewProjectionValue = uniformValues.subarray(
        kViewProjectionOffset, kViewProjectionOffset + 16);
    const worldValue = uniformValues.subarray(
        kWorldOffset, kWorldOffset + 16);
    const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
    const lightWorldPositionValue = uniformValues.subarray(
        kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
    const viewWorldPositionValue = uniformValues.subarray(
        kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
    const shininessValue = uniformValues.subarray(
        kShininessOffset, kShininessOffset + 1);

    const material = randomArrayElement(materials);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: material.texture.createView() },
        { binding: 1, resource: material.sampler },
        { binding: 2, resource: { buffer: uniformBuffer }},
      ],
    });

    const axis = vec3.normalize([rand(-1, 1), rand(-1, 1), rand(-1, 1)]);
    const radius = rand(10, 100);
    const speed = rand(0.1, 0.4);
    const rotationSpeed = rand(-1, 1);
    const scale = rand(2, 10);

    objectInfos.push({
      bindGroup,

      uniformBuffer,
      uniformValues,

      normalMatrixValue,
      worldValue,
      viewProjectionValue,
      colorValue,
      lightWorldPositionValue,
      viewWorldPositionValue,
      shininessValue,

      axis,
      material,
      radius,
      speed,
      rotationSpeed,
      scale,
    });
  }
</pre>
<p>ë Œë” íŒ¨ìŠ¤ ë””ìŠ¤í¬ë¦½í„°ë¥¼ ë¯¸ë¦¬ ë§Œë“­ë‹ˆë‹¤. ë Œë”ë§ ì‹œì‘ í• ë•Œ, ê·¸ ê°’ì„ ì¼ë¶€ ì—…ë°ì´íŠ¸ í•  ê²ƒì…ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass',
    colorAttachments: [
      {
        // view: &lt;- ë Œë”ë§ í• ë•Œ ì±„ì›Œì•¼í•¨
        clearValue: [0.3, 0.3, 0.3, 1],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    depthStencilAttachment: {
      // view: &lt;- ë Œë”ë§ í• ë•Œ ì±„ì›Œì•¼í•¨
      depthClearValue: 1.0,
      depthLoadOp: 'clear',
      depthStoreOp: 'store',
    },
  };
</pre>
<p>ê·¸ë¦´ ê°ì²´ì˜ ìˆ˜ë¥¼ ì¡°ì •í•  ìˆ˜ ìˆë„ë¡ ê°„ë‹¨í•œ UIê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    numObjects: 1000,
  };

  const gui = new GUI();
  gui.add(settings, 'numObjects', { min: 0, max: maxObjects, step: 1});
</pre>
<p>ì´ì œ ë Œë” ë£¨í”„ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  let depthTexture;
  let then = 0;

  function render(time) {
    time *= 0.001;  // ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜
    const deltaTime = time - then;
    then = time;


    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>ë Œë” ë£¨í”„ ë‚´ë¶€ì—ì„œ ë Œë” íŒ¨ìŠ¤ ë””ìŠ¤í¬ë¦½í„°ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ë˜í•œ ê¹Šì´ í…ìŠ¤ì²˜ê°€
ì—†ê±°ë‚˜ ê°€ì§€ê³  ìˆëŠ” ê²ƒì´ ìº”ë²„ìŠ¤ í…ìŠ¤ì²˜ì™€ í¬ê¸°ê°€ ë‹¤ë¥¸ ê²½ìš° ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ë§Œë“­ë‹ˆë‹¤.
<a href="webgpu-orthographic-projection.html#a-depth-textures">3Dì— ê´€í•œ ê¸€</a>ì—ì„œ ì´ë ‡ê²Œ í–ˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜„ì¬ í…ìŠ¤ì²˜ë¥¼ ê°€ì ¸ì™€
    // ë Œë”ë§í•  í…ìŠ¤ì²˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
    const canvasTexture = context.getCurrentTexture();
    renderPassDescriptor.colorAttachments[0].view = canvasTexture.createView();

    // ê¹Šì´ í…ìŠ¤ì²˜ê°€ ì—†ê±°ë‚˜ í¬ê¸°ê°€ canvasTextureì™€ ë‹¤ë¥´ë©´
    // ìƒˆ ê¹Šì´ í…ìŠ¤ì²˜ë¥¼ ë§Œë“­ë‹ˆë‹¤
    if (!depthTexture ||
        depthTexture.width !== canvasTexture.width ||
        depthTexture.height !== canvasTexture.height) {
      if (depthTexture) {
        depthTexture.destroy();
      }
      depthTexture = device.createTexture({
        size: [canvasTexture.width, canvasTexture.height],
        format: 'depth24plus',
        usage: GPUTextureUsage.RENDER_ATTACHMENT,
      });
    }
    renderPassDescriptor.depthStencilAttachment.view = depthTexture.createView();
</pre>
<p>ì»¤ë§¨ë“œ ë²„í¼ì™€ ë Œë” íŒ¨ìŠ¤ë¥¼ ì‹œì‘í•˜ê³  ì •ì  ë° ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, positionBuffer);
    pass.setVertexBuffer(1, normalBuffer);
    pass.setVertexBuffer(2, texcoordBuffer);
    pass.setIndexBuffer(indicesBuffer, 'uint16');
</pre>
<p>ê·¸ëŸ° ë‹¤ìŒ <a href="webgpu-perspective-projection.html">ì›ê·¼ íˆ¬ì˜ì— ê´€í•œ ê¸€</a>ì—ì„œ
ë‹¤ë£¬ ê²ƒì²˜ëŸ¼ viewProjection í–‰ë ¬ì„ ê³„ì‚°í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const degToRad = d =&gt; d * Math.PI / 180;

  function render(time) {
    ...

+    const aspect = canvas.clientWidth / canvas.clientHeight;
+    const projection = mat4.perspective(
+        degToRad(60),
+        aspect,
+        1,      // zNear
+        2000,   // zFar
+    );
+
+    const eye = [100, 150, 200];
+    const target = [0, 0, 0];
+    const up = [0, 1, 0];
+
+    // ë·° í–‰ë ¬ ê³„ì‚°
+    const viewMatrix = mat4.lookAt(eye, target, up);
+
+    // ë·° í–‰ë ¬ê³¼ íˆ¬ì˜ í–‰ë ¬ ê²°í•©
+    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);
</pre>
<p>ì´ì œ ëª¨ë“  ê°ì²´ë¥¼ ë°˜ë³µí•˜ì—¬ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ê°ì²´ì— ëŒ€í•´ ëª¨ë“  ìœ ë‹ˆí¼ ê°’ì„
ì—…ë°ì´íŠ¸í•˜ê³ , ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ë³µì‚¬í•˜ê³ , ì´ ê°ì²´ì˜ ë°”ì¸ë“œ ê·¸ë£¹ì„
ë°”ì¸ë”©í•˜ê³ , ê·¸ë¦½ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
        uniformBuffer,
        uniformValues,
        normalMatrixValue,
        worldValue,
        viewProjectionValue,
        colorValue,
        lightWorldPositionValue,
        viewWorldPositionValue,
        shininessValue,

        axis,
        material,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];

      // ì´ ê°ì²´ì˜ ìœ ë‹ˆí¼ ê°’ì— viewProjectionMatrix ë³µì‚¬
      viewProjectionValue.set(viewProjectionMatrix);

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

      const {color, shininess} = material;

      // ë¨¸í‹°ë¦¬ì–¼ ê°’ ë³µì‚¬
      colorValue.set(color);
      lightWorldPositionValue.set([-10, 30, 300]);
      viewWorldPositionValue.set(eye);
      shininessValue[0] = shininess;

      // ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }
</pre>
<blockquote>
<p>"ì›”ë“œ í–‰ë ¬ ê³„ì‚°"ì´ë¼ê³  í‘œì‹œëœ ì½”ë“œ ë¶€ë¶„ì€ ê·¸ë‹¤ì§€ ì¼ë°˜ì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤.
<a href="webgpu-scene-graphs.html">ì”¬ ê·¸ë˜í”„</a>ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¼ë°˜ì ì´ì§€ë§Œ
ê·¸ê²ƒì„ ì“°ë©´ ì˜ˆì œê°€ ë” ë³µì¡í•´ì§‘ë‹ˆë‹¤. ì• ë‹ˆë©”ì´ì…˜ì„ ë³´ì—¬ì¤„ ëª©ì ìœ¼ë¡œ ì´ëŸ° ì½”ë“œë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.</p>
</blockquote>
<p>ê·¸ëŸ° ë‹¤ìŒ íŒ¨ìŠ¤ë¥¼ ì¢…ë£Œí•˜ê³  ì»¤ë§¨ë“œ ë²„í¼ë¥¼ ì™„ë£Œí•˜ê³  ì œì¶œí•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    pass.end();
+
+    const commandBuffer = encoder.finish();
+    device.queue.submit([commandBuffer]);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>ëª‡ ê°€ì§€ ë” í•´ì•¼ í•  ì¼ì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤. í¬ê¸° ì¡°ì •ì„ ì¶”ê°€í•´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const canvasToSizeMap = new WeakMap();

  function render(time) {
    time *= 0.001;  // ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜
    const deltaTime = time - then;
    then = time;

+    const {width, height} = canvasToSizeMap.get(canvas) ?? canvas;
+
+    // ì´ë¯¸ í•´ë‹¹ í¬ê¸°ì¸ ê²½ìš° ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì„¤ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŠë¦´ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
+    if (canvas.width !== width || canvas.height !== height) {
+      canvas.width = width;
+      canvas.height = height;
+    }

    // ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜„ì¬ í…ìŠ¤ì²˜ë¥¼ ê°€ì ¸ì™€
    // ë Œë”ë§í•  í…ìŠ¤ì²˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
    const canvasTexture = context.getCurrentTexture();
    renderPassDescriptor.colorAttachments[0].view = canvasTexture.createView();

    ...

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

+  const observer = new ResizeObserver(entries =&gt; {
+    entries.forEach(entry =&gt; {
+      canvasToSizeMap.set(entry.target, {
+        width: Math.max(1, Math.min(entry.contentBoxSize[0].inlineSize, device.limits.maxTextureDimension2D)),
+        height: Math.max(1, Math.min(entry.contentBoxSize[0].blockSize, device.limits.maxTextureDimension2D)),
+      });
+    });
+  });
+  observer.observe(canvas);
</pre>
<p>íƒ€ì´ë°ë„ ì¶”ê°€í•´ ë³´ê² ìŠµë‹ˆë‹¤. <a href="webgpu-timing.html">íƒ€ì´ë°ì— ê´€í•œ ê¸€</a>ì—ì„œ
ë§Œë“  <code class="notranslate" translate="no">NonNegativeRollingAverage</code>ì™€ <code class="notranslate" translate="no">TimingHelper</code> í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// see https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
import TimingHelper from './resources/js/timing-helper.js';
// see https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
import NonNegativeRollingAverage from './resources/js/non-negative-rolling-average.js';

const fpsAverage = new NonNegativeRollingAverage();
const jsAverage = new NonNegativeRollingAverage();
const gpuAverage = new NonNegativeRollingAverage();
const mathAverage = new NonNegativeRollingAverage();
</pre>
<p>ê·¸ëŸ° ë‹¤ìŒ ë Œë”ë§ ì½”ë“œì˜ ì‹œì‘ë¶€í„° ëê¹Œì§€ JavaScript ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(time) {
    ...

+    const startTimeMs = performance.now();

    ...

+    const elapsedTimeMs = performance.now() - startTimeMs;
+    jsAverage.addSample(elapsedTimeMs);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>3D ìˆ˜í•™ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” JavaScript ë¶€ë¶„ì˜ ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render(time) {
    ...

+    let mathElapsedTimeMs = 0;

    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
        uniformBuffer,
        uniformValues,
        normalMatrixValue,
        worldValue,
        viewProjectionValue,
        colorValue,
        lightWorldPositionValue,
        viewWorldPositionValue,
        shininessValue,

        axis,
        material,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];
+      const mathTimeStartMs = performance.now();

      // ì´ ê°ì²´ì˜ ìœ ë‹ˆí¼ ê°’ì— viewProjectionMatrix ë³µì‚¬
      viewProjectionValue.set(viewProjectionMatrix);

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

      const {color, shininess} = material;

      colorValue.set(color);
      lightWorldPositionValue.set([-10, 30, 300]);
      viewWorldPositionValue.set(eye);
      shininessValue[0] = shininess;

+      mathElapsedTimeMs += performance.now() - mathTimeStartMs;

      // ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }

    ...

    const elapsedTimeMs = performance.now() - startTimeMs;
    jsAverage.addSample(elapsedTimeMs);
+    mathAverage.addSample(mathElapsedTimeMs);


    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p><code class="notranslate" translate="no">requestAnimationFrame</code> ì½œë°± ì‚¬ì´ì˜ ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  let depthTexture;
  let then = 0;

  function render(time) {
    time *= 0.001;  // ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜
    const deltaTime = time - then;
    then = time;

    ...

    const elapsedTimeMs = performance.now() - startTimeMs;
+    fpsAverage.addSample(1 / deltaTime);
    jsAverage.addSample(elapsedTimeMs);
    mathAverage.addSample(mathElapsedTimeMs);


    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>ê·¸ë¦¬ê³  ë Œë” íŒ¨ìŠ¤ì˜ ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter({
    powerPreference: 'high-performance',
  });
-  const device = await adapter?.requestDevice();
+  const canTimestamp = adapter.features.has('timestamp-query');
+  const device = await adapter?.requestDevice({
+    requiredFeatures: [
+      ...(canTimestamp ? ['timestamp-query'] : []),
+     ],
+  });
  if (!device) {
    fail('could not init WebGPU');
  }

+  const timingHelper = new TimingHelper(device);

  ...

  function render(time) {
    ...

-    const pass = encoder.beginRenderPass(renderPassEncoder);
+    const pass = timingHelper.beginRenderPass(encoder, renderPassDescriptor);

    ...

    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

+    timingHelper.getResult().then(gpuTime =&gt; {
+      gpuAverage.addSample(gpuTime / 1000);
+    });

    ...

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>ê·¸ë¦¬ê³  íƒ€ì´ë°ì„ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  ...

  const timingHelper = new TimingHelper(device);
+  const infoElem = document.querySelector('#info');

  ...

  function render(time) {
    ...

    timingHelper.getResult().then(gpuTime =&gt; {
      gpuAverage.addSample(gpuTime / 1000);
    });

    const elapsedTimeMs = performance.now() - startTimeMs;
    fpsAverage.addSample(1 / deltaTime);
    jsAverage.addSample(elapsedTimeMs);
    mathAverage.addSample(mathElapsedTimeMs);

+    infoElem.textContent = `\
+js  : ${jsAverage.get().toFixed(1)}ms
+math: ${mathAverage.get().toFixed(1)}ms
+fps : ${fpsAverage.get().toFixed(0)}
+gpu : ${canTimestamp ? `${(gpuAverage.get() / 1000).toFixed(1)}ms` : 'N/A'}
+`;

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</pre>
<p>ë¹„êµì— ë„ì›€ì´ ë˜ëŠ” ê²ƒì´ í•œê°€ì§€ ë” ìˆìŠµë‹ˆë‹¤. ì§€ê¸ˆ ìš°ë¦¬ì˜ ë¬¸ì œëŠ”
ë³´ì´ëŠ” ëª¨ë“  íë¸Œê°€ ëª¨ë“  í”½ì…€ì„ ë Œë”ë§í•˜ê±°ë‚˜ ìµœì†Œí•œ ë Œë”ë§í•´ì•¼ í•˜ëŠ”ì§€
í™•ì¸í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. í”½ì…€ ë Œë”ë§ì„ ìµœì í™”í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ WebGPU ìì²´ì˜
ì‚¬ìš©ì„ ìµœì í™”í•˜ê³  ìˆìœ¼ë¯€ë¡œ 1x1 í”½ì…€ ìº”ë²„ìŠ¤ì— ê·¸ë¦´ ìˆ˜ ìˆìœ¼ë©´ ìœ ìš©í•  ìˆ˜
ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì‚¼ê°í˜•ì„ ë˜ìŠ¤í„°í™”í•˜ëŠ” ë° ì†Œìš”ë˜ëŠ” ê±°ì˜ ëª¨ë“  ì‹œê°„ì´
ì œê±°ë˜ê³  ìˆ˜í•™ ì—°ì‚°ê³¼ WebGPUì™€ í†µì‹ í•˜ëŠ” ì½”ë“œ ë¶€ë¶„ë§Œ ë‚¨ìŠµë‹ˆë‹¤.</p>
<p>ê·¸ë ‡ê²Œ í•  ìˆ˜ ìˆëŠ” ì˜µì…˜ì„ ì¶”ê°€í•´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    numObjects: 1000,
+    render: true,
  };

  const gui = new GUI();
  gui.add(settings, 'numObjects', { min: 0, max: maxObjects, step: 1});
+  gui.add(settings, 'render');

  let depthTexture;
  let then = 0;
  let frameCount = 0;

  function render(time) {
    time *= 0.001;  // ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜
    const deltaTime = time - then;
    then = time;
    ++frameCount;

    const startTimeMs = performance.now();

-    const {width, height} = canvasToSizeMap.get(canvas) ?? canvas;
+    const {width, height} = settings.render
+       ? canvasToSizeMap.get(canvas) ?? canvas
+       : { width: 1, height: 1 };
</pre>
<p>ì´ì œ 'renderâ€™ë¥¼ ì²´í¬ í•´ì œí•˜ë©´ ê±°ì˜ ëª¨ë“  ë Œë”ë§ì´ ì œê±°ë©ë‹ˆë‹¤.</p>
<p>ê·¸ë¦¬ê³  ì´ê²ƒìœ¼ë¡œ ì²« ë²ˆì§¸ â€œìµœì í™”ë˜ì§€ ì•Šì€â€ ì˜ˆì œê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
ì´ ê¸€ì˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ë‚˜ì—´í–ˆë˜ ë‹¨ê³„ë“¤ì„ ë”°ë¥´ê³  ìˆìœ¼ë©° ì‘ë™í•©ë‹ˆë‹¤.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-optimization-none.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-optimization-none.html" target="_blank">ìƒˆ ì°½ìœ¼ë¡œ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</a>
</div>

<p></p>
<p>ê°ì²´ ìˆ˜ë¥¼ ëŠ˜ë ¤ê°€ë©´ì„œ í”„ë ˆì„ ì†ë„ê°€ ì–¸ì œ ë–¨ì–´ì§€ëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”.
ì œ ê²½ìš° M1 Macì˜ 75hz ëª¨ë‹ˆí„°ì—ì„œ íë¸Œ ì•½ 8000ê°œë¶€í„° í”„ë ˆì„ ì†ë„ê°€ ë–¨ì–´ì§€ê¸° ì‹œì‘í•©ë‹ˆë‹¤.</p>
<h1 id="ìµœì í™”-ìƒì„±-ì‹œ-ë§¤í•‘"><a id="a-mapped-on-creation"></a> ìµœì í™”: ìƒì„± ì‹œ ë§¤í•‘</h1>
<p>ìœ„ì˜ ì˜ˆì œì™€ ì´ ì‚¬ì´íŠ¸ì˜ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œì—ì„œ <code class="notranslate" translate="no">writeBuffer</code>ë¥¼ ì‚¬ìš©í•˜ì—¬
ë°ì´í„°ë¥¼ ì •ì  ë˜ëŠ” ì¸ë±ìŠ¤ ë²„í¼ì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤. ì´ íŠ¹ì • ê²½ìš°ì— ëŒ€í•œ
ë§¤ìš° ì‚¬ì†Œí•œ ìµœì í™”ë¡œ, ë²„í¼ë¥¼ ë§Œë“¤ ë•Œ <code class="notranslate" translate="no">mappedAtCreation: true</code>ë¥¼
ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ 2ê°€ì§€ ì´ì ì´ ìˆìŠµë‹ˆë‹¤.</p>
<ol>
<li>
<p>ìƒˆ ë²„í¼ì— ë°ì´í„°ë¥¼ ë„£ëŠ” ê²ƒì´ ì•½ê°„ ë” ë¹ ë¦…ë‹ˆë‹¤.</p>
</li>
<li>
<p>ë²„í¼ì— <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code> í”Œë˜ê·¸ë¥¼ ì¶”ê°€í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
<p>ì´ê²ƒì€ ë‚˜ì¤‘ì— <code class="notranslate" translate="no">writeBuffer</code>ë‚˜ ë²„í¼ë¡œ ë³µì‚¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ í†µí•´
ë°ì´í„°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šì„ ê²ƒì´ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤.</p>
</li>
</ol>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function createBufferWithData(device, data, usage) {
    const buffer = device.createBuffer({
      size: data.byteLength,
-      usage: usage | GPUBufferUsage.COPY_DST,
+      usage: usage,
+      mappedAtCreation: true,
    });
-    device.queue.writeBuffer(buffer, 0, data);
+    const dst = new Uint8Array(buffer.getMappedRange());
+    dst.set(new Uint8Array(data.buffer));
+    buffer.unmap();
    return buffer;
  }
</pre>
<p>ì´ ìµœì í™”ëŠ” ìƒì„± ì‹œì—ë§Œ ë„ì›€ì´ ë˜ë¯€ë¡œ ë Œë” ì‹œê°„ì˜ ì„±ëŠ¥ì—ëŠ” ì˜í–¥ì„
ë¯¸ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>
<h1 id="ìµœì í™”-ì •ì -íŒ¨í‚¹-ë°-ì¸í„°ë¦¬ë¹™interleaving"><a id="a-pack-verts"></a> ìµœì í™”: ì •ì  íŒ¨í‚¹ ë° ì¸í„°ë¦¬ë¹™(Interleaving)</h1>
<p>ìœ„ì˜ ì˜ˆì œì—ëŠ” 3ê°œì˜ ì†ì„±ì´ ìˆìŠµë‹ˆë‹¤. ìœ„ì¹˜, ë…¸ë©€, í…ìŠ¤ì²˜ ì¢Œí‘œì…ë‹ˆë‹¤. <a href="webgpu-normal-mapping.html">ë…¸ë©€ ë§¤í•‘ì„ ìœ„í•œ íƒ„ì  íŠ¸</a>ê°€
ìˆê³  <a href="webgpu-skinning.html">ìŠ¤í‚¨ ëª¨ë¸</a>ì´ ìˆëŠ” ê²½ìš° ê°€ì¤‘ì¹˜ì™€ ì¡°ì¸íŠ¸ë¥¼
ì¶”ê°€í•´ì„œ 4~6ê°œì˜ ì†ì„±ì„ ê°–ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.</p>
<p>ìœ„ì˜ ì˜ˆì œì—ì„œ ê° ì†ì„±ì€ ìì²´ ë²„í¼ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ê²ƒì€ CPUì™€ GPU
ëª¨ë‘ì—ì„œ ëŠë¦½ë‹ˆë‹¤. JavaScriptì˜ CPUì—ì„œ ëŠë¦° ì´ìœ ëŠ” ê·¸ë¦¬ë ¤ëŠ” ê° ëª¨ë¸ì˜
ê° ë²„í¼ì— ëŒ€í•´ <code class="notranslate" translate="no">setVertexBuffer</code>ë¥¼ í˜¸ì¶œí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.</p>
<p>íë¸Œ ëŒ€ì‹  100ê°œì˜ ëª¨ë¸ì´ ìˆë‹¤ê³  ìƒìƒí•´ ë³´ì„¸ìš”. ê·¸ë¦´ ëª¨ë¸ì„ ì „í™˜í•  ë•Œë§ˆë‹¤
<code class="notranslate" translate="no">setVertexBuffer</code>ë¥¼ ìµœëŒ€ 6ë²ˆ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤. ëª¨ë¸ë‹¹ 6 í˜¸ì¶œ * 100ê°œ ëª¨ë¸ = 600 í˜¸ì¶œ.</p>
<p>â€œì‘ì—…ì´ ì ìŒ = ë” ë¹ ë¦„â€ ê·œì¹™ì— ë”°ë¼ ì†ì„±ì˜ ë°ì´í„°ë¥¼ ë‹¨ì¼ ë²„í¼ë¡œ
ë³‘í•©í•˜ë©´ ëª¨ë¸ë‹¹ í•œ ë²ˆë§Œ <code class="notranslate" translate="no">setVertexBuffer</code>ë¥¼ í˜¸ì¶œí•˜ë©´ ë©ë‹ˆë‹¤. 100 í˜¸ì¶œ. 600% ë” ë¹ ë¦…ë‹ˆë‹¤!</p>
<p>GPUì—ì„œëŠ” ë©”ëª¨ë¦¬ ìƒì˜ ê°€ê¹Œìš´ ìœ„ì¹˜ì— ëª¨ì—¬ìˆëŠ” ê²ƒì„ ë¡œë“œí•˜ëŠ” ê²ƒì´
ë¨¼ ìœ„ì¹˜ì—ì„œ ë¡œë“œí•˜ëŠ” ê²ƒë³´ë‹¤ ë¹ ë¥´ë¯€ë¡œ ë‹¨ì¼ ëª¨ë¸ì˜ ì •ì  ë°ì´í„°ë¥¼
ë‹¨ì¼ ë²„í¼ì— ë„£ëŠ” ê²ƒ ì™¸ì—ë„ ë°ì´í„°ë¥¼ ì¸í„°ë¦¬ë¹™í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.</p>
<p>ì—­ì ì£¼: ì¸í„°ë¦¬ë¹™(interleaving)ì´ë€ ë°ì´í„°ë¥¼ í•©ì¹ ë•Œ ì„œë¡œ ì‚¬ì´ì‚¬ì´ì— ë¼ì›Œë„£ëŠ” ë°©ì‹ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 12345 ì™€ ABCDE ë¥¼ í•©ì³ì„œ 1A2B3C4D5E ë¥¼ ë§Œë“œëŠ” ê²ƒ.</p>
<p>ê·¸ ë³€ê²½ì„ í•´ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const positions = new Float32Array([1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]);
-  const normals   = new Float32Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
-  const texcoords = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
+  const vertexData = new Float32Array([
+  // ìœ„ì¹˜            ë…¸ë©€           í…ìŠ¤ì²˜ì¢Œí‘œ
+     1,  1, -1,     1,  0,  0,    1, 0,
+     1,  1,  1,     1,  0,  0,    0, 0,
+     1, -1,  1,     1,  0,  0,    0, 1,
+     1, -1, -1,     1,  0,  0,    1, 1,
+    -1,  1,  1,    -1,  0,  0,    1, 0,
+    -1,  1, -1,    -1,  0,  0,    0, 0,
+    -1, -1, -1,    -1,  0,  0,    0, 1,
+    -1, -1,  1,    -1,  0,  0,    1, 1,
+    -1,  1,  1,     0,  1,  0,    1, 0,
+     1,  1,  1,     0,  1,  0,    0, 0,
+     1,  1, -1,     0,  1,  0,    0, 1,
+    -1,  1, -1,     0,  1,  0,    1, 1,
+    -1, -1, -1,     0, -1,  0,    1, 0,
+     1, -1, -1,     0, -1,  0,    0, 0,
+     1, -1,  1,     0, -1,  0,    0, 1,
+    -1, -1,  1,     0, -1,  0,    1, 1,
+     1,  1,  1,     0,  0,  1,    1, 0,
+    -1,  1,  1,     0,  0,  1,    0, 0,
+    -1, -1,  1,     0,  0,  1,    0, 1,
+     1, -1,  1,     0,  0,  1,    1, 1,
+    -1,  1, -1,     0,  0, -1,    1, 0,
+     1,  1, -1,     0,  0, -1,    0, 0,
+     1, -1, -1,     0,  0, -1,    0, 1,
+    -1, -1, -1,     0,  0, -1,    1, 1,
+  ]);
  const indices   = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);

-  const positionBuffer = createBufferWithData(device, positions, GPUBufferUsage.VERTEX);
-  const normalBuffer = createBufferWithData(device, normals, GPUBufferUsage.VERTEX);
-  const texcoordBuffer = createBufferWithData(device, texcoords, GPUBufferUsage.VERTEX);
+  const vertexBuffer = createBufferWithData(device, vertexData, GPUBufferUsage.VERTEX);
  const indicesBuffer = createBufferWithData(device, indices, GPUBufferUsage.INDEX);
  const numVertices = indices.length;

  const pipeline = device.createRenderPipeline({
    label: 'textured model with point light w/specular highlight',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
-        // ìœ„ì¹˜
-        {
-          arrayStride: 3 * 4, // 3 floats
-          attributes: [
-            {shaderLocation: 0, offset: 0, format: 'float32x3'},
-          ],
-        },
-        // ë…¸ë©€
-        {
-          arrayStride: 3 * 4, // 3 floats
-          attributes: [
-            {shaderLocation: 1, offset: 0, format: 'float32x3'},
-          ],
-        },
-        // uv
-        {
-          arrayStride: 2 * 4, // 2 floats
-          attributes: [
-            {shaderLocation: 2, offset: 0, format: 'float32x2'},
-          ],
-        },
+        {
+          arrayStride: (3 + 3 + 2) * 4, // 8ê°œì˜ float
+          attributes: [
+            {shaderLocation: 0, offset: 0 * 4, format: 'float32x3'}, // ìœ„ì¹˜
+            {shaderLocation: 1, offset: 3 * 4, format: 'float32x3'}, // ë…¸ë©€
+            {shaderLocation: 2, offset: 6 * 4, format: 'float32x2'}, // í…ìŠ¤ì²˜ì¢Œí‘œ
+          ],
+        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
    primitive: {
      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
  });

  ...
-    pass.setVertexBuffer(0, positionBuffer);
-    pass.setVertexBuffer(1, normalBuffer);
-    pass.setVertexBuffer(2, texcoordBuffer);
+    pass.setVertexBuffer(0, vertexBuffer);
</pre>
<p>ìœ„ì—ì„œ 3ê°œì˜ ì†ì„±ì— ëŒ€í•œ ë°ì´í„°ë¥¼ ëª¨ë‘ ë‹¨ì¼ ë²„í¼ì— ë„£ì€ ë‹¤ìŒ
ë°ì´í„°ê°€ ë‹¨ì¼ ë²„í¼ë¡œ ì¸í„°ë¦¬ë¹™ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•˜ë„ë¡ ë Œë” íŒ¨ìŠ¤ë¥¼ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.</p>
<p>ì°¸ê³ : gLTF íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” ê²½ìš°, ì •ì  ë°ì´í„°ê°€ ë‹¨ì¼ ë²„í¼ë¡œ ì¸í„°ë¦¬ë¹™ë˜ë„ë¡
ì‚¬ì „ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ìµœì„ ì´ê³ , ê·¸ ë‹¤ìŒìœ¼ë¡œëŠ” ë¡œë“œ ì‹œì— ë°ì´í„°ë¥¼ ì¸í„°ë¦¬ë¹™í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.</p>
<h1 id="ìµœì í™”-ìœ ë‹ˆí¼-ë²„í¼-ë¶„í• -ê³µìœ -ë¨¸í‹°ë¦¬ì–¼-ëª¨ë¸ë³„">ìµœì í™”: ìœ ë‹ˆí¼ ë²„í¼ ë¶„í•  (ê³µìœ , ë¨¸í‹°ë¦¬ì–¼, ëª¨ë¸ë³„)</h1>
<p>í˜„ì¬ ì˜ˆì œì—ëŠ” ê°ì²´ë‹¹ í•˜ë‚˜ì˜ ìœ ë‹ˆí¼ ë²„í¼ê°€ ìˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  normalMatrix: mat3x3f,
  viewProjection: mat4x4f,
  world: mat4x4f,
  color: vec4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
  shininess: f32,
};
</pre>
<p><code class="notranslate" translate="no">viewProjection</code>, <code class="notranslate" translate="no">lightWorldPosition</code>, <code class="notranslate" translate="no">viewWorldPosition</code>ê³¼ ê°™ì€
ì¼ë¶€ ìœ ë‹ˆí¼ ê°’ì€ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p>ì…°ì´ë”ì—ì„œ ì´ê²ƒë“¤ì„ ë¶„í• í•˜ì—¬ ë‘ ê°œì˜ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê³µìœ í•˜ëŠ” ê°’ì„ ìœ„í•œ ê²ƒê³¼, <em>ê°ì²´ë³„ ê°’</em>ì„ ìœ„í•œ ê²ƒ.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct GlobalUniforms {
  viewProjection: mat4x4f,
  lightWorldPosition: vec3f,
  viewWorldPosition: vec3f,
};
struct PerObjectUniforms {
  normalMatrix: mat3x3f,
  world: mat4x4f,
  color: vec4f,
  shininess: f32,
};
</pre>
<p>ì´ ë³€ê²½ìœ¼ë¡œ <code class="notranslate" translate="no">viewProjection</code>, <code class="notranslate" translate="no">lightWorldPosition</code>, <code class="notranslate" translate="no">viewWorldPosition</code>ì„
ëª¨ë“  ìœ ë‹ˆí¼ ë²„í¼ì— ë³µì‚¬í•  í•„ìš”ê°€ ì—†ê²Œ ë©ë‹ˆë‹¤. ë˜í•œ <code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¡œ
ê°ì²´ë‹¹ ë” ì ì€ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ê²Œ ë©ë‹ˆë‹¤.</p>
<p>ìƒˆë¡œìš´ ì…°ì´ë”ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    code: /* wgsl */ `
-      struct Uniforms {
-        normalMatrix: mat3x3f,
-        viewProjection: mat4x4f,
-        world: mat4x4f,
-        color: vec4f,
-        lightWorldPosition: vec3f,
-        viewWorldPosition: vec3f,
-        shininess: f32,
-      };

+      struct GlobalUniforms {
+        viewProjection: mat4x4f,
+        lightWorldPosition: vec3f,
+        viewWorldPosition: vec3f,
+      };
+      struct PerObjectUniforms {
+        normalMatrix: mat3x3f,
+        world: mat4x4f,
+        color: vec4f,
+        shininess: f32,
+      };

      struct Vertex {
        @location(0) position: vec4f,
        @location(1) normal: vec3f,
        @location(2) texcoord: vec2f,
      };

      struct VSOutput {
        @builtin(position) position: vec4f,
        @location(0) normal: vec3f,
        @location(1) surfaceToLight: vec3f,
        @location(2) surfaceToView: vec3f,
        @location(3) texcoord: vec2f,
      };

      @group(0) @binding(0) var diffuseTexture: texture_2d&lt;f32&gt;;
      @group(0) @binding(1) var diffuseSampler: sampler;
-      @group(0) @binding(2) var&lt;uniform&gt; uni: Uniforms;
+      @group(0) @binding(2) var&lt;uniform&gt; obj: PerObjectUniforms;
+      @group(0) @binding(3) var&lt;uniform&gt; glb: GlobalUniforms;

      @vertex fn vs(vert: Vertex) -&gt; VSOutput {
        var vsOut: VSOutput;
-        vsOut.position = uni.viewProjection * uni.world * vert.position;
+        vsOut.position = glb.viewProjection * obj.world * vert.position;

        // ë…¸ë©€ì„ ë³€í™˜í•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
-        vsOut.normal = uni.normalMatrix * vert.normal;
+        vsOut.normal = obj.normalMatrix * vert.normal;

        // í‘œë©´ì˜ ì›”ë“œ ìœ„ì¹˜ ê³„ì‚°
-        let surfaceWorldPosition = (uni.world * vert.position).xyz;
+        let surfaceWorldPosition = (obj.world * vert.position).xyz;

        // í‘œë©´ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
-        vsOut.surfaceToLight = uni.lightWorldPosition - surfaceWorldPosition;
+        vsOut.surfaceToLight = glb.lightWorldPosition - surfaceWorldPosition;

        // í‘œë©´ì—ì„œ ë·°ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
-        vsOut.surfaceToView = uni.viewWorldPosition - surfaceWorldPosition;
+        vsOut.surfaceToView = glb.viewWorldPosition - surfaceWorldPosition;

        // í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.texcoord = vert.texcoord;

        return vsOut;
      }

      @fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
        // vsOut.normalì€ ìŠ¤í…Œì´ì§€ ê°„ ë³€ìˆ˜ì´ë¯€ë¡œ
        // ë³´ê°„ë˜ì–´ ë‹¨ìœ„ ë²¡í„°ê°€ ì•„ë‹™ë‹ˆë‹¤.
        // ì •ê·œí™”í•˜ë©´ ë‹¤ì‹œ ë‹¨ìœ„ ë²¡í„°ê°€ ë©ë‹ˆë‹¤
        let normal = normalize(vsOut.normal);

        let surfaceToLightDirection = normalize(vsOut.surfaceToLight);
        let surfaceToViewDirection = normalize(vsOut.surfaceToView);
        let halfVector = normalize(
          surfaceToLightDirection + surfaceToViewDirection);

        // ë…¸ë©€ê³¼ ê´‘ì› ë°©í–¥ì˜ ë‚´ì ìœ¼ë¡œ
        // ì¡°ëª…ì„ ê³„ì‚°í•©ë‹ˆë‹¤
        let light = dot(normal, surfaceToLightDirection);

        var specular = dot(normal, halfVector);
        specular = select(
            0.0,                           // ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ ê°’
-            pow(specular, uni.shininess),  // ì¡°ê±´ì´ ì°¸ì¼ ë•Œ ê°’
+            pow(specular, obj.shininess),  // ì¡°ê±´ì´ ì°¸ì¼ ë•Œ ê°’
            specular &gt; 0.0);               // ì¡°ê±´

-        let diffuse = uni.color * textureSample(diffuseTexture, diffuseSampler, vsOut.texcoord);
+        let diffuse = obj.color * textureSample(diffuseTexture, diffuseSampler, vsOut.texcoord);
        // ì•ŒíŒŒê°€ ì•„ë‹Œ ìƒ‰ìƒ ë¶€ë¶„ë§Œ
        // ì¡°ëª… ê³„ì‚°
        let color = diffuse.rgb * light + specular;
        return vec4f(color, diffuse.a);
      }
    `,
  });
</pre>
<p>ì „ì—­ ìœ ë‹ˆí¼ì„ ìœ„í•œ í•˜ë‚˜ì˜ ì „ì—­ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const globalUniformBufferSize = (16 + 4 + 4) * 4;
  const globalUniformBuffer = device.createBuffer({
    label: 'global uniforms',
    size: globalUniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const globalUniformValues = new Float32Array(globalUniformBufferSize / 4);

  const kViewProjectionOffset = 0;
  const kLightWorldPositionOffset = 16;
  const kViewWorldPositionOffset = 20;

  const viewProjectionValue = globalUniformValues.subarray(
      kViewProjectionOffset, kViewProjectionOffset + 16);
  const lightWorldPositionValue = globalUniformValues.subarray(
      kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
  const viewWorldPositionValue = globalUniformValues.subarray(
      kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
</pre>
<p>ê·¸ëŸ° ë‹¤ìŒ ê°ì²´ë³„ ìœ ë‹ˆí¼ ë²„í¼ì—ì„œ ì´ëŸ¬í•œ ìœ ë‹ˆí¼ì„ ì œê±°í•˜ê³ 
ê° ê°ì²´ì˜ ë°”ì¸ë“œ ê·¸ë£¹ì— ì „ì—­ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const maxObjects = 30000;
  const objectInfos = [];

  for (let i = 0; i &lt; maxObjects; ++i) {
-    const uniformBufferSize = (12 + 16 + 16 + 4 + 4 + 4) * 4;
+    const uniformBufferSize = (12 + 16 + 4 + 4) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);

    // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
    const kNormalMatrixOffset = 0;
-    const kViewProjectionOffset = 12;
-    const kWorldOffset = 28;
-    const kColorOffset = 44;
-    const kLightWorldPositionOffset = 48;
-    const kViewWorldPositionOffset = 52;
-    const kShininessOffset = 55;
+    const kWorldOffset = 12;
+    const kColorOffset = 28;
+    const kShininessOffset = 32;

    const normalMatrixValue = uniformValues.subarray(
        kNormalMatrixOffset, kNormalMatrixOffset + 12);
-    const viewProjectionValue = uniformValues.subarray(
-        kViewProjectionOffset, kViewProjectionOffset + 16);
    const worldValue = uniformValues.subarray(
        kWorldOffset, kWorldOffset + 16);
    const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
-    const lightWorldPositionValue = uniformValues.subarray(
-        kLightWorldPositionOffset, kLightWorldPositionOffset + 3);
-    const viewWorldPositionValue = uniformValues.subarray(
-        kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
    const shininessValue = uniformValues.subarray(
        kShininessOffset, kShininessOffset + 1);

    const material = randomArrayElement(materials);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: material.texture.createView() },
        { binding: 1, resource: material.sampler },
        { binding: 2, resource: { buffer: uniformBuffer }},
+        { binding: 3, resource: { buffer: globalUniformBuffer }},
      ],
    });

    const axis = vec3.normalize([rand(-1, 1), rand(-1, 1), rand(-1, 1)]);
    const radius = rand(10, 100);
    const speed = rand(0.1, 0.4);
    const rotationSpeed = rand(-1, 1);
    const scale = rand(2, 10);

    objectInfos.push({
      bindGroup,

      uniformBuffer,
      uniformValues,

      normalMatrixValue,
      worldValue,
-      viewProjectionValue,
      colorValue,
-      lightWorldPositionValue,
-      viewWorldPositionValue,
      shininessValue,
      material,

      axis,
      radius,
      speed,
      rotationSpeed,
      scale,
    });
  }
</pre>
<p>ê·¸ëŸ° ë‹¤ìŒ ë Œë” ì‹œê°„ì— ê°ì²´ ë Œë”ë§ ë£¨í”„ ì™¸ë¶€ì—ì„œ ì „ì—­ ìœ ë‹ˆí¼ ë²„í¼ë¥¼
í•œ ë²ˆë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        degToRad(60),
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    const eye = [100, 150, 200];
    const target = [0, 0, 0];
    const up = [0, 1, 0];

    // ë·° í–‰ë ¬ ê³„ì‚°
    const viewMatrix = mat4.lookAt(eye, target, up);

    // ë·° í–‰ë ¬ê³¼ íˆ¬ì˜ í–‰ë ¬ ê²°í•©
-    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);
+    mat4.multiply(projection, viewMatrix, viewProjectionValue);
+
+    lightWorldPositionValue.set([-10, 30, 300]);
+    viewWorldPositionValue.set(eye);
+
+    device.queue.writeBuffer(globalUniformBuffer, 0, globalUniformValues);

    let mathElapsedTimeMs = 0;

    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
        uniformBuffer,
        uniformValues,
        normalMatrixValue,
        worldValue,
-        viewProjectionValue,
        colorValue,
-        lightWorldPositionValue,
-        viewWorldPositionValue,
        shininessValue,

        axis,
        material,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];
      const mathTimeStartMs = performance.now();

-      // ì´ ê°ì²´ì˜ ìœ ë‹ˆí¼ ê°’ì— viewProjectionMatrix ë³µì‚¬
-      viewProjectionValue.set(viewProjectionMatrix);

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

      const {color, shininess} = material;
      colorValue.set(color);
-      lightWorldPositionValue.set([-10, 30, 300]);
-      viewWorldPositionValue.set(eye);
      shininessValue[0] = shininess;

      mathElapsedTimeMs += performance.now() - mathTimeStartMs;

      // ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }

    pass.end();
</pre>
<p>ì´ê²ƒì€ WebGPU í˜¸ì¶œ íšŸìˆ˜ë¥¼ ì¤„ì´ì§€ ì•ŠìŠµë‹ˆë‹¤. ì‹¤ì œë¡œëŠ” í•œë²ˆ ë” í˜¸ì¶œí•©ë‹ˆë‹¤.
í•˜ì§€ë§Œ ëª¨ë¸ë‹¹ ìˆ˜í–‰í•˜ë˜ ë§ì€ ì‘ì—…ì„ ì¤„ì˜€ìŠµë‹ˆë‹¤.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-optimization-step3-global-vs-per-object-uniforms.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-optimization-step3-global-vs-per-object-uniforms.html" target="_blank">ìƒˆ ì°½ìœ¼ë¡œ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</a>
</div>

<p></p>
<p>ì œ ì»´í“¨í„°ì—ì„œëŠ” ì´ ë³€ê²½ìœ¼ë¡œ ìˆ˜í•™ ë¶€ë¶„ì´ ì•½ 16% ê°ì†Œí–ˆìŠµë‹ˆë‹¤.</p>
<h1 id="ìµœì í™”-ë”-ë§ì€-ìœ ë‹ˆí¼-ë¶„ë¦¬">ìµœì í™”: ë” ë§ì€ ìœ ë‹ˆí¼ ë¶„ë¦¬</h1>
<p>3D ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì¼ë°˜ì ì¸ êµ¬ì„±ì€ â€œëª¨ë¸â€(ì •ì  ë°ì´í„°), â€œë¨¸í‹°ë¦¬ì–¼â€(ìƒ‰ìƒ, ê´‘íƒ, í…ìŠ¤ì²˜),
â€œì¡°ëª…â€(ì‚¬ìš©í•  ì¡°ëª…), â€œviewInfoâ€(ë·° ë° íˆ¬ì˜ í–‰ë ¬)ë¥¼ ê°–ëŠ” ê²ƒì…ë‹ˆë‹¤. íŠ¹íˆ ìš°ë¦¬ ì˜ˆì œì—ì„œ
<code class="notranslate" translate="no">color</code>ì™€ <code class="notranslate" translate="no">shininess</code>ëŠ” ì ˆëŒ€ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë§¤ í”„ë ˆì„ë§ˆë‹¤ ìœ ë‹ˆí¼ ë²„í¼ì—
ë³µì‚¬í•˜ëŠ” ê²ƒì€ ë‚­ë¹„ì…ë‹ˆë‹¤.</p>
<p>ë¨¸í‹°ë¦¬ì–¼ë‹¹ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ˆê¸°í™” ì‹œ ë¨¸í‹°ë¦¬ì–¼ ì„¤ì •ì„
ë³µì‚¬í•œ ë‹¤ìŒ ë°”ì¸ë“œ ê·¸ë£¹ì— ì¶”ê°€í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.</p>
<p>ë¨¼ì € ë‹¤ë¥¸ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì…°ì´ë”ë¥¼ ë³€ê²½í•´ ë³´ê² ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    code: /* wgsl */ `
      struct GlobalUniforms {
        viewProjection: mat4x4f,
        lightWorldPosition: vec3f,
        viewWorldPosition: vec3f,
      };

+      struct MaterialUniforms {
+        color: vec4f,
+        shininess: f32,
+      };

      struct PerObjectUniforms {
        normalMatrix: mat3x3f,
        world: mat4x4f,
-        color: vec4f,
-        shininess: f32,
      };

      struct Vertex {
        @location(0) position: vec4f,
        @location(1) normal: vec3f,
        @location(2) texcoord: vec2f,
      };

      struct VSOutput {
        @builtin(position) position: vec4f,
        @location(0) normal: vec3f,
        @location(1) surfaceToLight: vec3f,
        @location(2) surfaceToView: vec3f,
        @location(3) texcoord: vec2f,
      };

      @group(0) @binding(0) var diffuseTexture: texture_2d&lt;f32&gt;;
      @group(0) @binding(1) var diffuseSampler: sampler;
      @group(0) @binding(2) var&lt;uniform&gt; obj: PerObjectUniforms;
      @group(0) @binding(3) var&lt;uniform&gt; glb: GlobalUniforms;
+      @group(0) @binding(4) var&lt;uniform&gt; material: MaterialUniforms;

      @vertex fn vs(vert: Vertex) -&gt; VSOutput {
        var vsOut: VSOutput;
        vsOut.position = glb.viewProjection * obj.world * vert.position;

        // ë…¸ë©€ì„ ë³€í™˜í•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.normal = obj.normalMatrix * vert.normal;

        // í‘œë©´ì˜ ì›”ë“œ ìœ„ì¹˜ ê³„ì‚°
        let surfaceWorldPosition = (obj.world * vert.position).xyz;

        // í‘œë©´ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.surfaceToLight = glb.lightWorldPosition - surfaceWorldPosition;

        // í‘œë©´ì—ì„œ ë·°ë¡œì˜ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³ 
        // í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.surfaceToView = glb.viewWorldPosition - surfaceWorldPosition;

        // í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ í”„ë˜ê·¸ë¨¼íŠ¸ ì…°ì´ë”ë¡œ ì „ë‹¬
        vsOut.texcoord = vert.texcoord;

        return vsOut;
      }

      @fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
        // vsOut.normalì€ ìŠ¤í…Œì´ì§€ ê°„ ë³€ìˆ˜ì´ë¯€ë¡œ
        // ë³´ê°„ë˜ì–´ ë‹¨ìœ„ ë²¡í„°ê°€ ì•„ë‹™ë‹ˆë‹¤.
        // ì •ê·œí™”í•˜ë©´ ë‹¤ì‹œ ë‹¨ìœ„ ë²¡í„°ê°€ ë©ë‹ˆë‹¤
        let normal = normalize(vsOut.normal);

        let surfaceToLightDirection = normalize(vsOut.surfaceToLight);
        let surfaceToViewDirection = normalize(vsOut.surfaceToView);
        let halfVector = normalize(
          surfaceToLightDirection + surfaceToViewDirection);

        // ë…¸ë©€ê³¼ ê´‘ì› ë°©í–¥ì˜ ë‚´ì ìœ¼ë¡œ
        // ì¡°ëª…ì„ ê³„ì‚°í•©ë‹ˆë‹¤
        let light = dot(normal, surfaceToLightDirection);

        var specular = dot(normal, halfVector);
        specular = select(
            0.0,                           // ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œì˜ ê°’
            pow(specular, material.shininess),  // ì¡°ê±´ì´ ì°¸ì¼ ë•Œì˜ ê°’
            specular &gt; 0.0);               // ì¡°ê±´

        let diffuse = material.color * textureSample(diffuseTexture, diffuseSampler, vsOut.texcoord);
        // ì•ŒíŒŒê°€ ì•„ë‹Œ ìƒ‰ìƒ ë¶€ë¶„ë§Œ
        // ì¡°ëª… ê³„ì‚°
        let color = diffuse.rgb * light + specular;
        return vec4f(color, diffuse.a);
      }
    `,
  });
</pre>
<p>ê·¸ëŸ° ë‹¤ìŒ ê° ë¨¸í‹°ë¦¬ì–¼ì— ëŒ€í•œ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const numMaterials = 20;
  const materials = [];
  for (let i = 0; i &lt; numMaterials; ++i) {
    const color = hslToRGBA(rand(), rand(0.5, 0.8), rand(0.5, 0.7));
    const shininess = rand(10, 120);

+    const materialValues = new Float32Array([
+      ...color,
+      shininess,
+      0, 0, 0,  // íŒ¨ë”©
+    ]);
+    const materialUniformBuffer = createBufferWithData(
+      device,
+      materialValues,
+      GPUBufferUsage.UNIFORM,
+    );

    materials.push({
-      color,
-      shininess,
+      materialUniformBuffer,
      texture: randomArrayElement(textures),
      sampler,
    });
  }
</pre>
<p>ê°ì²´ë³„ ì •ë³´ë¥¼ ì„¤ì •í•  ë•Œ ë” ì´ìƒ ë¨¸í‹°ë¦¬ì–¼ ì„¤ì •ì„ ì „ë‹¬í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
ëŒ€ì‹  ë¨¸í‹°ë¦¬ì–¼ì˜ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ê°ì²´ì˜ ë°”ì¸ë“œ ê·¸ë£¹ì— ì¶”ê°€í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const maxObjects = 30000;
  const objectInfos = [];

  for (let i = 0; i &lt; maxObjects; ++i) {
-    const uniformBufferSize = (12 + 16 + 4 + 4) * 4;
+    const uniformBufferSize = (12 + 16) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);

    // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
    const kNormalMatrixOffset = 0;
    const kWorldOffset = 12;
-    const kColorOffset = 28;
-    const kShininessOffset = 32;

    const normalMatrixValue = uniformValues.subarray(
        kNormalMatrixOffset, kNormalMatrixOffset + 12);
    const worldValue = uniformValues.subarray(
        kWorldOffset, kWorldOffset + 16);
-    const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
-    const shininessValue = uniformValues.subarray(
-        kShininessOffset, kShininessOffset + 1);

    const material = randomArrayElement(materials);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: material.texture.createView() },
        { binding: 1, resource: material.sampler },
        { binding: 2, resource: { buffer: uniformBuffer }},
        { binding: 3, resource: { buffer: globalUniformBuffer }},
+        { binding: 4, resource: { buffer: material.materialUniformBuffer }},
      ],
    });

    const axis = vec3.normalize([rand(-1, 1), rand(-1, 1), rand(-1, 1)]);
    const radius = rand(10, 100);
    const speed = rand(0.1, 0.4);
    const rotationSpeed = rand(-1, 1);
    const scale = rand(2, 10);

    objectInfos.push({
      bindGroup,

      uniformBuffer,
      uniformValues,

      normalMatrixValue,
      worldValue,
-      colorValue,
-      shininessValue,

      axis,
-      material,
      radius,
      speed,
      rotationSpeed,
      scale,
    });
  }
</pre>
<p>ë˜í•œ ë Œë” ì‹œì ì— ì´ê²ƒë“¤ì„ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
        uniformBuffer,
        uniformValues,
        normalMatrixValue,
        worldValue,
-        colorValue,
-        shininessValue,

        axis,
-        material,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];
      const mathTimeStartMs = performance.now();

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

-      const {color, shininess} = material;
-      colorValue.set(color);
-      shininessValue[0] = shininess;

      mathElapsedTimeMs += performance.now() - mathTimeStartMs;

      // ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-optimization-step4-material-uniforms.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-optimization-step4-material-uniforms.html" target="_blank">ìƒˆ ì°½ìœ¼ë¡œ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</a>
</div>

<p></p>
<h1 id="ìµœì í™”-ë²„í¼-ì˜¤í”„ì…‹ì„-ì‚¬ìš©í•˜ëŠ”-í•˜ë‚˜ì˜-í°-ìœ ë‹ˆí¼-ë²„í¼-ì‚¬ìš©">ìµœì í™”: ë²„í¼ ì˜¤í”„ì…‹ì„ ì‚¬ìš©í•˜ëŠ” í•˜ë‚˜ì˜ í° ìœ ë‹ˆí¼ ë²„í¼ ì‚¬ìš©</h1>
<p>ì§€ê¸ˆ ê° ê°ì²´ëŠ” ìì²´ ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ë Œë” ì‹œê°„ì— ê° ê°ì²´ì— ëŒ€í•´
í•´ë‹¹ ê°ì²´ì˜ ìœ ë‹ˆí¼ ê°’ìœ¼ë¡œ íƒ€ì… ë°°ì—´ì„ ì—…ë°ì´íŠ¸í•œ ë‹¤ìŒ <code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¥¼
í˜¸ì¶œí•˜ì—¬ ë‹¨ì¼ ìœ ë‹ˆí¼ ë²„í¼ì˜ ê°’ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. 8000ê°œì˜ ê°ì²´ë¥¼ ë Œë”ë§í•˜ëŠ” ê²½ìš°
<code class="notranslate" translate="no">device.queue.writeBuffer</code>ì— ëŒ€í•œ 8000ë²ˆì˜ í˜¸ì¶œì´ ìˆìŠµë‹ˆë‹¤.</p>
<p>ëŒ€ì‹  í•˜ë‚˜ì˜ ë” í° ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ê° ê°ì²´ì˜ ë°”ì¸ë“œ ê·¸ë£¹ì„
ì„¤ì •í•˜ì—¬ ë” í° ë²„í¼ì˜ ìì²´ ë¶€ë¶„ì„ ì‚¬ìš©í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë Œë” ì‹œê°„ì— í•˜ë‚˜ì˜
í° íƒ€ì… ë°°ì—´ì—ì„œ ëª¨ë“  ê°ì²´ì— ëŒ€í•œ ëª¨ë“  ê°’ì„ ì—…ë°ì´íŠ¸í•˜ê³  <code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¥¼
í•œ ë²ˆë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©° ì´ê²ƒì´ ë” ë¹ ë¥¼ ê²ƒì…ë‹ˆë‹¤.</p>
<p>ë¨¼ì € í° ìœ ë‹ˆí¼ ë²„í¼ì™€ í° íƒ€ì… ë°°ì—´ì„ í• ë‹¹í•´ ë³´ê² ìŠµë‹ˆë‹¤. ìœ ë‹ˆí¼ ë²„í¼ ì˜¤í”„ì…‹ì—ëŠ”
ê¸°ë³¸ì ìœ¼ë¡œ 256ë°”ì´íŠ¸ì¸ ìµœì†Œ ì •ë ¬ì´ ìˆìœ¼ë¯€ë¡œ ê°ì²´ë‹¹ í•„ìš”í•œ í¬ê¸°ë¥¼ 256ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ
ì˜¬ë¦¼í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+/** vë¥¼ alignmentì˜ ë°°ìˆ˜ë¡œ ì˜¬ë¦¼ */
+const roundUp = (v, alignment) =&gt; Math.ceil(v / alignment) * alignment;

  ...

+  const uniformBufferSize = (12 + 16) * 4;
+  const uniformBufferSpace = roundUp(uniformBufferSize, device.limits.minUniformBufferOffsetAlignment);
+  const uniformBuffer = device.createBuffer({
+    label: 'uniforms',
+    size: uniformBufferSpace * maxObjects,
+    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+  });
+  const uniformValues = new Float32Array(uniformBuffer.size / 4);
</pre>
<p>ì´ì œ ê°ì²´ë³„ ë·°ë¥¼ í•´ë‹¹ í° íƒ€ì… ë°°ì—´ì„ ë°”ë¼ë³´ë„ë¡ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë˜í•œ ë°”ì¸ë“œ ê·¸ë£¹ì´ í° ìœ ë‹ˆí¼ ë²„í¼ì˜ ì˜¬ë°”ë¥¸ ë¶€ë¶„ì„ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  for (let i = 0; i &lt; maxObjects; ++i) {
+    const uniformBufferOffset = i * uniformBufferSpace;
+    const f32Offset = uniformBufferOffset / 4;

    // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
    const kNormalMatrixOffset = 0;
    const kWorldOffset = 12;

-    const normalMatrixValue = uniformValues.subarray(
-        kNormalMatrixOffset, kNormalMatrixOffset + 12);
-    const worldValue = uniformValues.subarray(
-        kWorldOffset, kWorldOffset + 16);
+    const normalMatrixValue = uniformValues.subarray(
+        f32Offset + kNormalMatrixOffset, f32Offset + kNormalMatrixOffset + 12);
+    const worldValue = uniformValues.subarray(
+        f32Offset + kWorldOffset, f32Offset + kWorldOffset + 16);

    const material = randomArrayElement(materials);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: material.texture.createView() },
        { binding: 1, resource: material.sampler },
-        { binding: 2, resource: { buffer: uniformBuffer }},
+        {
+          binding: 2,
+          resource: {
+            buffer: uniformBuffer,
+            offset: uniformBufferOffset,
+            size: uniformBufferSize,
+          },
+        },
        { binding: 3, resource: { buffer: globalUniformBuffer }},
        { binding: 4, resource: { buffer: material.materialUniformBuffer }},
      ],
    });

    const axis = vec3.normalize([rand(-1, 1), rand(-1, 1), rand(-1, 1)]);
    const radius = rand(10, 100);
    const speed = rand(0.1, 0.4);
    const rotationSpeed = rand(-1, 1);
    const scale = rand(2, 10);

    objectInfos.push({
      bindGroup,

-      uniformBuffer,
-      uniformValues,

      normalMatrixValue,
      worldValue,

      axis,
      radius,
      speed,
      rotationSpeed,
      scale,
    });
  }
</pre>
<p>ë Œë” ì‹œì ì— ëª¨ë“  ê°ì²´ ê°’ì„ ì—…ë°ì´íŠ¸í•œ ë‹¤ìŒ <code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¥¼
í•œ ë²ˆë§Œ í˜¸ì¶œí•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
-        uniformBuffer,
-        uniformValues,
        normalMatrixValue,
        worldValue,

        axis,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];
      const mathTimeStartMs = performance.now();

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

      mathElapsedTimeMs += performance.now() - mathTimeStartMs;

-      // ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
-      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }

+    // ëª¨ë“  ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
+    if (settings.numObjects) {
+      const size = (settings.numObjects - 1) * uniformBufferSpace + uniformBufferSize;
+      device.queue.writeBuffer( uniformBuffer, 0, uniformValues, 0, size / uniformValues.BYTES_PER_ELEMENT);
+    }

    pass.end();
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-optimization-step5-use-buffer-offsets.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-optimization-step5-use-buffer-offsets.html" target="_blank">ìƒˆ ì°½ìœ¼ë¡œ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</a>
</div>

<p></p>
<p>ì œ ì»´í“¨í„°ì—ì„œëŠ” JavaScript ì‹œê°„ì´ 40% ì¤„ì—ˆìŠµë‹ˆë‹¤!</p>
<h1 id="ìµœì í™”-ë§¤í•‘ëœ-ë²„í¼-ì‚¬ìš©">ìµœì í™”: ë§¤í•‘ëœ ë²„í¼ ì‚¬ìš©</h1>
<p><code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¥¼ í˜¸ì¶œí•˜ë©´ WebGPUëŠ” íƒ€ì… ë°°ì—´ì˜ ë°ì´í„°ë¥¼ ë³µì‚¬í•©ë‹ˆë‹¤.
í•´ë‹¹ ë°ì´í„°ë¥¼ GPU í”„ë¡œì„¸ìŠ¤(ë³´ì•ˆì„ ìœ„í•´ GPUì™€ í†µì‹ í•˜ëŠ” ë³„ë„ì˜ í”„ë¡œì„¸ìŠ¤)ë¡œ ë³µì‚¬í•©ë‹ˆë‹¤.
GPU í”„ë¡œì„¸ìŠ¤ì—ì„œ í•´ë‹¹ ë°ì´í„°ëŠ” GPU ë²„í¼ë¡œ ë³µì‚¬ë©ë‹ˆë‹¤.</p>
<p>ë§¤í•‘ëœ ë²„í¼ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ëŸ¬í•œ ë³µì‚¬ ì¤‘ í•˜ë‚˜ë¥¼ ê±´ë„ˆë›¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë²„í¼ë¥¼ ë§¤í•‘í•˜ê³ 
ìœ ë‹ˆí¼ ê°’ì„ í•´ë‹¹ ë§¤í•‘ëœ ë²„í¼ì— ì§ì ‘ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ë²„í¼ë¥¼ ì–¸ë§µí•˜ê³ 
<code class="notranslate" translate="no">copyBufferToBuffer</code> ëª…ë ¹ì„ ë°œí–‰í•˜ì—¬ ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë³µì‚¬ê°€
í•˜ë‚˜ ì ˆì•½ë©ë‹ˆë‹¤.</p>
<p>WebGPU ë§¤í•‘ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ë°œìƒí•˜ë¯€ë¡œ ë²„í¼ë¥¼ ë§¤í•‘í•˜ê³  ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ëŒ€ì‹ 
ì´ë¯¸ ë§¤í•‘ëœ ë²„í¼ì˜ ë°°ì—´ì„ ìœ ì§€í•©ë‹ˆë‹¤. ê° í”„ë ˆì„ë§ˆë‹¤ ì´ë¯¸ ë§¤í•‘ëœ ë²„í¼ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜
ì´ë¯¸ ë§¤í•‘ëœ ìƒˆ ë²„í¼ë¥¼ ë§Œë“­ë‹ˆë‹¤. ë Œë”ë§í•œ í›„ ë²„í¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì„ ë•Œ ë§¤í•‘í•˜ë„ë¡
ì½œë°±ì„ ì„¤ì •í•˜ê³  ì´ë¯¸ ë§¤í•‘ëœ ë²„í¼ ëª©ë¡ì— ë‹¤ì‹œ ë„£ìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë§¤í•‘ëœ ë²„í¼ë¥¼
ê¸°ë‹¤ë¦´ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
<p>ë¨¼ì € ë§¤í•‘ëœ ë²„í¼ì˜ ë°°ì—´ê³¼ ì‚¬ì „ ë§¤í•‘ëœ ë²„í¼ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ìƒˆ ë²„í¼ë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜ë¥¼
ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const mappedTransferBuffers = [];
  const getMappedTransferBuffer = () =&gt; {
    return mappedTransferBuffers.pop() || device.createBuffer({
      label: 'transfer buffer',
      size: uniformBufferSpace * maxObjects,
      usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
      mappedAtCreation: true,
    });
  };
</pre>
<p>ë²„í¼ë¥¼ ë§¤í•‘í•˜ë©´ ìƒˆë¡œìš´ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a>ê°€ ì–»ì–´ì§€ë¯€ë¡œ ë” ì´ìƒ íƒ€ì… ë°°ì—´ ë·°ë¥¼
ë¯¸ë¦¬ ë§Œë“¤ì–´ ë‘˜ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë§¤í•‘ í›„ ìƒˆ íƒ€ì… ë°°ì—´ ë·°ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
+  const kNormalMatrixOffset = 0;
+  const kWorldOffset = 12;

  for (let i = 0; i &lt; maxObjects; ++i) {
    const uniformBufferOffset = i * uniformBufferSpace;
-    const f32Offset = uniformBufferOffset / 4;
-
-    // float32 ì¸ë±ìŠ¤ì—ì„œ ë‹¤ì–‘í•œ ìœ ë‹ˆí¼ ê°’ì— ëŒ€í•œ ì˜¤í”„ì…‹
-    const kNormalMatrixOffset = 0;
-    const kWorldOffset = 12;
-
-    const normalMatrixValue = uniformValues.subarray(
-        f32Offset + kNormalMatrixOffset, f32Offset + kNormalMatrixOffset + 12);
-    const worldValue = uniformValues.subarray(
-        f32Offset + kWorldOffset, f32Offset + kWorldOffset + 16);
-    const material = randomArrayElement(materials);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: material.texture.createView() },
        { binding: 1, resource: material.sampler },
        { binding: 2, resource: { buffer: uniformBuffer, offset: uniformBufferOffset, size: uniformBufferSize }},
        { binding: 3, resource: { buffer: globalUniformBuffer }},
        { binding: 4, resource: { buffer: material.materialUniformBuffer }},
      ],
    });

    const axis = vec3.normalize([rand(-1, 1), rand(-1, 1), rand(-1, 1)]);
    const radius = rand(10, 100);
    const speed = rand(0.1, 0.4);
    const rotationSpeed = rand(-1, 1);
    const scale = rand(2, 10);

    objectInfos.push({
      bindGroup,

-      normalMatrixValue,
-      worldValue,

      axis,
      radius,
      speed,
      rotationSpeed,
      scale,
    });
  }
</pre>
<p>ë Œë” ì‹œì ì— ê°ì²´ë“¤ì„ ë°˜ë³µ(ìˆœíšŒ)í•˜ê¸° <em>ì „ì—</em> ì „ì†¡ ë²„í¼ë¥¼ ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬í•˜ëŠ” ëª…ë ¹ì„
ì¸ì½”ë”©í•©ë‹ˆë‹¤. ì´ëŠ” <code class="notranslate" translate="no">copyBufferToBuffer</code> ëª…ë ¹ì´ <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandEncoder"><code class="notranslate" translate="no">GPUCommandEncoder</code></a>ì˜ ëª…ë ¹ì´ê¸°
ë•Œë¬¸ì…ë‹ˆë‹¤. ê°ì²´ê°€ ë Œë”ë§ë˜ê¸° ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ê°ì²´ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ë Œë” íŒ¨ìŠ¤
ëª…ë ¹ì„ ì¸ì½”ë”©í•˜ì—¬ ë Œë”ë§í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ì „ì—ëŠ” íƒ€ì… ë°°ì—´ì„ ì—…ë°ì´íŠ¸í•œ í›„
<code class="notranslate" translate="no">device.queue.writeBuffer</code>ë¥¼ í˜¸ì¶œí–ˆì—ˆê³ , ì´ëŠ” ë‹¹ì—°í•˜ê²Œë„ ê°€ì¥ ë¨¼ì € ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.
ì•„ì§ <code class="notranslate" translate="no">submit</code>ì„ í˜¸ì¶œí•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì´ì£ .
í•˜ì§€ë§Œ ì´ë²ˆ ê²½ìš° ë³µì‚¬ëŠ” ì‹¤ì œë¡œ ëª…ë ¹ì´ë¯€ë¡œ ê·¸ë¦¬ê¸° ëª…ë ¹ ì „ì— ì¸ì½”ë”©í•´ì•¼ í•©ë‹ˆë‹¤. ì´ê²ƒì€ ê´œì°®ìŠµë‹ˆë‹¤.
ì™œëƒí•˜ë©´ ì—¬ê¸°ì„œ ë³µì‚¬ëŠ” ë‹¨ì§€ ëª…ë ¹ì¼ ë¿ì´ê³  ì»¤ë§¨ë“œ ë²„í¼ë¥¼ ì œì¶œí•  ë•Œê¹Œì§€ ì‹¤í–‰ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
ë³µì‚¬ê°€ ì•„ì§ ë°œìƒí•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì—¬ì „íˆ ì „ì†¡ ë²„í¼ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const encoder = device.createCommandEncoder();
-    const pass = timingHelper.beginRenderPass(encoder, renderPassDescriptor);
-    pass.setPipeline(pipeline);
-    pass.setVertexBuffer(0, vertexBuffer);
-    pass.setIndexBuffer(indicesBuffer, 'uint16');

    ...

    let mathElapsedTimeMs = 0;

+    const transferBuffer = getMappedTransferBuffer();
+    const uniformValues = new Float32Array(transferBuffer.getMappedRange());

+    // ì „ì†¡ ë²„í¼ì˜ ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬
+    if (settings.numObjects) {
+      // ê¸°ì–µí•˜ì„¸ìš”, ì´ê²ƒì€ ë‚˜ì¤‘ì— ì‹¤í–‰ë  ëª…ë ¹ì„ ì¸ì½”ë”©í•˜ëŠ” ê²ƒì¼ ë¿ì…ë‹ˆë‹¤.
+      const size = (settings.numObjects - 1) * uniformBufferSpace + uniformBufferSize;
+      encoder.copyBufferToBuffer(transferBuffer, 0, uniformBuffer, 0, size);
+    }

+    const pass = timingHelper.beginRenderPass(encoder, renderPassDescriptor);
+    pass.setPipeline(pipeline);
+    pass.setVertexBuffer(0, vertexBuffer);
+    pass.setIndexBuffer(indicesBuffer, 'uint16');

    for (let i = 0; i &lt; settings.numObjects; ++i) {
      const {
        bindGroup,
-        normalMatrixValue,
-        worldValue,
        axis,
        radius,
        speed,
        rotationSpeed,
        scale,
      } = objectInfos[i];
      const mathTimeStartMs = performance.now();

+      // ë§¤í•‘ëœ ë²„í¼ë¡œ ë·°ë¥¼ ë§Œë“­ë‹ˆë‹¤.
+      const uniformBufferOffset = i * uniformBufferSpace;
+      const f32Offset = uniformBufferOffset / 4;
+      const normalMatrixValue = uniformValues.subarray(
+          f32Offset + kNormalMatrixOffset, f32Offset + kNormalMatrixOffset + 12);
+      const worldValue = uniformValues.subarray(
+          f32Offset + kWorldOffset, f32Offset + kWorldOffset + 16);

      // ì›”ë“œ í–‰ë ¬ ê³„ì‚°
      mat4.identity(worldValue);
      mat4.axisRotate(worldValue, axis, i + time * speed, worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 3.721 + time * speed) * radius], worldValue);
      mat4.translate(worldValue, [0, 0, Math.sin(i * 9.721 + time * 0.1) * radius], worldValue);
      mat4.rotateX(worldValue, time * rotationSpeed + i, worldValue);
      mat4.scale(worldValue, [scale, scale, scale], worldValue);

      // ì—­í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬ì„ normalMatrix ê°’ì— ì €ì¥
      mat3.fromMat4(mat4.transpose(mat4.inverse(worldValue)), normalMatrixValue);

      mathElapsedTimeMs += performance.now() - mathTimeStartMs;

      pass.setBindGroup(0, bindGroup);
      pass.drawIndexed(numVertices);
    }
+    transferBuffer.unmap();

-    // ëª¨ë“  ìœ ë‹ˆí¼ ê°’ì„ ìœ ë‹ˆí¼ ë²„í¼ì— ì—…ë¡œë“œ
-    if (settings.numObjects) {
-      const size = (settings.numObjects - 1) * uniformBufferSpace + uniformBufferSize;
-      device.queue.writeBuffer( uniformBuffer, 0, uniformValues, 0, size / uniformValues.BYTES_PER_ELEMENT);
-    }

    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
</pre>
<p>ë§ˆì§€ë§‰ìœ¼ë¡œ ì»¤ë§¨ë“œ ë²„í¼ë¥¼ ì œì¶œí•˜ìë§ˆì ë²„í¼ë¥¼ ë‹¤ì‹œ ë§¤í•‘í•©ë‹ˆë‹¤.
ë§¤í•‘ì€ ë¹„ë™ê¸°ì ì´ë¯€ë¡œ ìµœì¢…ì ìœ¼ë¡œ ì¤€ë¹„ë˜ë©´ ì´ë¯¸ ë§¤í•‘ëœ ë²„í¼ ëª©ë¡ì— ë‹¤ì‹œ ì¶”ê°€í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

+    transferBuffer.mapAsync(GPUMapMode.WRITE).then(() =&gt; {
+      mappedTransferBuffers.push(transferBuffer);
+    });
</pre>
<p>ì œ ì»´í“¨í„°ì—ì„œ ì´ ë²„ì „ì€ 75fpsì—ì„œ ì•½ 15000ê°œì˜ ê°ì²´ë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
ì²« ë²„ì „ë³´ë‹¤ ì•½ 87% ë” ë§ìŠµë‹ˆë‹¤.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-optimization-step6-use-mapped-buffers.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-optimization-step6-use-mapped-buffers.html" target="_blank">ìƒˆ ì°½ìœ¼ë¡œ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</a>
</div>

<p></p>
<p>â€˜renderâ€™ ì²´í¬ë¥¼ í•´ì œí•˜ë©´ ì°¨ì´ê°€ í›¨ì”¬ ë” í½ë‹ˆë‹¤. ì €ëŠ” ì›ë˜ ìµœì í™”ë˜ì§€ ì•Šì€
ì˜ˆì œì—ì„œ 75fpsì—ì„œ 9000ê°œë¥¼ ê·¸ë ¸ì—ˆê³  ì´ ë§ˆì§€ë§‰ ë²„ì „ì—ì„œ 75fpsì—ì„œ 18000ê°œë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
2ë°° ì†ë„ í–¥ìƒì…ë‹ˆë‹¤!</p>
<p>ë„ì›€ì´ <em>ë  ìˆ˜ ìˆëŠ”</em> ë‹¤ë¥¸ ê²ƒë“¤</p>
<ul>
<li>
<p><strong>í° ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì´ì¤‘ ë²„í¼ë§</strong></p>
<p>WebGPUëŠ” í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ë²„í¼ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ë§ì´ ë©ë‹ˆë‹¤.</p>
<p>ë Œë”ë§ì„ ì‹œì‘í•œë‹¤ê³  ìƒìƒí•´ ë³´ì„¸ìš”(<code class="notranslate" translate="no">device.queue.submit</code>ì„ í˜¸ì¶œ).
GPUëŠ” í° ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì‚¬ìš©í•˜ì—¬ ë Œë”ë§ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì¦‰ì‹œ í•´ë‹¹ ë²„í¼ë¥¼
ì—…ë°ì´íŠ¸í•˜ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤. ì´ ê²½ìš° WebGPUëŠ” ì¼ì‹œ ì¤‘ì§€í•˜ê³  GPUê°€ ë Œë”ë§ì—
ë²„í¼ ì‚¬ìš©ì„ ì™„ë£Œí•  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•©ë‹ˆë‹¤.</p>
<p>ì´ê²ƒì€ ìœ„ì˜ ì˜ˆì œì—ì„œ ë°œìƒí•  ê°€ëŠ¥ì„±ì´ ë‚®ìŠµë‹ˆë‹¤. ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì§ì ‘ ì—…ë°ì´íŠ¸í•˜ì§€
ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  ì „ì†¡ ë²„í¼ë¥¼ ì—…ë°ì´íŠ¸í•œ ë‹¤ìŒ ë‚˜ì¤‘ì— GPUì— ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬í•˜ë„ë¡
ìš”ì²­í•©ë‹ˆë‹¤.</p>
<p>ì´ ë¬¸ì œëŠ” ì»´í“¨íŠ¸ ì…°ì´ë”ë¥¼ ì‚¬ìš©í•˜ì—¬ GPUì—ì„œ ì§ì ‘ ë²„í¼ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²½ìš°
ë°œìƒí•  ê°€ëŠ¥ì„±ì´ ë” ë†’ìŠµë‹ˆë‹¤.</p>
</li>
<li>
<p><strong>ì˜¤í”„ì…‹ìœ¼ë¡œ í–‰ë ¬ ìˆ˜í•™ ê³„ì‚°</strong></p>
<p><a href="webgpu-matrix-math.html">í–‰ë ¬ ìˆ˜í•™ì— ê´€í•œ ì‹œë¦¬ì¦ˆ</a>ì—ì„œ ë§Œë“  ìˆ˜í•™ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ”
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a>ë¥¼ ì¶œë ¥ìœ¼ë¡œ ìƒì„±í•˜ê³  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a>ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ìŠµë‹ˆë‹¤.
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a>ë¥¼ ì œìë¦¬ì—ì„œ ìˆ˜ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì˜¤í”„ì…‹ ê°’ì„ ì‚¬ìš©í•˜ì—¬
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a>ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.</p>
<p>ê·¸ë ‡ê¸° ë•Œë¬¸ì— ê°ì²´ë³„ ìœ ë‹ˆí¼ ê°’ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë£¨í”„ì—ì„œ ê° ê°ì²´ì— ëŒ€í•´ ë§¤í•‘ëœ ë²„í¼ì—
2ê°œì˜ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> ë·°ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. 20000ê°œì˜ ê°ì²´ì˜ ê²½ìš°
ì´ëŸ¬í•œ ì„ì‹œ ë·°ë¥¼ 40000ê°œ ë§Œë“œëŠ” ê²ƒì…ë‹ˆë‹¤.</p>
<p>ëª¨ë“  ì…ë ¥ì— ì˜¤í”„ì…‹ì„ ì¶”ê°€í•˜ë©´ ì œ ìƒê°ì—ëŠ” ì‚¬ìš©í•˜ê¸° ë²ˆê±°ë¡œì›Œì§ˆ ê²ƒ ê°™ì§€ë§Œ,
í…ŒìŠ¤íŠ¸ ì‚¼ì•„ì„œ ì˜¤í”„ì…‹ì„ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •í•œ ìˆ˜í•™ í•¨ìˆ˜ë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤.
ë‹¤ì‹œ ë§í•´ì„œ:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    mat4.multiply(a, b, dst);
</pre>
<p>ìœ„ì˜ ê²ƒì´ ì•„ë˜ê²ƒ ì²˜ëŸ¼ ë°”ë€ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   mat4.multiply(a, aOffset, b, bOffset, dst, dstOffset);
</pre>
<p><a href="../../webgpu-optimization-step6-use-mapped-buffers-math-w-offsets.html">ì˜¤í”„ì…‹ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì•½ 7% ë” ë¹ ë¥¸ ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤</a>.</p>
<p>ì´ê²ƒì´ ê°€ì¹˜ê°€ ìˆë‹¤ê³  ë³¼ì§€ ì—¬ë¶€ëŠ” ì—¬ëŸ¬ë¶„ì—ê²Œ ë‹¬ë ¤ ìˆìŠµë‹ˆë‹¤. ì € ê°œì¸ì ìœ¼ë¡œëŠ”
ê¸€ë¨¸ë¦¬ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ ì‚¬ìš©í•˜ê¸° ê°„ë‹¨í•˜ê²Œ ìœ ì§€í•˜ëŠ” ê²ƒì„ ì„ í˜¸í•©ë‹ˆë‹¤. ì €ëŠ” 10000ê°œì˜
ë¬¼ì²´ë¥¼ ê·¸ë¦¬ë ¤ê³  í•˜ëŠ” ê²½ìš°ê°€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë” ì„±ëŠ¥ì„ ì§œë‚´ê³  ì‹¶ë‹¤ë©´
ì—¬ê¸°ê°€ ë“¤ì—¬ë‹¤ ë³¼ë§Œí•œ ê³³ì´ë¼ëŠ” ê²ƒì€ ì•Œì•„ë‘ì„¸ìš”. ì €ëŠ” ê·¸ë ‡ê²Œê¹Œì§€ ê°€ì•¼í•œë‹¤ë©´
WebAssemblyë¥¼ ë“¤ì—¬ë‹¤ ë³¼ ê²ƒ ê°™ìŠµë‹ˆë‹¤.</p>
</li>
<li>
<p><strong>ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì§ì ‘ ë§¤í•‘</strong></p>
<p>ìœ„ì˜ ì˜ˆì œì—ì„œ ìš°ë¦¬ëŠ” <code class="notranslate" translate="no">COPY_SRC</code>ì™€ <code class="notranslate" translate="no">MAP_WRITE</code> ì‚¬ìš© í”Œë˜ê·¸ë§Œ ìˆëŠ” ë²„í¼ì¸
ì „ì†¡ ë²„í¼ë¥¼ ë§¤í•‘í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ <code class="notranslate" translate="no">encoder.copyBufferToBuffer</code>ë¥¼ í˜¸ì¶œí•˜ì—¬
í•´ë‹¹ ë²„í¼ì˜ ë‚´ìš©ì„ ì‹¤ì œ ìœ ë‹ˆí¼ ë²„í¼ë¡œ ë³µì‚¬í•´ì•¼ í•©ë‹ˆë‹¤.</p>
<p>ìœ ë‹ˆí¼ ë²„í¼ë¥¼ ì§ì ‘ ë§¤í•‘í•˜ê³  ë³µì‚¬ë¥¼ í”¼í•  ìˆ˜ ìˆë‹¤ë©´ í›¨ì”¬ ì¢‹ì„ ê²ƒì…ë‹ˆë‹¤.
ë¶ˆí–‰íˆë„ ì´ ê¸°ëŠ¥ì€ WebGPU ë²„ì „ 1ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ì§€ë§Œ í–¥í›„ ì„ íƒì  ê¸°ëŠ¥ìœ¼ë¡œ
ê³ ë ¤ë˜ê³  ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì¼ë¶€ ARM ê¸°ë°˜ ì¥ì¹˜ì™€ ê°™ì€ <em>í†µí•© ë©”ëª¨ë¦¬ ì•„í‚¤í…ì²˜</em>ì˜ ê²½ìš°ì— í•œí•´ì„œ ì…ë‹ˆë‹¤.</p>
</li>
<li>
<p><strong>ê°„ì ‘ ê·¸ë¦¬ê¸°</strong></p>
<p>ê°„ì ‘ ê·¸ë¦¬ê¸°ëŠ” GPU ë²„í¼ë¥¼ í†µí•´ì„œ ë§¤ê°œë³€ìˆ˜ë¥¼ ë„˜ê¸°ëŠ” ê·¸ë¦¬ê¸° ëª…ë ¹ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);  // ì§ì ‘
pass.drawIndirect(someBuffer, offsetIntoSomeBuffer);                // ê°„ì ‘
</pre>
<p>ìœ„ì˜ ê°„ì ‘ ê·¸ë¦¬ê¸°ì˜ ê²½ìš° <code class="notranslate" translate="no">someBuffer</code>ëŠ” <code class="notranslate" translate="no">[vertexCount, instanceCount, firstVertex, firstInstance]</code>ë¥¼
ë³´ìœ í•˜ëŠ” GPU ë²„í¼ì˜ 16ë°”ì´íŠ¸ í¬ê¸°ì˜ ë¶€ë¶„ ì˜ì—­ì…ë‹ˆë‹¤.</p>
<p>ê°„ì ‘ ê·¸ë¦¬ê¸°ì˜ ì¥ì ì€ GPU ìì²´ê°€ ê°’ì„ ì±„ìš¸ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.
ë¬´ì–¸ê°€ë¥¼ ê·¸ë¦¬ì§€ ì•Šê³  ì‹¶ì„ ë•Œ GPUê°€ <code class="notranslate" translate="no">vertexCount</code> ë°/ë˜ëŠ” <code class="notranslate" translate="no">instanceCount</code>ë¥¼
0ìœ¼ë¡œ ì„¤ì •í•˜ë„ë¡ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.</p>
<p>ì˜ˆë¥¼ ë“¤ì–´ ê°„ì ‘ ê·¸ë¦¬ê¸°ë¥¼ ì‚¬ìš©í•˜ë©´ ëª¨ë“  ê°ì²´ì˜ ê²½ê³„ ìƒì ë˜ëŠ” ê²½ê³„ êµ¬ë¥¼ GPUì—
ì „ë‹¬í•œ ë‹¤ìŒ GPUê°€ í”„ëŸ¬ìŠ¤í…€ ì»¬ë§ì„ ìˆ˜í–‰í•˜ë„ë¡ í•˜ê³  ê°ì²´ê°€ í”„ëŸ¬ìŠ¤í…€ ë‚´ë¶€ì— ìˆëŠ”ì§€<br>
ì—¬ë¶€ì— ë”°ë¼ í•´ë‹¹ ê°ì²´ì˜ ê°„ì ‘ ê·¸ë¦¬ê¸° ë§¤ê°œë³€ìˆ˜ë¥¼ ê²°ì •í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
"í”„ëŸ¬ìŠ¤í…€ ì»¬ë§"ì€ ê°ì²´ê°€ ì¹´ë©”ë¼ì˜ í”„ëŸ¬ìŠ¤í…€ ë‚´ë¶€ì— ìˆì„ ê°€ëŠ¥ì„±ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë©‹ì§„ ë°©ë²•ì…ë‹ˆë‹¤.
<a href="webgpu-persective-projection.html">ì›ê·¼ íˆ¬ì˜ì— ê´€í•œ ê¸€</a>ì—ì„œ í”„ëŸ¬ìŠ¤í…€ì— ëŒ€í•´
ë‹¤ë£¹ë‹ˆë‹¤.</p>
</li>
<li>
<p><strong>ë Œë” ë²ˆë“¤</strong></p>
<p>ë Œë” ë²ˆë“¤ì„ ì‚¬ìš©í•˜ë©´ ë§ì€ ì»¤ë§¨ë“œ ë²„í¼ ëª…ë ¹ì„ ë¯¸ë¦¬ ê¸°ë¡í•œ ë‹¤ìŒ ë‚˜ì¤‘ì— ì‹¤í–‰í•˜ë„ë¡
ìš”ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ íŠ¹íˆ ì”¬(Scene)ì´ ë¹„êµì  ì •ì ì¸ ê²½ìš°, ì¦‰ ë‚˜ì¤‘ì— ê°ì²´ë¥¼
ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•  í•„ìš”ê°€ ì—†ëŠ” ê²½ìš° ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p>ë Œë” ë²ˆë“¤, ê°„ì ‘ ê·¸ë¦¬ê¸°, GPU í”„ëŸ¬ìŠ¤í…€ ì»¬ë§ì„ ê²°í•©í•˜ì—¬ íŠ¹ìˆ˜í•œ ìƒí™©ì—ì„œ ë” ì¢‹ì€
ì„±ëŠ¥ì„ ì–»ê¸° ìœ„í•œ ëª‡ ê°€ì§€ ì•„ì´ë””ì–´ë¥¼ ë³´ì—¬ì£¼ëŠ” í›Œë¥­í•œ ê¸€ì´
<a href="https://toji.dev/webgpu-best-practices/render-bundles">ì—¬ê¸°</a>ì— ìˆìŠµë‹ˆë‹¤.</p>
</li>
</ul>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-optimization.html">English
    </option><option value="/webgpu/lessons/es/webgpu-optimization.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-optimization.html">æ—¥æœ¬èª
    </option><option value="/webgpu/lessons/ko/webgpu-optimization.html" selected="">í•œêµ­ì–´
    </option><option value="/webgpu/lessons/ru/webgpu-optimization.html">Ğ ÑƒÑÑĞºĞ¸Ğ¹
    </option><option value="/webgpu/lessons/tr/webgpu-optimization.html">TÃ¼rkÃ§e
    </option><option value="/webgpu/lessons/uk/webgpu-optimization.html">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°
    </option><option value="/webgpu/lessons/zh_cn/webgpu-optimization.html">ç®€ä½“ä¸­æ–‡
</option></select>


        <div id="toc">
          <ul>  <li>ê¸°ì´ˆ</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">ê¸°ì´ˆ</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">ìŠ¤í…Œì´ì§€ê°„ ë³€ìˆ˜(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">ìŠ¤í† ë¦¬ì§€ ë²„í¼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">ì •ì  ë²„í¼</a></li>
  <li>í…ìŠ¤ì²˜</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">í…ìŠ¤ì²˜</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">ì´ë¯¸ì§€ ë¡œë”©</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">ë¹„ë””ì˜¤ ì‚¬ìš©í•˜ê¸°</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">íë¸Œë§µ(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">ìŠ¤í† ë¦¬ì§€ í…ìŠ¤ì²˜</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">ë©€í‹° ìƒ˜í”Œë§ / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">ìƒìˆ˜(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">ë°ì´í„° ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">ë°”ì¸ë“œ ê·¸ë£¹ ë ˆì´ì•„ì›ƒ</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">ë°ì´í„° ë³µì‚¬í•˜ê¸°</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">ì„ íƒì  ê¸°ëŠ¥(optional feature)ê³¼ ì œí•œ(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">íƒ€ì´ë° ì„±ëŠ¥</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">ë™ì‘ ë°©ì‹</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D ìˆ˜í•™</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>ì¡°ëª…</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>ê¸°ë²•</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>í›„ì²˜ë¦¬</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-post-processing.html">Basic CRT Effect</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-image-adjustments.html">Image Adjustments</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-1dlut.html">1D Lookup Table (LUT)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-3dlut.html">3D Lookup Table (LUT)</a></li>
        </ul>
  <li>Editor</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-highlighting.html">Highlighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-camera-controls.html">Camera Controls</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-picking.html">Picking</a></li>
        </ul>
        </ul>
  <li>ì»´í“¨íŠ¸ ì…°ì´ë”</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">ì»´í“¨íŠ¸ ì…°ì´ë” ê¸°ì´ˆ</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">ì´ë¯¸ì§€ íˆìŠ¤í† ê·¸ë¨</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">ì´ë¯¸ì§€ íˆìŠ¤í† ê·¸ë¨ Part 2</a></li>
        </ul>
  <li>ê¸°íƒ€</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">ì†ë„ì™€ ìµœì í™”</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-debugging.html">ë””ë²„ê¹…ê³¼ ì—ëŸ¬</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">ë¦¬ì†ŒìŠ¤ / ì°¸ê³ ìë£Œ</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>ì§ˆë¬¸ì´ ìˆë‚˜ìš”? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>ì— ë¬¼ì–´ë³´ì„¸ìš”.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">ì œì•ˆ</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">ìš”ì²­ ì‚¬í•­</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">ì´ìŠˆ</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">ë²„ê·¸</a>
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU ì†ë„ì™€ ìµœì í™”`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>ë‹˜<br> ë‹¹ì‹ ì˜ <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} ê¸°ì—¬ì— ê°ì‚¬ë“œë¦½ë‹ˆë‹¤.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/js/prettify.js"></script>
<script src="/webgpu/lessons/resources/js/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>