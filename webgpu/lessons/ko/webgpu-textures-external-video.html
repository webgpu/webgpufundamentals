<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ko/webgpu-textures-external-video.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGPU에서 비디오를 사용하는 방법">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_ko.jpg">

<meta property="og:title" content="WebGPU 비디오의 효율적인 사용">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_ko.jpg">
<meta property="og:description" content="WebGPU에서 비디오를 사용하는 방법">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU 비디오의 효율적인 사용">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html">
<meta name="twitter:description" content="WebGPU에서 비디오를 사용하는 방법">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html",
      "inLanguage":"ko",
      "name":"WebGPU 비디오의 효율적인 사용",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ko/webgpu-textures-external-video.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU 비디오의 효율적인 사용</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-textures-external-video.html">English
    </option><option value="/webgpu/lessons/es/webgpu-textures-external-video.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-textures-external-video.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-textures-external-video.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-textures-external-video.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-textures-external-video.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-textures-external-video.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-textures-external-video.html">简体中文
</option></select>


    <a href="#toc">목차</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ko/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU 비디오의 효율적인 사용</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><a href="webgpu-importing-textures.html">이전 글</a>에서 이미지, 캔버스, 비디오를 텍스처로 로딩하는 방법을 알아봤습니다.
이 글에서는 WebGPU에서 비디오를 사용하는 보다 효율적인 방법을 설명합니다.</p>
<p>이전 글에서 비디오를 WebGPU 텍스처로 로딩할 때 <code class="notranslate" translate="no">copyExternalImageToTexture</code>를 호출하였습니다.
이 함수는 비디오의 현재 프레임을 우리가 만들어둔, 이미 존재하는 텍스처에 복사하였습니다.</p>
<p>WebGPU에는 비디오를 사용하는 또다른 방법이 있습니다.
<code class="notranslate" translate="no">importExternalTexture</code>인데 이름에서 알 수 있듯이 이 함수는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUExternalTexture"><code class="notranslate" translate="no">GPUExternalTexture</code></a>를 반환해줍니다.
이 외부(external) 텍스처는 비디오 데이터를 직접 표현합니다. 복사가 필요하지 않습니다. <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>
<code class="notranslate" translate="no">importExternalTexture</code>에 비디오를 넣어주면 텍스처가 반환되고, 바로 사용할 수 있습니다.</p>
<p><code class="notranslate" translate="no">importExternalTexture</code>의 텍스처를 사용할 때는 몇 가지 큰 유의사항이 있습니다.</p>
<ul>
<li>
<h2 id="텍스처는-현재-자바스크립트-작업이-종료될-때까지만-유효합니다">텍스처는 현재 자바스크립트 작업이 종료될 때까지만 유효합니다.</h2>
<p>대부분의 WebGPU 앱의 경우 위 말은 텍스처가 <code class="notranslate" translate="no">requestAnimationCallback</code> 함수가 끝날때까지만 존재한다는 뜻입니다.
또는 <code class="notranslate" translate="no">requestVideoFrameCallback</code>, <code class="notranslate" translate="no">setTimeout</code>, <code class="notranslate" translate="no">mouseMove</code> 와 같은 다른 렌더링을 수행하는 이벤트일 수도 있습니다.
함수가 종료되면 텍스처가 만료(expired)됩니다.
비디오를 다시 사용하려면 <code class="notranslate" translate="no">importExternalTexture</code>를 다시 호출해야만 합니다.</p>
<p>이 말인즉, <code class="notranslate" translate="no">importExternalTexture</code>를 호출할 때마다 새로운 바인드그룹을 만들어서<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 새로운 텍스처를 셰이더에 전달할 수 있어야 한다는 뜻입니다.</p>
</li>
<li>
<h2 id="셰이더에서-texture_external-를-사용해야만-합니다">셰이더에서 <code class="notranslate" translate="no">texture_external</code> 를 사용해야만 합니다.</h2>
<p>이전 텍스처 예제에서는 모두 <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>를 사용했지만 <code class="notranslate" translate="no">importExternalTexture</code>에서 만들어진 텍스처는 <code class="notranslate" translate="no">texture_external</code>를 사용한 바인딩 포인트에만 바인딩 될 수 있습니다.</p>
</li>
<li>
<h2 id="셰이더에서-texturesamplebaseclamptoedge-를-사용해야만-합니다">셰이더에서 <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code> 를 사용해야만 합니다.</h2>
<p>이전 텍스처 예제에서는 모두 <code class="notranslate" translate="no">textureSample</code>를 사용했지만 <code class="notranslate" translate="no">importExternalTexture</code>에서 만들어진 텍스처는 <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>만 사용할 수 있습니다. <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>
이름 그대로, <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>는 기본 텍스터 밉 레벨 (레벨 0)만 샘플링합니다.
다시 말해, 외부 텍스처는 밉맵을 사용할 수 없습니다.
게다가, edge clamping을 하기 때문에 <code class="notranslate" translate="no">addressModeU: 'repeat'</code>는 무시됩니다.</p>
<p><code class="notranslate" translate="no">fract</code>를 아래와 같이 사용하면 직접 반복(repeat)을 할 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">let color = textureSAmpleBaseClampToEdge(
   someExternalTexture,
   someSampler,
   fract(texcoord)
);`
</pre>
</li>
</ul>
<p>이러한 제약들을 받아들이기 싫으면 <a href="webgpu-importing-textures.html">이전 글</a>에서와 같이 <code class="notranslate" translate="no">copyExternalImageToTexture</code>를 사용해야만 합니다.</p>
<p><code class="notranslate" translate="no">importExternalTexture</code>를 사용한 예제를 만들어 봅시다.
비디오는 아래와 같습니다.</p>
<div class="webgpu_center">
  <div>
     <video muted="" controls="" src="../../resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4" style="width: 320px" ;=""></video>
     <div class="copyright"><a href="https://www.pexels.com/video/dog-walking-outside-the-house-5534310/">by Anna Bondarenko</a></div>
  </div>
</div>
<p>이전 예제에서 수정해야 할 사항은 아래와 같습니다.</p>
<p>먼저 셰이더를 수정해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurVertexShaderOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
};

struct Uniforms {
  matrix: mat4x4f,
};

@group(0) @binding(2) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32
) -&gt; OurVertexShaderOutput {
  let pos = array(

    vec2f( 0.0,  0.0),  // center
    vec2f( 1.0,  0.0),  // right, center
    vec2f( 0.0,  1.0),  // center, top

    // 2st triangle
    vec2f( 0.0,  1.0),  // center, top
    vec2f( 1.0,  0.0),  // right, center
    vec2f( 1.0,  1.0),  // right, top
  );

  var vsOutput: OurVertexShaderOutput;
  let xy = pos[vertexIndex];
  vsOutput.position = uni.matrix * vec4f(xy, 0.0, 1.0);
-  vsOutput.texcoord = xy * vec2f(1, 50);
+  vsOutput.texcoord = xy;
  return vsOutput;
}

@group(0) @binding(0) var ourSampler: sampler;
-@group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;
+@group(0) @binding(1) var ourTexture: texture_external;

@fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-  return textureSample(ourTexture, ourSampler, fsInput.texcoord);
+  return textureSampleBaseClampToEdge(
+      ourTexture,
+      ourSampler,
+      fsInput.texcoord,
+  );
}
</pre>
<p>위에서, 텍스처 좌표에 50을 곱하는 것은 삭제했는데, 이는 반복을 보여주기 위함이었고, 외부 텍스처는 반복이 불가능하기 때문입니다.</p>
<p>그리고 위해서 이야기한 제약 사항들을 수정했습니다.
<code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>는 <code class="notranslate" translate="no">texture_external</code>로 바뀌었고 <code class="notranslate" translate="no">textureSample</code>은 <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>로 바뀌었습니다.</p>
<p>텍스처 생성과 밉맵 생성 관련한 코드는 모두 제거합니다.</p>
<p>물론 비디오의 출처를 명시해야 합니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  video.src = 'resources/videos/Golden_retriever_swimming_the_doggy_paddle-360-no-audio.webm';
+  video.src = 'resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4';
</pre>
<p>밉 레벨이 없으므로 이를 위한 샘플러도 생성하지 않습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const objectInfos = [];
-  for (let i = 0; i &lt; 8; ++i) {
+  for (let i = 0; i &lt; 4; ++i) {
    const sampler = device.createSampler({
      addressModeU: 'repeat',
      addressModeV: 'repeat',
      magFilter: (i &amp; 1) ? 'linear' : 'nearest',
      minFilter: (i &amp; 2) ? 'linear' : 'nearest',
-      mipmapFilter: (i &amp; 4) ? 'linear' : 'nearest',
    });

  ...
</pre>
<p><code class="notranslate" translate="no">importExternalTexture</code>를 호출하기 전까지는 텍스처가 없기 때문에 바인드그룹을 미리 만들수도 없습니다.
따라서 나중에 생성하기 위한 정보만 저장해 둡니다. <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const objectInfos = [];
  for (let i = 0; i &lt; 4; ++i) {

    ...

-    const bindGroups = textures.map(texture =&gt;
-      device.createBindGroup({
-        layout: pipeline.getBindGroupLayout(0),
-        entries: [
-          { binding: 0, resource: sampler },
-          { binding: 1, resource: texture.createView() },
-          { binding: 2, resource: { buffer: uniformBuffer }},
-        ],
-      }));

    // Save the data we need to render this object.
    objectInfos.push({
-      bindGroups,
+      sampler,
      matrix,
      uniformValues,
      uniformBuffer,
    });
</pre>
<p>렌더링 시점에 <code class="notranslate" translate="no">importExternalTexture</code>를 호출하고 바인드그룹을 만듭니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
-    copySourceToTexture(device, texture, video);
    ...

    const encoder = device.createCommandEncoder({
      label: 'render quad encoder',
    });
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

+    const texture = device.importExternalTexture({source: video});

    objectInfos.forEach(({sampler, matrix, uniformBuffer, uniformValues}, i) =&gt; {
+      const bindGroup = device.createBindGroup({
+        layout: pipeline.getBindGroupLayout(0),
+        entries: [
+          { binding: 0, resource: sampler },
+          { binding: 1, resource: texture },
+          { binding: 2, resource: { buffer: uniformBuffer }},
+        ],
+      });

      ...

      pass.setBindGroup(0, bindGroup);
      pass.draw(6);  // call our vertex shader 6 times
    });
</pre>
<p>또한 텍스처의 반복이 불가능하니 그리는 사각형이 보다 잘 보이도록 행렬 계산을 수정하여 50배 크기로 만들지는 않도록 합시다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...
    objectInfos.forEach(({bindGroups, matrix, uniformBuffer, uniformValues}, i) =&gt; {
      const bindGroup = bindGroups[texNdx];

      const xSpacing = 1.2;
-      const ySpacing = 0.7;
-      const zDepth = 50;
+      const ySpacing = 0.5;
+      const zDepth = 1;

-      const x = i % 4 - 1.5;
-      const y = i &lt; 4 ? 1 : -1;
+      const x = i % 2 - .5;
+      const y = i &lt; 2 ? 1 : -1;

      mat4.translate(viewProjectionMatrix, [x * xSpacing, y * ySpacing, -zDepth * 0.5], matrix);
-      mat4.rotateX(matrix, 0.5 * Math.PI, matrix);
-      mat4.scale(matrix, [1, zDepth * 2, 1], matrix);
+      mat4.rotateX(matrix, 0.25 * Math.PI * Math.sign(y), matrix);
+      mat4.scale(matrix, [1, -1, 1], matrix);
      mat4.translate(matrix, [-0.5, -0.5, 0], matrix);

      // copy the values from JavaScript to the GPU
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.draw(6);  // call our vertex shader 6 times
    });

</pre>
<p>이로써 WebGPU에서 복사를 하지 않는 비디오 텍스처가 만들어졌습니다.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-textured-quad-external-video.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-textured-quad-external-video.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<h2 id="texture_external-왜-써야하지-"><code class="notranslate" translate="no">texture_external</code> 왜 써야하지 ?</h2>
<p>어떤 분들은 이 비디오 사용 방식이 일반적인 <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>가 아닌 <code class="notranslate" translate="no">texture_external</code>을 사용한다는 사실을 주목할 것입니다.
그리고 일반적인 <code class="notranslate" translate="no">textureSample</code>이 아닌 <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>를 사용하는데, 이는 이 텍스처 사용 방식을 렌더링의 다른 부분과 섞어서 사용하고 싶다면 서로 다른 셰이더가 필요하다는 것을 의미합니다.
정적 텍스처를 사용할 때는 <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>를 사용하는 셰이더가 필요하고 비디오를 사용할 때는 <code class="notranslate" translate="no">texture_external</code>을 사용하는 다른 셰이더가 필요합니다.</p>
<p>여기서 내부적으로 무슨 일이 일어나는지 이해하는 것이 중요합니다.</p>
<p>비디오는 종종 밝기(각 픽셀의 밝기값) 부분과 색도(각 픽셀의 색상값) 부분이 분리되어 전달됩니다.
종종 색상 정보의 해상도는 밝기 정보보다 낮습니다.
이를 분리하고 인코딩하는 일반적인 방법은 <a href="https://en.wikipedia.org/wiki/Y%E2%80%B2UV">YUV</a>인데, 데이터가 휘도(Y)와 색상 정보(UV)로 분리됩니다.
이런 표현 방식은 일반적으로 압축률도 더 좋습니다.</p>
<p>WebGPU의 외부 텍스처 목표는 제공되는 형식 그대로 비디오를 직접 사용하는 것입니다.
WebGPU 에서는, 제공되는 형식 그대로 비디오를 직접 사용할 수 있도록 하는 것을 지향합니다.
이를 위해 하나의 비디오 텍스처가 있는 <em>척</em>하지만 실제 구현에서는 여러 개의 텍스처가 있을 수 있습니다.
예를 들어, 휘도 값(Y)을 가진 하나의 텍스처와 UV 값을 가진 별도의 텍스처가 있을 수 있습니다.
그리고 이러한 UV 값은 특별하게 분리될 수 있습니다.
픽셀당 2개의 값이 서로 교차된(interleaved) 텍스처 형태일수도 있고,</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
</pre>
<p>다음과 같이 배열될 수 있습니다.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
</pre>
<p>텍스처의 한 영역에는 픽셀당 하나의 (u) 값이, 다른 영역에는 하나의 (v) 값이 있습니다.
이렇게 데이터를 배열하는 것이 종종 더 나은 압축률을 제공하기 때문입니다.</p>
<p>셰이더에 <code class="notranslate" translate="no">texture_external</code>과 <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>를 추가하면, WebGPU는 이면에서 셰이더에 코드를 주입하여 이 비디오 데이터를 가져와서 RGBA 값을 반환해줍니다.
여러 텍스처에서 샘플링을 하거나, 올바른 데이터를 2개, 3개 또는 그 이상의 위치에서 가져와 RGB로 변환하기 위해 텍스처 좌표 계산을 수행해야 할 수도 있습니다.</p>
<p>위 비디오의 Y, U, V 채널은 다음과 같습니다.</p>
<div class="webgpu_center">
  <div class="side-by-side">
    <div class="separate">
      <img src="../../resources/videos/pexels-anna-bordarenko-5534310-y-channel.png" style="width: 300px;">
      <div>Y 채널 (휘도)</div>
    </div>
    <div class="separate">
      <div class="side-by-side">
        <div class="separate">
          <img src="../../resources/videos/pexels-anna-bordarenko-5534310-u-channel.png" style="width: 150px;">
          <div>U 채널<br>(빨강 ↔ 노랑)</div>
        </div>
        <div class="separate">
          <img src="../../resources/videos/pexels-anna-bordarenko-5534310-v-channel.png" style="width: 150px;">
          <div>V 채널<br>(파랑 ↔ 노랑)</div>
        </div>
      </div>
    </div>
  </div>
</div>
<p>WebGPU는 여기에 관련하여 효과적으로 최적화를 제공하고 있습니다.
전통적인 그래픽 라이브러리에서는 이것을 여러분이 알아서 처리해야 합니다.
YUV에서 RGB로 변환하는 코드를 직접 작성하거나 OS에 요청해야 합니다.
데이터를 RGBA 텍스처로 복사한 다음 그 RGBA 텍스처를 <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>로 사용하도록 직접 구현할 수 있을 겁니다.
이 방식이 더 유연하기는 합니다. 비디오와 정적 텍스처에 서로 다른 셰이더를 작성할 필요도 없습니다.
하지만 YUV 텍스처에서 RGBA 텍스처로 변환이 일어나야 하기 때문에 더 느립니다.</p>
<p>이러한 느리지만 유연한 방법도 WebGPU에서 여전히 사용 가능하며 <a href="webgpu-importing-textures.html#a-loading-video">이전 글</a>에서 다루었습니다.
유연성이 필요한 경우, 비디오와 정적 이미지에 서로 다른 셰이더 없이 모든 곳에서 비디오를 사용하고 싶다면 그 방법을 사용하세요.</p>
<p>WebGPU가 <code class="notranslate" translate="no">texture_external</code>에 대해 이러한 최적화를 제공하는 한 가지 이유는 이것이 웹이기 때문입니다.
브라우저에서 지원되는 비디오 형식은 시간이 지남에 따라 변경됩니다.
WebGPU가 이를 처리해주지만, YUV에서 RGB로 변환하는 셰이더를 직접 작성해야 한다면 비디오 형식이 변경되지 않을 것이라는 것도 알아야 하는데, 웹에서는 이것이 보장되지 않습니다.</p>
<p>이 글에서 설명한 <code class="notranslate" translate="no">texture_external</code> 방법을 사용하기에 적절한 곳은 meet, zoom, FB messenger와 같은 비디오 관련 기능들입니다.
시각화 추가나 배경 분리를 위한 얼굴 인식을 할 때 같은 경우입니다.
또 다른 경우는 WebXR에서 WebGPU가 지원되면 VR 비디오를 위한 용도입니다.</p>
<h2 id="카메라-사용하기"><a id="a-web-camera"></a> 카메라 사용하기</h2>
<p>실제로 카메라를 사용해 봅시다. 아주 조금만 변경하면 됩니다.</p>
<p>먼저, 재생할 비디오를 지정하지 않습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const video = document.createElement('video');
-  video.muted = true;
-  video.loop = true;
-  video.preload = 'auto';
-  video.src = 'resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4'; /* webgpufundamentals: url */
  await waitForClick();
  await startPlayingAndWaitForVideo(video);
</pre>
<p>그런 다음, 사용자가 재생을 클릭하면 <code class="notranslate" translate="no">getUserMedia</code>를 호출하여 카메라를 요청합니다.
결과 스트림은 비디오에 적용됩니다. WebGPU 부분의 코드에는 변경이 없습니다.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function waitForClick() {
    return new Promise(resolve =&gt; {
      window.addEventListener(
        'click',
-        () =&gt; {
+        async() =&gt; {
          document.querySelector('#start').style.display = 'none';
-          resolve();
+          try {
+            const stream = await navigator.mediaDevices.getUserMedia({
+              video: true,
+            });
+            video.srcObject = stream;
+            resolve();
+          } catch (e) {
+            fail(`could not access camera: ${e.message ?? ''}`);
+          }
        },
        { once: true });
    });
  }
</pre>
<p>됐습니다!</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-textured-quad-external-video-camera.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-textured-quad-external-video-camera.html" target="_blank">새 창으로 보려면 여기를 클릭하세요</a>
</div>

<p></p>
<p>효율적인 <code class="notranslate" translate="no">texture_external</code> 타입 텍스처 대신, 보다 유연한 <code class="notranslate" translate="no">texture&lt;f32&gt;</code> 타입 텍스처로 카메라 이미지를 만들어 쓰기 원한다면
<a href="webgpu-importing-textures.html#a-loading-video">이전 글의 비디오 예제</a>에도 유사한 변경을 해 볼수 있을 겁니다.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>실제 동작 방식은 브라우저 구현에 달려 있습니다.
WebGPU 명세(spec)는 브라우저가 복사를 하지 않기를 바라며 만들어졌습니다. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>명세에는 구현에 따라 같은 텍스처를 반환할 수 있어야 한다고 되어 있지만 꼭 요구되는 사항은 아닙니다.
같은 텍스처가 반환되었는지 확인하려면 이를 다음과 같이 확인해야 합니다. </p><pre class="prettyprint showlinemods notranslate notranslate" translate="no">const newTexture = device.importExternalTexture(…);<br>const same = oldTexture === newTexture;</pre> 같은 텍스처라면 이미 존재하는 바인드그룹과 참조된 <code class="notranslate" translate="no">oldTexture</code>를 사용 가능합니다. <a href="#fnref2" class="footnote-backref">↩︎</a><p></p>
</li>
<li id="fn3" class="footnote-item"><p><code class="notranslate" translate="no">textureLoad</code>도 외부 텍스처에 사용할 수 있습니다. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>바인드 그룹을 나누어서 하나는 샘플러와 uniform 버퍼만을 가지고 있도록 미리 만들고, 다른 하나는 렌더링 시점에 생성할 외부 텍스처를 참조하기만 하는 것을 만들어 둘 수도 있습니다.
이렇게 하는 것이 좋을지는 여러분의 필요에 따라 선택하시면 됩니다. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-textures-external-video.html">English
    </option><option value="/webgpu/lessons/es/webgpu-textures-external-video.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-textures-external-video.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-textures-external-video.html" selected="">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-textures-external-video.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-textures-external-video.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-textures-external-video.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-textures-external-video.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-fundamentals.html">기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">스테이지간 변수(Inter-stage Variables)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-buffers.html">스토리지 버퍼(Storage Buffers)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-vertex-buffers.html">정점 버퍼</a></li>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-textures.html">텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-importing-textures.html">이미지 로딩</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-textures-external-video.html">비디오 사용하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cube-maps.html">큐브맵(Cube Maps)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-storage-textures.html">스토리지 텍스처</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multisampling.html">멀티 샘플링 / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ko/webgpu-constants.html">상수(Constants)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-memory-layout.html">데이터 메모리 레이아웃</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-copying-data.html">데이터 복사하기</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-limits-and-features.html">선택적 기능(optional feature)과 제한(limit)</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-how-it-works.html">동작 방식</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D 수학</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>후처리</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-post-processing.html">Basic CRT Effect</a></li>
        </ul>
        </ul>
  <li>컴퓨트 셰이더</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-compute-shaders.html">컴퓨트 셰이더 기초</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>기타</li>
        <ul>
          <li><a href="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-resources.html">리소스 / 참고자료</a></li>
<li><a href="/webgpu/lessons/ko/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>질문이 있나요? <a href="http://stackoverflow.com/questions/tagged/webgpu">Stack Overflow</a>에 물어보세요.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">제안</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">요청 사항</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">이슈</a> /
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">버그</a>
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU 비디오의 효율적인 사용`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "<a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a>님<br> 당신의 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 기여에 감사드립니다.</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>