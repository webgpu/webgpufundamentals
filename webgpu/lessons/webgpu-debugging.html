<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-debugging.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Tips for debugging WebGPU">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-debugging_en.jpg">

<meta property="og:title" content="WebGPU Debugging and Errors">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-debugging_en.jpg">
<meta property="og:description" content="Tips for debugging WebGPU">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Debugging and Errors">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html">
<meta name="twitter:description" content="Tips for debugging WebGPU">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-debugging_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-debugging_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html",
      "inLanguage":"en",
      "name":"WebGPU Debugging and Errors",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-debugging.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Debugging and Errors</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-debugging.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-debugging.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-debugging.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-debugging.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-debugging.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-debugging.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-debugging.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-debugging.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Debugging and Errors</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Some tips on debugging WebGPU and dealing with errors.</p>
<h2 id="keep-the-javascript-console-open-to-see-webgpu-errors">Keep the JavaScript console open to see WebGPU errors</h2>
<p>Most browsers have a JavaScript console. Keep it open. WebGPU
should generally print errors there.</p>
<h2 id="consider-logging-uncaught-errors">Consider logging uncaught errors</h2>
<p>You can setup an event to catch uncaptured WebGPU errors and then
log them yourself. For example</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const device = await adapter.requestDevice();
device.addEventListener('uncapturederror', event =&gt; alert(event.error.message));
</pre>
<p>Personally, I generally don’t use <code class="notranslate" translate="no">alert</code> but you can log the message, put it
an element, or in some way make it visible. I find this useful because I often forget
the advice above, to open the JavaScript console, and then I don’t see the errors. 😅</p>
<p>Errors that WebGPU emits itself go to the JavaScript console but errors that you
capture go where you tell them to.</p>
<h2 id="help-webgpu-report-errors">Help WebGPU report errors</h2>
<p>Errors in WebGPU are reported asynchronously. This is to keep WebGPU fast
and efficient. But, it means sometimes means you might not get an error
at the time you expect it or at all, unless you help WebGPU.</p>
<p>Here’s some code using the advice from above, adding an event to
show uncaptured errors. It then compiles a shader module that
should get an error.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();

  device.addEventListener('uncapturederror', event =&gt; {
    log(event.error.message);
  });

  device.createShaderModule({
    code: `
      this shader won't compile
    `,
  });

  log('--done--');
}
</pre>
<p>In the live example below, at least in Chrome 129, you probably won’t
get an error.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-help-webgpu-report-errors.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-help-webgpu-report-errors.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>The reason is, in this case, Chrome in WebGPU doesn’t process certain
errors until you call certain functions. One such function is
<code class="notranslate" translate="no">submit</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();

  device.addEventListener('uncapturederror', event =&gt; {
    log(event.error.message);
  });

  device.createShaderModule({
    code: `
      this shader won't compile
    `,
  });

+  // pump WebGPU
+  device.queue.submit([]);

  log('--done--');
}
</pre>
<p>Now it should show the error.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-help-webgpu-report-errors-fixed.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-help-webgpu-report-errors-fixed.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>This issue rarely comes up because if you never call <code class="notranslate" translate="no">submit</code> then you really
aren’t using WebGPU yet. But, it can come up in special situations, like
when you’re trying to make a minimal complete verifiable example for a
tech support question or a bug report. Or if you’re stepping through the
code and you pass a line you know is supposed to cause an error and yet
no error has appeared yet.</p>
<p>Note: If you don’t want the error to also go to the JavaScript
console you can call <code class="notranslate" translate="no">event.preventDefault()</code></p>
<h2 id="manually-catching-errors">Manually catching errors.</h2>
<p>Above we showed a message for “uncaptured errors” which implies there’s
such a thing as a “captured error”. To capture an error there are a pair
of functions. <code class="notranslate" translate="no">device.pushErrorScope</code> and <code class="notranslate" translate="no">device.popErrorScope</code>.</p>
<p>You push an error scope. Submit commands, then pop the error scope
to see if there were any errors between the time you pushed and the
time you popped.</p>
<p>Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();

  device.addEventListener('uncapturederror', event =&gt; {
*    log('uncaptured error:', event.error.message);
  });

+  device.pushErrorScope('validation');
  device.createShaderModule({
    code: `
      this shader won't compile
    `,
  });
+  const error = await device.popErrorScope();
+  if (error) {
+    log('captured error:', error.message);
+  }

+  device.createShaderModule({
+    code: `
+      also, this shader won't compile
+    `,
+  });

  device.queue.submit([]);

  log('--done--');
</pre>
<p><code class="notranslate" translate="no">device.pushErrorScope</code> takes one of three filters.</p>
<ul>
<li>
<p><code class="notranslate" translate="no">'validation'</code></p>
<p>Errors related to using the API incorrectly</p>
</li>
<li>
<p><code class="notranslate" translate="no">'out-of-memory'</code></p>
<p>Errors related to trying to allocate too much memory.</p>
</li>
<li>
<p><code class="notranslate" translate="no">'internal'</code></p>
<p>Errors where you did nothing wrong but the driver complained.
For example, this might happen if your shader is too complex.</p>
</li>
</ul>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-push-pop-error-scope.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-push-pop-error-scope.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">popErrorScope</code> returns a promise with an error or null of there was no error.
Above we use <code class="notranslate" translate="no">await</code> to wait for the promise, but that stops our program. It’s
probably more common to use <code class="notranslate" translate="no">then</code> as in:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  device.pushErrorScope('validation');
  device.createShaderModule({
    code: `
      this shader won't compile
    `,
  });
+  device.popErrorScope().then(error =&gt; {
+    if (error) {
+      log('captured error:', error.message);
+    }
+  });
</pre>
<p>This way our program doesn’t pause and wait the GPU to get back
to us on whether or not there was an error.</p>
<h2 id="different-kinds-of-errors">Different kinds of Errors</h2>
<p>Some errors in WebGPU are checked when you call a function. Others are checked
later. WebGPU specifies timelines. Two of them are the “content timeline” and
the “device timeline”. The “content timeline” is same timeline as JavaScript
itself. The device timeline is separate and generally run in a separate process.
Yet other errors are checked by the rules of JavaScript itself.</p>
<ul>
<li>
<p>Example of a JavaScript Error: Passing the wrong type</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.writeBuffer(someTexture, ...);
</pre>
<p>The code above would immediately get an error because the first argument
of <code class="notranslate" translate="no">writeBuffer</code> must be a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBuffer"><code class="notranslate" translate="no">GPUBuffer</code></a> which JavaScript itself enforces.</p>
</li>
<li>
<p>Example of a “content timeline” error</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.createTexture({
  size: [],
  format: 'rgba8unorm',
  usage: GPUTextureUsage.TEXTURE_BINDING,
});
</pre>
<p><code class="notranslate" translate="no">size</code> as provided above, is an error, it must have at least 1 element.</p>
</li>
<li>
<p>Example of a device error</p>
<p>The examples at the start of the page are device errors. Device
errors are what <code class="notranslate" translate="no">pushErrorScope</code>, <code class="notranslate" translate="no">popErrorScope</code>, and uncaptured
error events process.</p>
</li>
</ul>
<p>Where errors happens is detailed in <a href="https://www.w3.org/TR/webgpu/">the spec</a>
but it’s important to know that JavaScript errors and content timeline errors
happen immediately and throw an exception where as device timeline errors happen
asynchronously.</p>
<h2 id="wgsl-errors">WGSL errors</h2>
<p>If you get an error compiling a shader module you can ask for more
detailed info by calling <code class="notranslate" translate="no">getComplicationInfo</code>.</p>
<p>Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  device.pushErrorScope('validation');
  const code = `
      // This function
      // calls a function
      // that does not
      // exist.

      fn foo() -&gt; vec3f {
        return someFunction(1, 2);
      }
    `;
  const module = device.createShaderModule({ code });
  device.popErrorScope().then(async error =&gt; {
    if (error) {
      const info = await module.getCompilationInfo();

      // Split the code into lines
      const lines = code.split('\n');

      // Sort the messages by line numbers in reverse order
      // so that as we insert the messages they won't affect
      // the line numbers.
      const msgs = [...info.messages].sort((a, b) =&gt; b.lineNum - a.lineNum);

      // Insert the error messages between lines
      for (const msg of msgs) {
        lines.splice(msg.lineNum, 0,
          `${''.padEnd(msg.linePos - 1)}${''.padEnd(msg.length, '^')}`,
          msg.message,
        );
      }

      log(lines.join('\n'));
    }
  });
</pre>
<p>The code above effectively interleaves any error messages
into the full shader code.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-get-compilation-info.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-get-compilation-info.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">getCompilationInfo</code> returns an object that contains an array of
<a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUCompilationMessage"><code class="notranslate" translate="no">GPUCompilationMessage</code></a>s, each of which has the following fields</p>
<ul>
<li><code class="notranslate" translate="no">message</code>: a string error message</li>
<li><code class="notranslate" translate="no">type</code>: <code class="notranslate" translate="no">'error'</code> or <code class="notranslate" translate="no">'warning'</code> or <code class="notranslate" translate="no">'info'</code></li>
<li><code class="notranslate" translate="no">lineNum</code>: the number of the error, 1 based</li>
<li><code class="notranslate" translate="no">linePos</code>: the position in the line of the error, 1 based</li>
<li><code class="notranslate" translate="no">offset</code>: the position in the string of the error, 0 based.
(this is effectively the same info as linePos, lineNum)</li>
<li><code class="notranslate" translate="no">length</code>: the length to highlight</li>
</ul>
<h2 id="webgpu-dev-extension">WebGPU-Dev-Extension</h2>
<p>The <a href="https://github.com/greggman/webgpu-dev-extension">WebGPU-Dev-Extension</a> provides features to help debug.</p>
<p>Some things it can do</p>
<ul>
<li>
<p>Show a stack trace where errors happened.</p>
<p>As we showed above, errors in WebGPU happen asynchronously. In the
first example we used the <code class="notranslate" translate="no">uncapturederror</code> event to see that we
got a WebGPU error but there was no info about where in JavaScript
that error happened.</p>
<p>The webgpu-dev-extension provides this info by trying to add calls
to <code class="notranslate" translate="no">pushErrorScope</code> and <code class="notranslate" translate="no">popErrorScope</code> around all of the WebGPU
functions that generate errors. Inside it creates an <code class="notranslate" translate="no">Error</code> object
which holds the a stack trace. If it gets an error it can then print
that <code class="notranslate" translate="no">Error</code> object and you’ll see the error stack of where the
error was originally generated.</p>
</li>
<li>
<p>Show errors for command encoders</p>
<p>In WebGPU, command encoders, like <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandEncoder"><code class="notranslate" translate="no">GPUCommandEncoder</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPURenderPassEncoder"><code class="notranslate" translate="no">GPURenderPassEncoder</code></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUComputePassEncoder"><code class="notranslate" translate="no">GPUComputePassEncoder</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPURenderBundleEncoder"><code class="notranslate" translate="no">GPURenderBundleEncoder</code></a> do
not generate device timeline errors. Instead, the errors
are saved up until you call <code class="notranslate" translate="no">encoder.finish</code></p>
<p>For example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const encoder = device.createCommandEncoder();
const pass = encoder.beginRenderPass(renderPassDesc);
pass.setPipeline(somePipeline);
pass.setBindGroup(0, someBindGroupIncompatibleWithSomePipeline); // oops!
pass.setVertexBuffer(0, positionBuffer);
pass.setVertexBuffer(1, normalBuffer);
pass.setIndexBuffer(indexBuffer, 'uint16');
pass.drawIndexed(4);
pass.end();
const cb = encoder.finish();  // Error above is generated here
</pre>
<p>The problem here is, at best you’ll get an error message
that the bind group bound to group 0 is incompatible with
the pipeline but you won’t know which line the error happened on.
In a small example like this it should be pretty obvious but in
a large app, it might be hard to track down which specific line
caused the error.</p>
<p>The webgpu-dev-extension can try to throw an error at the line
that caused the error.</p>
</li>
<li>
<p>Show WGSL errors interleaved with the full shader source</p>
<p>Like the example above, the webgpu-dev-extension has an option
to show the errors interleaved with the source WGSL, rather than
just a terse error message. (the default)</p>
</li>
</ul>
<h2 id="webgpu-inspector">WebGPU-Inspector</h2>
<p><a href="https://github.com/brendan-duncan/webgpu_inspector">The WebGPU-Inspector</a>
will attempt to capture all of your WebGPU commands and can let you
inspect buffers, textures, calls, and generally try to see what’s
happening in your WebGPU code.</p>
<div class="webgpu_center"><img src="https://github.com/brendan-duncan/webgpu_inspector/raw/main/docs/images/frame_capture_commands.png"></div>
<h2 id="tips-for-debugging-shaders">Tips for debugging shaders</h2>
<h3 id="simplify">Simplify:</h3>
<p>Get your shader to a working state by cutting out as much as possible.
Once it’s working, add stuff back in little by little</p>
<h3 id="show-a-solid-color">Show a solid color</h3>
<p>For render passes, the first thing I often do is show a solid color.</p>
<p>Here is last shader from <a href="webgpu-lighitng-spot.html">the article on spot lights</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  // Because vsOut.normal is an inter-stage variable 
  // it's interpolated so it will not be a unit vector.
  // Normalizing it will make it a unit vector again
  let normal = normalize(vsOut.normal);

  let surfaceToLightDirection = normalize(vsOut.surfaceToLight);
  let surfaceToViewDirection = normalize(vsOut.surfaceToView);
  let halfVector = normalize(
    surfaceToLightDirection + surfaceToViewDirection);

  let dotFromDirection = dot(surfaceToLightDirection, -uni.lightDirection);
  let inLight = smoothstep(uni.outerLimit, uni.innerLimit, dotFromDirection);

  // Compute the light by taking the dot product
  // of the normal with the direction to the light
  let light = inLight * dot(normal, surfaceToLightDirection);

  var specular = dot(normal, halfVector);
  specular = inLight * select(
      0.0,                           // value if condition false
      pow(specular, uni.shininess),  // value if condition is true
      specular &gt; 0.0);               // condition

  // Lets multiply just the color portion (not the alpha)
  // by the light
  let color = uni.color.rgb * light + specular;
  return vec4f(color, uni.color.a);
}
</pre>
<p>The example is supposed to render a green F with a small portion lit by a
spotlight. Here’s a version with a bug. Let’s debug it.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-01.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-01.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>We ran it and nothing appeared on the screen and there were
no WebGPU errors. The first thing I might do is change it to return solid red</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  let color = uni.color.rgb * light + specular;
-  return vec4f(color, uni.color.a);
+  //return vec4f(color, uni.color.a);
+  return vec4f(1, 0, 0, 1);  // solid red
</pre>
<p>If I see a red F then I know I should start looking in the fragment shader since
clearly enough of the vertex shader was correct to draw the triangles that make the F.
If I don’t see a red F then I should start looking in the vertex shader.</p>
<p>Trying it:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-02.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-02.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>We see a red F. Ok, lets try to visualize the normals.
To do so, change the end of the fragment shader to:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  let color = uni.color.rgb * light + specular;
  //return vec4f(color, uni.color.a);
-   return vec4f(1, 0, 0, 1);  // solid red
+   //return vec4f(1, 0, 0, 1);  // solid red
+   return vec4f(vsOut.normal * 0.5 + 0.5, 1);  // normal
</pre>
<p>Normals go from -1.0 to +1.0 but colors go from 0.0 to 1.0 so by multiplying
by 0.5 and adding 0.5 we convert the normals to something that can be visualized
with colors.</p>
<p>Trying that:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-03.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-03.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Hmmm, that’s not right. That looks suspiciously like all the normals are 0,0,0.
Clearly something is wrong the normals in the fragment shader. Those normals
come from the vertex shader after being multiplied by <code class="notranslate" translate="no">normalMatrix</code>. Let’s try
passing the normals straight through, without multiplying by <code class="notranslate" translate="no">normalMatrix</code>. If
the F appears then we know the bug is in <code class="notranslate" translate="no">normalMatrix</code>. If the F doesn’t appear
then the bug in the data being supplied to the vertex shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  // Orient the normals and pass to the fragment shader
-  vsOut.normal = uni.normalMatrix * vert.normal;
+  //vsOut.normal = uni.normalMatrix * vert.normal;
+  vsOut.normal = vert.normal;
</pre>
<p>Running that:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-04.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-04.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>That looks more like it. So apparently something is wrong with
<code class="notranslate" translate="no">normalMatrix</code></p>
<p>Checking the code it was commented out which left the matrix all zeros.
Someone must have checking something and forgot to uncomment it.😅</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // Inverse and transpose it into the worldInverseTranspose value
-    //mat3.fromMat4(mat4.transpose(mat4.inverse(world)), normalMatrixValue);
+    mat3.fromMat4(mat4.transpose(mat4.inverse(world)), normalMatrixValue);
</pre>
<p>Let’s un-comment it. Then let’s put the vertex shader back the way it was</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  // Orient the normals and pass to the fragment shader
-  //vsOut.normal = uni.normalMatrix * vert.normal;
-  vsOut.normal = vert.normal;
+  vsOut.normal = uni.normalMatrix * vert.normal;
</pre>
<p>That gives us:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-05.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-05.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>If you rotate the F you’ll see the colors change showing the normals
are being re-oriented by <code class="notranslate" translate="no">normalMatrix</code>. Compare that to the one above
where the colors don’t change as we rotate.</p>
<p>With that we can finally restore the fragment shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  let color = uni.color.rgb * light + specular;
-  //return vec4f(color, uni.color.a);
-  //return vec4f(1, 0, 0, 1);  // solid red
-  return vec4f(vsOut.normal * 0.5 + 0.5, 1);  // normal
+  return vec4f(color, uni.color.a);
</pre>
<p>And it’s working as it’s supposed to.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-debugging-spot-light-06.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-debugging-spot-light-06.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Finding ways to visualize your data is a good way to check it.
For example, to check <a href="webpgu-textures.html">texture coordinates</a>
you might do something like</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">   return vec4f(fract(textureCoord), 0, 1);
</pre>
<p>Texture coordinates generally go from 0.0 to 1.0 but if you’re repeating
the texture they might go higher so <code class="notranslate" translate="no">fract</code> covers that.</p>
<p>To give an idea of what texture coordinates look like, here’s a few objects with their texture coordinates visualized.</p>
<div class="webgpu_center">
   <div data-diagram="texcoords" style="width: 1024px; height: 400px;"></div>
   <div class="caption">texture coordinates visualized</div>
</div>
<p>Texture coordinates are generally smooth over some surface.</p>
<p>Here are the same texture coordinates visualized with a bug.</p>
<div class="webgpu_center">
   <div data-diagram="texcoords-bad" style="width: 1024px; height: 400px;"></div>
   <div class="caption">bad texture coordinates</div>
</div>
<p>They are no longer smooth so something is probably off.</p>
<p>Following the same procedures as above we’d conclude that the data coming into
the vertex shader must be bad. And indeed, this example is uploading the
vertex data as <code class="notranslate" translate="no">float32x3</code> values but mistakenly specified them as <code class="notranslate" translate="no">float16x2</code>
in the render pipeline descriptor.</p>
<!-- keep this at the bottom of the article -->
<link href="webgpu-debugging.css" rel="stylesheet">
<script type="module" src="webgpu-debugging.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-debugging.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-debugging.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-debugging.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-debugging.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-debugging.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-debugging.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-debugging.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-debugging.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Post Processing</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Debugging and Errors`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>