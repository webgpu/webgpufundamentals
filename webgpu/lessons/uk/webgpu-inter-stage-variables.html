<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/uk/webgpu-inter-stage-variables.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="uk"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Передаємо дані з вершинного шейдера в фрагментний шейдер">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_uk.jpg">

<meta property="og:title" content="Міжетапні змінні у WebGPU">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_uk.jpg">
<meta property="og:description" content="Передаємо дані з вершинного шейдера в фрагментний шейдер">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="Міжетапні змінні у WebGPU">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html">
<meta name="twitter:description" content="Передаємо дані з вершинного шейдера в фрагментний шейдер">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_uk.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_uk.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html",
      "inLanguage":"uk",
      "name":"Міжетапні змінні у WebGPU",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/uk/webgpu-inter-stage-variables.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Міжетапні змінні у WebGPU</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html" selected="">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


    <a href="#toc">Зміст</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/uk/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Міжетапні змінні у WebGPU</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>В <a href="webgpu-fundamentals.html">попередній статті</a> ми розглянули основи
роботи з WebGPU. В цій статті ми пройдемось по <em>основам</em> роботи з міжетапними
змінними.</p>
<p>Міжетапні змінні вступають у гру між вершинним та фрагментним шейдером.</p>
<p>Вершинний шейдер повертаючи 3 точки дає змогу нам намалювати трикутник між ними.
Проте, вершинний шейдер може також повернути додаткові дані для кожної з цих точок,
які, відповідно до стандартної поведінки, будуть інтерпольовані між цими точками.</p>
<p>Наведемо невеликий приклад. Ми розпочнемо з шейдерного модуля з попередньої статті.
Все, що ми збираємось зробити, це внести певні змінити в ці шейдери.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
-    label: 'our hardcoded red triangle shaders',
+    label: 'our hardcoded rgb triangle shaders',
    code: `
+      struct OurVertexShaderOutput {
+        @builtin(position) position: vec4f,
+        @location(0) color: vec4f,
+      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
+        var color = array&lt;vec4f, 3&gt;(
+          vec4f(1, 0, 0, 1), // red
+          vec4f(0, 1, 0, 1), // green
+          vec4f(0, 0, 1, 1), // blue
+        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
      }

-      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+        return fsInput.color;
      }
    `,
  });
</pre>
<p>Перш за все ми оголошуємо структуру (<code class="notranslate" translate="no">struct</code>). Це один із простих способів
координації міжетапних змінних між вершинним та фрагментним шейдерами.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>Далі ми оголошуємо, що наш вершинний шейдер повертатиме структуру цього типу.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
</pre>
<p>Створюємо масив з 3 кольорів.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        var color = array&lt;vec4f, 3&gt;(
          vec4f(1, 0, 0, 1), // червоний
          vec4f(0, 1, 0, 1), // зелений
          vec4f(0, 0, 1, 1), // синій
        );
</pre>
<p>Після цього, замість того, щоб просто повертати <code class="notranslate" translate="no">vec4f</code> для позиції, ми оголошуємо
екземпляр нашої структури, заповнюємо його даними і повертаємо.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
</pre>
<p>В оголошенні фрагментного шейдера ми вказуємо, що він прийматиме цю нашу структуру,
як параметр функції.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
        return fsInput.color;
      }
</pre>
<p>Далі, просто повертаємо колір з отриманої структури.</p>
<p>Якщо ми запустимо цей приклад, то побачимо, що кожного разу, коли графічний процесор
запускає наш фрагментний шейдер, то передає туди значення кольору, яке було
інтерпольоване між нашими 3 точками.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

<p></p>
<p>Міжетапні змінні зазвичай використовуються для інтерполяції координат текстури
вздовж трикутника, що ми розглянемо в <a href="webgpu-textures.html">цій статті про текстури</a>.
Інший поширений спосіб використання цих змінних це інтерполяція нормалів вздовж
трикутника, яку ми розглянемо в <a href="webgpu-lighting-directional.html">першій статті про освітлення</a>.</p>
<h2 id="міжетапні-змінні-зєднанні-з-допомогою-location">Міжетапні змінні з’єднанні з допомогою <code class="notranslate" translate="no">location</code></h2>
<p>Важливо зазначити, що, як і майже все в WebGPU, зв’язок між вершинним та
фрагментним шейдерами здійснюється за індексом. Для міжетапних змінних, цей зв’язок
працює через індекс локації.</p>
<p>Щоб побачити, що я маю на увазі, давайте змінимо фрагментний шейдер таким чином, щоб
заміст структури він приймав параметр <code class="notranslate" translate="no">vec4f</code> з позначкою локації <code class="notranslate" translate="no">location(0)</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(@location(0) color: vec4f) -&gt; @location(0) vec4f {
        return color;
      }
</pre>
<p>Запустивши цей код, ми побачимо, що він досі працює.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle-by-fn-param.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle-by-fn-param.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

<p></p>
<h2 id="builtinposition"><a id="a-builtin-position"></a> <code class="notranslate" translate="no">@builtin(position)</code></h2>
<p>Це допомагає нам звернути увагу на ще одну особливість. Наш початковий шейдерний модуль,
який використовував одну і ту ж структуру для вершинного та фрагментного шейдерів,
мав поле <code class="notranslate" translate="no">position</code>, але воно не мало своєї локації. Натомість, воно було оголошене як
<code class="notranslate" translate="no">@builtin(position)</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
*        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>Це поле <strong>НЕ</strong> є міжетапною змінною. Натомість, це вбудоване змінна (<code class="notranslate" translate="no">builtin</code>).
Так трапилось, що <code class="notranslate" translate="no">@builtin(position)</code> має різне значення для вершинного та для
фрагментного шейдера.</p>
<p>В вершинному шейдері, <code class="notranslate" translate="no">@builtin(position)</code> - це вихідні дані, які потрібні графічному
процесору, щоб той намалював трикутник/лінію/точку.</p>
<p>В фрагментному шейдері, <code class="notranslate" translate="no">@builtin(position)</code> - це вхідні дані. Це піксельні координати того
пікселя, про колір якого ми попросили дізнатися у нашого фрагментного шейдера.</p>
<p>Піксельні координати визначаються краями пікселя. Значення, яке передається в
фрагментний шейдер це координати центру пікселя.</p>
<p>Якщо б текстура, на якій ми малюємо була б розміром 3x2 пікселя, то координати
були б такими як на малюнку.</p>
<div class="webgpu_center"><img src="../resources/webgpu-pixels.svg" style="width: 500px;"></div>
<p>Ми можемо змінити наш шейдер так, щоб він використовував ці позиції. Для прикладу,
давайте намалюємо шахову дошку.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded checkerboard triangle shaders',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
-        @location(0) color: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
-        var color = array&lt;vec4f, 3&gt;(
-          vec4f(1, 0, 0, 1), // red
-          vec4f(0, 1, 0, 1), // green
-          vec4f(0, 0, 1, 1), // blue
-        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
-        vsOutput.color = color[vertexIndex];
        return vsOutput;
      }

      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-        return fsInput.color;
+        let red = vec4f(1, 0, 0, 1);
+        let cyan = vec4f(0, 1, 1, 1);
+
+        let grid = vec2u(fsInput.position.xy) / 8;
+        let checker = (grid.x + grid.y) % 2 == 1;
+
+        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>Код, вказаний вище, бере змінну <code class="notranslate" translate="no">fsInput.position</code>, яка була оголошена як
<code class="notranslate" translate="no">@builtin(position)</code>, і конвертує поле <code class="notranslate" translate="no">xy</code> з координатами в значення типу <code class="notranslate" translate="no">vec2u</code>
з 2 беззнаковими числами. Далі ми ділимо цих два числа на 8, що дає нам число, яке
збільшується кожних 8 пікселів. Далі ми додаємо <code class="notranslate" translate="no">x</code> та <code class="notranslate" translate="no">y</code> цього вектора, обчислюємо
остачу від ділення на 2 і порівнює результат з 1. Це дозволить нам отримати булеве
значення, яке буде правдивим чи хибним в залежності від нашого числа. В кінці,
ми використовуємо WGSL функцію <code class="notranslate" translate="no">select</code>, яка отримує два значення та обирає з них одне
залежно від булева умова. В JavaScript функція <code class="notranslate" translate="no">select</code> виглядала б так:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// якщо condition хибне - повертаємо `a`, в іншому випадку - `b`
select = (a, b, condition) =&gt; condition ? b : a;
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

<p></p>
<p>Навіть, якщо ви не використовуєте <code class="notranslate" translate="no">@builtin(position)</code> в фрагментному шейдері,
зручно мати його в коді, оскільки ми зможемо використовувати одну і ту ж структуру
в вершинному та фрагментному шейдері. Важливо запам’ятати, що значення поля <code class="notranslate" translate="no">position</code>
нашої структури відрізняються в вершинному і фрагментному шейдері і зовсім не
пов’язані між собою. Це абсолютно різні змінні.</p>
<p>Як зазначалося вище, для міжетапних змінних має значення лише <code class="notranslate" translate="no">@location(?)</code>.
Тому оголошення різних структур для вихідних даних вершинного шейдера
та вхідних даних фрагментного шейдера.</p>
<p>Для того щоб прояснити це все, той факт, що вершинний шейдер та фрагментний шейдер
ми тримаємо в одній і тій самій текстовій змінній це лише заради зручності. Насправді
ми також можемо розділити їх на різні модулі.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
-    label: 'hardcoded checkerboard triangle shaders',
+  const vsModule = device.createShaderModule({
+    label: 'hardcoded triangle',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
        return vsOutput;
      }
+    `,
+  });
+
+  const fsModule = device.createShaderModule({
+    label: 'checkerboard',
+    code: `
-      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+      @fragment fn fs(@builtin(position) pixelPosition: vec4f) -&gt; @location(0) vec4f {
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);

-        let grid = vec2u(fsInput.position.xy) / 8;
+        let grid = vec2u(pixelPosition.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;

        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>Та оновити створення нашого пайплайну, щоб використати ці модулі</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded checkerboard triangle pipeline',
    layout: 'auto',
    vertex: {
-      module,
+      module: vsModule,
    },
    fragment: {
-      module,
+      module: fsModule,
      targets: [{ format: presentationFormat }],
    },
  });

</pre>
<p>І все це буде працювати так само</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position-separate-modules.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position-separate-modules.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

<p></p>
<p>Справа в тому, що той факт, що обидва шейдери знаходяться в одному текстовому рядку
в більшості прикладів є лише зручністю. Насправді спочатку WebGPU аналізує WGSL,
щоб переконатися, що він синтаксично правильний. Потім WebGPU дивиться на вказану вами
точку входу. Звідти він переходить і переглядає частини, на які посилається entryPoint, і
нічого більше окрім цієї entryPoint. Це все зручно, тому що вам не потрібно двічі
описувати такі речі, як структури, прив’язки та розташування груп, якщо два або
більше шейдерів спільно використовують їх. Але з точки зору WebGPU це працює так, наче
ви створили їх усі, по одному разу для кожної точки входу.</p>
<p>Примітка: Генерування шахового патерну з допомогою <code class="notranslate" translate="no">@builtin(position)</code> не є
дуже поширеною практикою. Шаховий та інші патерни зазвичай реалізовують з
допомогою <a href="webgpu-textures.html">текстур</a>. Фактично, ви можете побачити поточну
проблему з цим підходом змінивши розмір вікна. Через те, що цей шаховий патерн
залежить від координат полотна, то він бути обчислюватись відносно полотна, а
не відносно трикутника.</p>
<h2 id="налаштування-інтерполяції"><a id="a-interpolate"></a>Налаштування інтерполяції</h2>
<p>Ми побачили вище, що міжетапні змінні, які повертаються з вершинного шейдера,
інтерполюються в момент, коли передаються в фрагментний шейдер. Є два набори
налаштувань для зміни способу інтерполяції. Зміна стандартних значень цих
налаштувань не є дуже поширеною практикою, але є випадки коли це потрібно.
Ми розглянемо такі випадки в інших статтях.</p>
<p>Тип інтерполяції:</p>
<ul>
<li><code class="notranslate" translate="no">perspective</code>: Значення інтерполюються у перспективно правильний спосіб (<strong>стандартне значення</strong>)</li>
<li><code class="notranslate" translate="no">linear</code>: Значення інтерполюються лінійно, не перспективно правильним способом.</li>
<li><code class="notranslate" translate="no">flat</code>: Значення не інтерполюються. Вибірка інтерполяції не використовується з цим типом.</li>
</ul>
<p>Вибірка інтерполяції:</p>
<ul>
<li><code class="notranslate" translate="no">center</code>: Інтерполяція виконується в центрі пікселя (<strong>стандартне значення</strong>)</li>
<li><code class="notranslate" translate="no">centroid</code>: Інтерполяція виконується в точці, яка лежить у межах усіх вибірок, охоплених фрагментом у поточному примітиві. Це значення однакове для всіх зразків у примітиві.</li>
<li><code class="notranslate" translate="no">sample</code>:  Інтерполяція виконується для вибірки. Фрагментний шейдер викликається один раз на вибірку, коли застосовано цей атрибут.</li>
<li><code class="notranslate" translate="no">first</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. (default) The value comes from the first vertex of the primitive being drawn</li>
<li><code class="notranslate" translate="no">either</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. The value comes from either the first or the last vertex of the primitive being drawn.</li>
</ul>
<p>Ви зазначаєте їх, як атрибути. Наприклад</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  @location(2) @interpolate(linear, center) myVariableFoo: vec4f;
  @location(3) @interpolate(flat) myVariableBar: vec4f;
</pre>
<p>Зверніть увагу, що якшо ваша міжетапна змінна має тип <code class="notranslate" translate="no">integer</code>, то ви маєте
використати тип інтерполяції <code class="notranslate" translate="no">flat</code>.</p>
<p>Якщо ви застосуєте тип <code class="notranslate" translate="no">flat</code>, то значення передане в фрагментний шейдер буде
значенням міжетапної змінної в першій вершині переданого трикутника.</p>
<p>В <a href="webgpu-uniforms.html">наступній статті ми розглянемо юніформи</a>, як ще один
спосіб передачі даних в шейдери.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html" selected="">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Основи</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-fundamentals.html">Основи</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Міжетапні змінні</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-uniforms.html">Юніформи</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-storage-buffers.html">Буфери зберігання</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-vertex-buffers.html">Буфери вершин</a></li>
  <li>Текстури</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/uk/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-memory-layout.html">Схема розміщення даних в пам’яті</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D математика</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Освітлення</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Техніки</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-post-processing.html">Basic CRT Effect</a></li>
        </ul>
        </ul>
  <li>Обчислювальні шейдери</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Різне</li>
        <ul>
          <li><a href="/webgpu/lessons/uk/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/uk/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Запитання? <a href="http://stackoverflow.com/questions/tagged/webgpu">Запитати на stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Пропозиція</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Запит</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Проблема</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Помилка</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `Міжетапні змінні у WebGPU`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>