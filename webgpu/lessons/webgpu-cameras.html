<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-cameras.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Cameras via Matrices">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_en.jpg">

<meta property="og:title" content="WebGPU Cameras">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_en.jpg">
<meta property="og:description" content="Cameras via Matrices">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Cameras">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html">
<meta name="twitter:description" content="Cameras via Matrices">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-cameras_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html",
      "inLanguage":"en",
      "name":"WebGPU Cameras",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Cameras</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-cameras.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-cameras.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-cameras.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-cameras.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-cameras.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-cameras.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-cameras.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-cameras.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Cameras</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is the 7th in a series of articles that will hopefully teach
you about 3D math. Each one builds on the previous lesson so you may find
them easiest to understand by reading them in order.</p>
<ol>
<li><a href="webgpu-translation.html">Translation</a></li>
<li><a href="webgpu-rotation.html">Rotation</a></li>
<li><a href="webgpu-scale.html">Scaling</a></li>
<li><a href="webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="webgpu-cameras.html">Cameras</a> ⬅ you are here</li>
<li><a href="webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="webgpu-scene-graphs.html">Scene Graphs</a></li>
</ol>
<p>In the last post we had to move the F in front of the frustum because the
<code class="notranslate" translate="no">mat4.perspective</code> function puts the eye at at the origin (0, 0, 0) and
that objects in the frustum are between <code class="notranslate" translate="no">-zNear</code> to <code class="notranslate" translate="no">-zFar</code> in front of it.
This means, anything we want to appear, needs to be placed this this space.</p>
<p>In the real world you usually move your camera to take a picture of a
some object</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="move-camera"></div>
   <div class="caption">moving the camera to the objects</div>
</div>
<p>But, in our last post, we came up with a projection matrix that requires things to
be in front of the origin on the -Z axis.  To achieve this, what we want to
do is, move the camera to the origin and move everything else the right
amount so it’s still in the same place <em>relative to the camera</em>.</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="move-world"></div>
   <div class="caption">moving the objects to the view</div>
</div>
<p>We need to effectively move the world in front of the camera.  The easiest way
to do this is to use an “inverse” matrix.  The math to compute an inverse matrix
in the general case is complex but conceptually it’s easy. The inverse is the
value you’d use to negate some other value.  For example, the inverse of a
matrix that translates in X by 123 is a matrix that translates in X by -123.
The inverse of a matrix that scales by 5 is a matrix that scales by 1/5th or
0.2.  The inverse of a matrix that rotates 30° around the X axis would be
one that rotates -30° around the X axis.</p>
<p>Up until this point we’ve used translation, rotation and scale to affect the
position and orientation of our ‘F’.  After multiplying all the matrices
together we have a single matrix that represents how to move the ‘F’ from the
origin to the place, size and orientation we want it.  We can do the same for a
camera.  Once we have the matrix that tells us how to move and rotate the camera
from the origin to where we want it we can compute its inverse which will give
us a matrix that tells us how to move and rotate everything else the opposite
amount which will effectively make it so the camera is at (0, 0, 0) and we’ve
moved everything in front of it.</p>
<p>Let’s make a 3D scene with a circle of 'F’s like the diagrams above.</p>
<p>First things first, lets adjust our F vertex data. We originally started in 2D
with pixels. The top left corner of the F is at 0,0 and extends 100 pixels right
and 150 pixels down. “Pixels” probably make no sense as a unit in 3D and the
perspective projection matrix we made uses positive Y up so, let’s flip our F so
positive Y is up and let’s center it around the origin.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const positions = [
-    // left column
-    0, 0, 0,
-    30, 0, 0,
-    0, 150, 0,
-    30, 150, 0,
-
-    // top rung
-    30, 0, 0,
-    100, 0, 0,
-    30, 30, 0,
-    100, 30, 0,
-
-    // middle rung
-    30, 60, 0,
-    70, 60, 0,
-    30, 90, 0,
-    70, 90, 0,
-
-    // left column back
-    0, 0, 30,
-    30, 0, 30,
-    0, 150, 30,
-    30, 150, 30,
-
-    // top rung back
-    30, 0, 30,
-    100, 0, 30,
-    30, 30, 30,
-    100, 30, 30,
-
-    // middle rung back
-    30, 60, 30,
-    70, 60, 30,
-    30, 90, 30,
-    70, 90, 30,
+    // left column
+     -50,  75,  15,
+     -20,  75,  15,
+     -50, -75,  15,
+     -20, -75,  15,
+
+    // top rung
+     -20,  75,  15,
+      50,  75,  15,
+     -20,  45,  15,
+      50,  45,  15,
+
+    // middle rung
+     -20,  15,  15,
+      20,  15,  15,
+     -20, -15,  15,
+      20, -15,  15,
+
+    // left column back
+     -50,  75, -15,
+     -20,  75, -15,
+     -50, -75, -15,
+     -20, -75, -15,
+
+    // top rung back
+     -20,  75, -15,
+      50,  75, -15,
+     -20,  45, -15,
+      50,  45, -15,
+
+    // middle rung back
+     -20,  15, -15,
+      20,  15, -15,
+     -20, -15, -15,
+      20, -15, -15,
  ];
</pre>
<p>Further, as we went over in
<a href="webgpu-perspective-projection.html">the previous article</a>,
because we were using positive Y = down to match most 2D pixel libraries, we had
our triangle vertex order backward for normal 3D and ended up culling the the
<code class="notranslate" translate="no">'front'</code> facing triangles instead of the normal <code class="notranslate" translate="no">'back'</code> facing triangles since
were scaling Y by negative 1. Now that we’re doing <em>normal</em> 3D with positive Y =
up, let’s flip the order of the vertices so that clockwise triangles are facing
out.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const indices = [
-     0,  1,  2,    2,  1,  3,  // left column
-     4,  5,  6,    6,  5,  7,  // top run
-     8,  9, 10,   10,  9, 11,  // middle run
-
-    12, 14, 13,   14, 15, 13,  // left column back
-    16, 18, 17,   18, 19, 17,  // top run back
-    20, 22, 21,   22, 23, 21,  // middle run back
-
-     0, 12,  5,   12, 17,  5,   // top
-     5, 17,  7,   17, 19,  7,   // top rung right
-     6,  7, 18,   18,  7, 19,   // top rung bottom
-     6, 18,  8,   18, 20,  8,   // between top and middle rung
-     8, 20,  9,   20, 21,  9,   // middle rung top
-     9, 21, 11,   21, 23, 11,   // middle rung right
-    10, 11, 22,   22, 11, 23,   // middle rung bottom
-    10, 22,  3,   22, 15,  3,   // stem right
-     2,  3, 14,   14,  3, 15,   // bottom
-     0,  2, 12,   12,  2, 14,   // left
+     0,  2,  1,    2,  3,  1,   // left column
+     4,  6,  5,    6,  7,  5,   // top run
+     8, 10,  9,   10, 11,  9,   // middle run
+
+    12, 13, 14,   14, 13, 15,   // left column back
+    16, 17, 18,   18, 17, 19,   // top run back
+    20, 21, 22,   22, 21, 23,   // middle run back
+
+     0,  5, 12,   12,  5, 17,   // top
+     5,  7, 17,   17,  7, 19,   // top rung right
+     6, 18,  7,   18, 19,  7,   // top rung bottom
+     6,  8, 18,   18,  8, 20,   // between top and middle rung
+     8,  9, 20,   20,  9, 21,   // middle rung top
+     9, 11, 21,   21, 11, 23,   // middle rung right
+    10, 22, 11,   22, 23, 11,   // middle rung bottom
+    10,  3, 22,   22,  3, 15,   // stem right
+     2, 14,  3,   14, 15,  3,   // bottom
+     0, 12,  2,   12, 14,  2,   // left
  ];
</pre>
<p>Finally let’s set the <code class="notranslate" translate="no">cullMode</code> to cull <em>back facing</em> triangles.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
    primitive: {
-      cullMode: 'front',  // note: uncommon setting. See article
+      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
  });
</pre>
<p>Here’s a function that given a matrix will compute its inverse matrix.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...

+  inverse(m, dst) {
+    dst = dst || new Float32Array(16);
+
+    const m00 = m[0 * 4 + 0];
+    const m01 = m[0 * 4 + 1];
+    const m02 = m[0 * 4 + 2];
+    const m03 = m[0 * 4 + 3];
+    const m10 = m[1 * 4 + 0];
+    const m11 = m[1 * 4 + 1];
+    const m12 = m[1 * 4 + 2];
+    const m13 = m[1 * 4 + 3];
+    const m20 = m[2 * 4 + 0];
+    const m21 = m[2 * 4 + 1];
+    const m22 = m[2 * 4 + 2];
+    const m23 = m[2 * 4 + 3];
+    const m30 = m[3 * 4 + 0];
+    const m31 = m[3 * 4 + 1];
+    const m32 = m[3 * 4 + 2];
+    const m33 = m[3 * 4 + 3];
+
+    const tmp0 = m22 * m33;
+    const tmp1 = m32 * m23;
+    const tmp2 = m12 * m33;
+    const tmp3 = m32 * m13;
+    const tmp4 = m12 * m23;
+    const tmp5 = m22 * m13;
+    const tmp6 = m02 * m33;
+    const tmp7 = m32 * m03;
+    const tmp8 = m02 * m23;
+    const tmp9 = m22 * m03;
+    const tmp10 = m02 * m13;
+    const tmp11 = m12 * m03;
+    const tmp12 = m20 * m31;
+    const tmp13 = m30 * m21;
+    const tmp14 = m10 * m31;
+    const tmp15 = m30 * m11;
+    const tmp16 = m10 * m21;
+    const tmp17 = m20 * m11;
+    const tmp18 = m00 * m31;
+    const tmp19 = m30 * m01;
+    const tmp20 = m00 * m21;
+    const tmp21 = m20 * m01;
+    const tmp22 = m00 * m11;
+    const tmp23 = m10 * m01;
+
+    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
+               (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
+    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
+               (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
+    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
+               (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
+    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
+               (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
+
+    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
+
+    dst[0] = d * t0;
+    dst[1] = d * t1;
+    dst[2] = d * t2;
+    dst[3] = d * t3;
+
+    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -
+                  (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
+    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -
+                  (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
+    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -
+                  (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
+    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -
+                  (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
+
+    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -
+                  (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
+    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -
+                  (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
+    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -
+                   (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
+    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -
+                   (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
+
+    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -
+                   (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
+    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -
+                   (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
+    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -
+                   (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
+    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -
+                   (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
+    return dst;
+  },
...
</pre>
<p>Like we’ve done in previous examples, to draw 5 things we need 5
uniform buffers and 5 bind groups.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const numFs = 5;
+  const objectInfos = [];
+  for (let i = 0; i &lt; numFs; ++i) {
    // matrix
    const uniformBufferSize = (16) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);

    // offsets to the various uniform values in float32 indices
    const kMatrixOffset = 0;

    const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer }},
      ],
    });

+    objectInfos.push({
+      uniformBuffer,
+      uniformValues,
+      matrixValue,
+      bindGroup,
+    });
+  }
</pre>
<p>Let’s get rid of some of the settings to unclutter our example</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    fieldOfView: degToRad(100),
-    translation: [-65, 0, -120],
-    rotation: [degToRad(220), degToRad(25), degToRad(325)],
-    scale: [1, 1, 1],
  };

  ...

-      mat4.translate(matrixValue, settings.translation, matrixValue);
-      mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
-      mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
-      mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
-      mat4.scale(matrixValue, settings.scale, matrixValue);
</pre>
<p>Because we are drawing 5 things and they will all use the same
projection matrix we’ll calculate it before the loop of drawing the Fs</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...

    const aspect = canvas.clientWidth / canvas.clientHeight;
-    mat4.perspective(
+    const projection = mat4.perspective(
        settings.fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
-        matrixValue,
    );
</pre>
<p>Next we’ll compute a camera matrix. This matrix represents the
position and orientation of the camera in the world.  The code
below makes a matrix that rotates the camera around the origin
radius * 1.5 distance out and looking at the origin.</p>
<div class="webgpu_center" style="width: 512px">
   <div data-diagram="camera-movement"></div>
   <div class="caption">camera movement</div>
</div>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const radius = 200;
  const settings = {
    fieldOfView: degToRad(100),
+    cameraAngle: 0,
  };

  ...

  function render() {

     ...
 

+    // compute a matrix for the camera.
+    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
+    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);
</pre>
<p>We then compute a “view matrix” from the camera matrix.  A “view matrix”
is the matrix that moves everything the opposite of the camera effectively
making everything relative to the camera as though the camera was at the
origin (0,0,0). We can do this by using the <code class="notranslate" translate="no">inverse</code> function that computes
the inverse matrix (the matrix that does the exact opposite of the supplied matrix).
In this case the supplied matrix would move the camera to some position
and orientation relative to the origin. The inverse of that is a matrix
that will move everything else such that the camera is at the origin.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // Make a view matrix from the camera matrix.
    const viewMatrix = mat4.inverse(cameraMatrix);
</pre>
<p>Now we combine the view and projection matrix into a view projection matrix.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    // combine the view and projection matrixes
+    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);
</pre>
<p>Finally we draw a circle of Fs. For each F we start with the
view projection matrix, then compute a position on a circle and
translate to that position.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
        settings.fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
    );

    // compute a matrix for the camera.
    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);

    // Make a view matrix from the camera matrix.
    const viewMatrix = mat4.inverse(cameraMatrix);

    // combine the view and projection matrixes
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

+    objectInfos.forEach(({
+      matrixValue,
+      uniformBuffer,
+      uniformValues,
+      bindGroup,
+    }, i) =&gt; {
+      const angle = i / numFs * Math.PI * 2;
+      const x = Math.cos(angle) * radius;
+      const z = Math.sin(angle) * radius;

+      mat4.translate(viewProjectionMatrix, [x, 0, z], matrixValue);

      // upload the uniform values to the uniform buffer
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.draw(numVertices);
+    });
</pre>
<p>And voila!  A camera that goes around the circle of 'F’s.  Drag the
<code class="notranslate" translate="no">cameraAngle</code> slider to move the camera around.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-1-direct-math.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-1-direct-math.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>That’s all fine but using rotate and translate to move a camera where you
want it and point toward what you want to see is not always easy.  For
example if we wanted the camera to always point at a specific one of the
'F’s it would take some pretty crazy math to compute how to rotate the
camera to point at that ‘F’ while it goes around the circle of 'F’s.</p>
<p>Fortunately there’s an easier way.  We can just decide where we want the
camera and what we want it to point at and then compute a matrix that will
put the camera there.  Based on how matrices work this is surprisingly
easy.</p>
<p>First we need to know where we want the camera.  We’ll call this the
<code class="notranslate" translate="no">eye</code>.  Then we need to know the position of the thing we want
to look at or aim at.  We’ll call it the <code class="notranslate" translate="no">target</code>.  If we subtract the
<code class="notranslate" translate="no">target</code> from the <code class="notranslate" translate="no">eye</code> we’ll have a vector that points in the
direction we’d need to go from the camera to get to the target.  Let’s
call it <code class="notranslate" translate="no">zAxis</code>.  Since we know the camera points in the -Z direction we
can subtract the other way <code class="notranslate" translate="no">eye - target</code>. We normalize the
results and copy it directly into the <code class="notranslate" translate="no">z</code> part of a matrix.</p>
<div class="webgpu_center">
  <div class="glocal-center">
    <table class="glocal-center-content glocal-mat">
      <tbody><tr>
        <td class="m11"> </td>
        <td class="m12"> </td>
        <td class="m13">Zx</td>
        <td class="m14"> </td>
      </tr>
      <tr>
        <td class="m21"> </td>
        <td class="m22"> </td>
        <td class="m23">Zy</td>
        <td class="m24"> </td>
      </tr>
      <tr>
        <td class="m31"> </td>
        <td class="m32"> </td>
        <td class="m33">Zz</td>
        <td class="m34"> </td>
      </tr>
      <tr>
        <td class="m41"> </td>
        <td class="m42"> </td>
        <td class="m43"> </td>
        <td class="m44"> </td>
      </tr>
    </tbody></table>
  </div>
</div>
<p>This part of a matrix represents the Z axis.  In this case the Z-axis of
the camera.  Normalizing a vector means making it a vector that represents
1.0 unit.  If you go back to <a href="webgpu-rotation.html">the rotation article</a>
where we talked about unit circles and how those helped with 2D rotation.
In 3D we need unit spheres and a normalized vector represents a point on a
unit sphere.</p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-00"></div>
  <div class="caption">the <span class="z-axis">z axis</span></div>
</div>
<p>That’s not enough info though.  Just a single vector gives us a point on a
unit sphere but which orientation from that point to orient things?  We
need to fill out the other parts of the matrix.  Specifically the X axis
and Y axis parts.  We know that in general, these 3 parts are perpendicular
to each other.  We also know that “in general”, we don’t point the camera
straight up.  Given that, if we know which way is up, in this case
(0,1,0), We can use that and something called a “cross product” to compute
the X axis and Y axis for the matrix.</p>
<p>I have no idea what a cross product means in mathematical terms.  What I
do know is that, if you have 2 unit vectors and you compute the cross
product of them you’ll get a vector that is perpendicular to those 2
vectors.  In other words, if you have a vector pointing south east, and a
vector pointing up, and you compute the cross product you’ll get a vector
pointing either south west or north east since those are the 2 vectors
that are perpendicular to south east and up.  Depending on which order you
compute the cross product in, you’ll get the opposite answer.</p>
<p>In any case if we compute the cross product of our <span class="z-axis"><code class="notranslate" translate="no">zAxis</code></span> and
<span style="color: gray;"><code class="notranslate" translate="no">up</code></span> we’ll get the <span class="x-axis">xAxis</span> for the camera.</p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-01"></div>
  <div class="caption"><span style="color:gray;">up</span> cross <span class="z-axis">zAxis</span> = <span class="x-axis">xAxis</span></div>
</div>
<p>And now that we have the <span class="x-axis"><code class="notranslate" translate="no">xAxis</code></span> we can cross the <span class="z-axis"><code class="notranslate" translate="no">zAxis</code></span> and the <span class="x-axis"><code class="notranslate" translate="no">xAxis</code></span>
which will give us the camera’s <span class="y-axis"><code class="notranslate" translate="no">yAxis</code></span></p>
<div class="webgpu_center" style="width: 768px">
  <div data-diagram="cross-product-02"></div>
  <div class="caption"><span class="z-axis">zAxis</span> cross <span class="x-axis">xAxis</span> = <span class="y-axis">yAxis</span></div>
</div>
<p>Now all we have to do is plug the 3 axes into a matrix. That gives us a
matrix that will orient something that points at the <code class="notranslate" translate="no">target</code> from the
<code class="notranslate" translate="no">eye</code>. We just need to put in the <code class="notranslate" translate="no">eye</code> position in the final column.</p>
<div class="webgpu_center">
  <div class="glocal-center">
    <table class="glocal-center-content glocal-mat">
      <tbody>
        <tr class="vertical-spans">
          <td><span class="x-axis">x axis →</span></td>
          <td><span class="y-axis">y axis →</span></td>
          <td><span class="z-axis">z axis →</span></td>
          <td><span>eye position →</span></td>
        </tr>
        <tr>
          <td class="m11">Xx</td>
          <td class="m12">Yx</td>
          <td class="m13">Zx</td>
          <td class="m14">Tx</td>
        </tr>
        <tr>
          <td class="m21">Xy</td>
          <td class="m22">Yy</td>
          <td class="m23">Zy</td>
          <td class="m24">Ty</td>
        </tr>
        <tr>
          <td class="m31">Xz</td>
          <td class="m32">Yz</td>
          <td class="m33">Zz</td>
          <td class="m34">Tz</td>
        </tr>
        <tr>
          <td class="m41">0</td>
          <td class="m42">0</td>
          <td class="m43">0</td>
          <td class="m44">1</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<p>Here’s the code to compute the cross product of 2 vectors.
Like our matrix code we’ll make it take an optional destination array.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const vec3 = {
+  cross(a, b, dst) {
+    dst = dst || new Float32Array(3);
+
+    const t0 = a[1] * b[2] - a[2] * b[1];
+    const t1 = a[2] * b[0] - a[0] * b[2];
+    const t2 = a[0] * b[1] - a[1] * b[0];
+
+    dst[0] = t0;
+    dst[1] = t1;
+    dst[2] = t2;
+
+    return dst;
+  },
+};
</pre>
<p>Here’s the code to subtract two vectors.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
+  subtract(a, b, dst) {
+    dst = dst || new Float32Array(3);
+
+    dst[0] = a[0] - b[0];
+    dst[1] = a[1] - b[1];
+    dst[2] = a[2] - b[2];
+
+    return dst;
+  },
</pre>
<p>Here’s the code to normalize a vector (make it into a unit vector).</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
+  normalize(v, dst) {
+    dst = dst || new Float32Array(3);
+
+    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
+    // make sure we don't divide by 0.
+    if (length &gt; 0.00001) {
+      dst[0] = v[0] / length;
+      dst[1] = v[1] / length;
+      dst[2] = v[2] / length;
+    } else {
+      dst[0] = 0;
+      dst[1] = 0;
+      dst[2] = 0;
+    }
+
+    return dst;
+  },
</pre>
<p>Here’s the code to compute a <em>camera</em> matrix. It follows the steps described above.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
  cameraAim(eye, target, up, dst) {
    dst = dst || new Float32Array(16);

    const zAxis = vec3.normalize(vec3.subtract(eye, target));
    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));

    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;

    return dst;
  },
  ...
</pre>
<p>And here is how we might use it to make the camera point at a specific ‘F’
as we move it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    // compute a matrix for the camera.
-    const cameraMatrix = mat4.rotationY(settings.cameraAngle);
-    mat4.translate(cameraMatrix, [0, 0, radius * 1.5], cameraMatrix);
+    // Compute the position of the first F
+    const fPosition = [radius, 0, 0];
+
+    // Use matrix math to compute a position on a circle where
+    // the camera is
+    const tempMatrix = mat4.rotationY(settings.cameraAngle);
+    mat4.translate(tempMatrix, [0, 0, radius * 1.5], tempMatrix);
+
+    // Get the camera's position from the matrix we computed
+    const eye = tempMatrix.slice(12, 15);
+
+    const up = [0, 1, 0];
+
+    // Compute the camera's matrix using cameraAim
+    const cameraMatrix = mat4.cameraAim(eye, fPosition, up);

    // Make a view matrix from the camera matrix.
    const viewMatrix = mat4.inverse(cameraMatrix);
</pre>
<p>And here’s the result.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-2-camera-aim.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-2-camera-aim.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Drag the slider and notice how the camera tracks a single ‘F’.</p>
<p>Most math libraries don’t have a <code class="notranslate" translate="no">cameraAim</code> function. Instead they have a <code class="notranslate" translate="no">lookAt</code> function
which computes exactly what our <code class="notranslate" translate="no">cameraAim</code> function does but ALSO converts it to a view matrix.
Functionally <code class="notranslate" translate="no">lookAt</code> could be implemented like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
+  lookAt(eye, target, up, dst) {
+    return mat4.inverse(mat4.cameraAim(eye, target, up, dst), dst);
+  },
  ...
};
</pre>
<p>Using this <code class="notranslate" translate="no">lookAt</code> function our code would change to this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    // Compute the camera's matrix using look at.
-    const cameraMatrix = mat4.cameraAim(eye, fPosition, up);
-
-    // Make a view matrix from the camera matrix.
-    const viewMatrix = mat4.inverse(cameraMatrix);
+    // Compute a view matrix
+    const viewMatrix = mat4.lookAt(eye, fPosition, up);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-3-look-at.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-3-look-at.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Note that you can use this type of “aim” math for more than just cameras.
Common uses are making a character’s head follow some target.  Making a turret aim
at a target.  Making an object follow a path.  You compute where on the path the
target is.  Then you compute where on the path the target would be a few moments
in the future.  Plug those 2 values into your <code class="notranslate" translate="no">aim</code> function and you’ll get a
matrix that makes your object follow the path and orient toward the path as
well.</p>
<p>Usually to “aim” something you want it to point down the positive Z axis instead
of the negative Z axis as our function above did. So, we need to
subtract <code class="notranslate" translate="no">target</code> from <code class="notranslate" translate="no">eye</code> instead of <code class="notranslate" translate="no">eye</code> from <code class="notranslate" translate="no">target</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
+  aim(eye, target, up, dst) {
+    dst = dst || new Float32Array(16);
+
+    const zAxis = vec3.normalize(vec3.subtract(target, eye));
+    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
+    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));
+
+    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
+    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
+    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
+    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;
+
+    return dst;
+  },

  cameraAim(eye, target, up, dst) {
    dst = dst || new Float32Array(16);

    const zAxis = vec3.normalize(vec3.subtract(eye, target));
    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));

    dst[ 0] = xAxis[0];  dst[ 1] = xAxis[1];  dst[ 2] = xAxis[2];  dst[ 3] = 0;
    dst[ 4] = yAxis[0];  dst[ 5] = yAxis[1];  dst[ 6] = yAxis[2];  dst[ 7] = 0;
    dst[ 8] = zAxis[0];  dst[ 9] = zAxis[1];  dst[10] = zAxis[2];  dst[11] = 0;
    dst[12] = eye[0];    dst[13] = eye[1];    dst[14] = eye[2];    dst[15] = 1;

    return dst;
  },
...

&lt;a id="a-aim-fs"&gt;&lt;/a&gt; Let's make a bunch of Fs point at another F (yea, too many Fs but I don't want to clutter
the example with more data). We'll make a grid of 5x5 Fs + 1 more
for them to "aim" at

```js
-  const numFs = 5;
+  const numFs = 5 * 5 + 1;
</pre>
<p>Then we’ll hard code a camera target and change the
settings so we can move one of the Fs</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
-    fieldOfView: degToRad(100),
-    cameraAngle: 0,
+    target: [0, 200, 300],
+    targetAngle: 0,
  };

  const radToDegOptions = { min: -360, max: 360, step: 1, converters: GUI.converters.radToDeg };

  const gui = new GUI();
  gui.onChange(render);
-  gui.add(settings, 'fieldOfView', {min: 1, max: 179, converters: GUI.converters.radToDeg});
-  gui.add(settings, 'cameraAngle', radToDegOptions);
+  gui.add(settings.target, '1', -100, 300).name('target height');
+  gui.add(settings, 'targetAngle', radToDegOptions).name('target angle');
</pre>
<p>And finally for the first 25 Fs we’ll orient them in
a grid using <code class="notranslate" translate="no">aim</code> and <em>aim</em> them at the 26th F</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+    // update target X,Z based on angle
+    settings.target[0] = Math.cos(settings.targetAngle) * radius;
+    settings.target[2] = Math.sin(settings.targetAngle) * radius;

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
-        settings.fieldOfView,
+        degToRad(60), // fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
    );

-    // Compute the position of the first F
-    const fPosition = [radius, 0, 0];
-
-    // Use matrix math to compute a position on a circle where
-    // the camera is
-    const tempMatrix = mat4.rotationY(settings.cameraAngle);
-    mat4.translate(tempMatrix, [0, 0, radius * 1.5], tempMatrix);
-
-    // Get the camera's position from the matrix we computed
-    const eye = tempMatrix.slice(12, 15);
+    const eye = [-500, 300, -500];
+    const target = [0, -100, 0];
    const up = [0, 1, 0];

    // Compute a view matrix
-    const viewMatrix = mat4.lookAt(eye, fPosition, up);
+    const viewMatrix = mat4.lookAt(eye, target, up);

    // combine the view and projection matrixes
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    objectInfos.forEach(({
      matrixValue,
      uniformBuffer,
      uniformValues,
      bindGroup,
    }, i) =&gt; {
-      const angle = i / numFs * Math.PI * 2;
-      const x = Math.cos(angle) * radius;
-      const z = Math.sin(angle) * radius;
-
-      mat4.translate(viewProjectionMatrix, [x, 0, z], matrixValue);

+      const deep = 5;
+      const across = 5;
+      if (i &lt; 25) {
+        // compute grid positions
+        const gridX = i % across;
+        const gridZ = i / across | 0;
+
+        // compute 0 to 1 positions
+        const u = gridX / (across - 1);
+        const v = gridZ / (deep - 1);
+
+        // center and spread out
+        const x = (u - 0.5) * across * 150;
+        const z = (v - 0.5) * deep * 150;
+
+        // aim this F from it's position toward the target F
+        const aimMatrix = mat4.aim([x, 0, z], settings.target, up);
+        mat4.multiply(viewProjectionMatrix, aimMatrix, matrixValue);
+      } else {
+        mat4.translate(viewProjectionMatrix, settings.target, matrixValue);
+      }

      // upload the uniform values to the uniform buffer
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<p>And now 25 Fs are facing (their front is positive Z), the 26th F</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-cameras-step-4-aim-Fs.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-cameras-step-4-aim-Fs.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Move the sliders and see all 25Fs <em>aim</em>.</p>
<!-- keep this at the bottom of the article -->
<link href="webgpu-cameras.css" rel="stylesheet">
<script type="module" src="webgpu-cameras.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-cameras.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-cameras.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-cameras.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-cameras.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-cameras.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-cameras.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-cameras.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-cameras.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Cameras`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>