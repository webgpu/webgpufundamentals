<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-picking.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Clicking on Objects">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-picking_en.jpg">

<meta property="og:title" content="WebGPU Picking">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-picking_en.jpg">
<meta property="og:description" content="Clicking on Objects">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Picking">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html">
<meta name="twitter:description" content="Clicking on Objects">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-picking_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-picking_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html",
      "inLanguage":"en",
      "name":"WebGPU Picking",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-picking.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Picking</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-picking.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-picking.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-picking.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-picking.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-picking.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-picking.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-picking.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-picking.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Picking</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is the 3nd in a short series about making parts for a 3D editor.
Each one builds on the previous lesson so you may find them easiest to
understand by reading them in order.</p>
<ol>
<li><a href="webgpu-highlighting.html">Highlighting</a></li>
<li><a href="webgpu-camera-controls.html">Camera Controls</a></li>
<li><a href="webgpu-picking.html">Picking</a> ⬅ you are here</li>
</ol>
<p>Picking is the act of selecting objects by clicking on the screen
and then figuring out which objects were clicked on.</p>
<h2 id="cpu-based-picking">CPU Based Picking</h2>
<p>In our series on 3D math we learned how to use matrices to
project 3D vertex positions into clip space positions. For picking
we can do the reverse. We can take where the user clicked on the
screen, convert that to clip space positions, then using the inverse
of the matrix that converted vertex positions to clip space, we can
convert clip space positions to vertex space.</p>
<p>Once they are in the same space it’s relatively easy to check
if the ray from the front of the current frustum to the back of
the current frustum, intersects any objects.</p>
<p>Let’s work down. First we need to decide when the pick. Because
we also use the pointer to move the camera, let’s pick on
pointerup, if the user hasn’t moved the pointer.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {
    let startX;
    let startY;
+    let moved;
    let lastMode;
    let camHelper;
    let doubleTapMode;
    let lastSingleTapTime;
    let startPinchDistance;
    const pointerToLastPosition = new Map();

    ...

    const onMove = (e) =&gt; {
      if (!pointerToLastPosition.has(e.pointerId) ||
          !canvas.hasPointerCapture(e.pointerId)) {
        return;
      }
      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });

      const mode = pointerToLastPosition.size === 2
        ? 'pinch'
        : pointerToLastPosition.size &gt; 2
        ? 'undefined'
        : doubleTapMode
        ? 'doubleTapZoom'
        : e.shiftKey
        ? 'track'
        : 'panAndTilt';

      if (mode !== lastMode) {
        lastMode = mode;
        updateStartPosition(e);
      }

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

+      if (pointerToLastPosition.size === 1 &amp;&amp;
+          Math.hypot(deltaX, deltaY) &gt; 1) {
+        moved = true;
+      }

      switch (mode) {
        case 'pinch': {
          const pinchDistance = computePinchDistance();
          const delta = pinchDistance - startPinchDistance;
          camHelper.dolly(cam.radius * 0.002 * -delta);
          break;
        }
        case 'track': {
          const s = cam.radius * 0.001;
          camHelper.track(-deltaX * s, deltaY * s);
          break;
        }
        case 'panAndTilt':
          camHelper.panAndTilt(deltaX * 0.01, deltaY * 0.01);
          break;
        case 'doubleTapZoom':
          camHelper.dolly(cam.radius * 0.002 * deltaY);
          break;
      }

      render();
    };

    const onUp = (e) =&gt; {
+      const numPointers = pointerToLastPosition.size;
      pointerToLastPosition.delete(e.pointerId);
      canvas.releasePointerCapture(e.pointerId);
-      if (pointerToLastPosition.size === 0) {
+      if (numPointers === 1 &amp;&amp; pointerToLastPosition.size === 0) {
        doubleTapMode = false;
+        if (!moved) {
+          pickMeshes(e, cam, moved);
+        }
      }
    };

    const kDoubleClickTimeMS = 300;
    const onDown = (e) =&gt; {
      canvas.setPointerCapture(e.pointerId);
      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (pointerToLastPosition.size === 1) {
+        moved = false;
        if (!doubleTapMode) {
          const now = performance.now();
          const deltaTime = now - lastSingleTapTime;
          if (deltaTime &lt; kDoubleClickTimeMS) {
            doubleTapMode = true;
          }
          lastSingleTapTime = now;
        }
      } else {
        doubleTapMode = false;
      }
      updateStartPosition(e);
    };

    ...
  }
</pre>
<p>With that we’re calling <code class="notranslate" translate="no">pickMeshes</code> if the user hasn’t moved
the pointer. We need to supply that function, but before that
we’re going to need a view projection matrix so let’s pull out
the current view project matrix code.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function getViewProjectionMatrix(cam, canvas) {
+    const aspect = canvas.clientWidth / canvas.clientHeight;
+    const projection = mat4.perspective(
+        settings.fieldOfView,
+        aspect,
+        1,      // zNear
+        2000,   // zFar
+    );
+
+    const viewMatrix = mat4.inverse(cam.getCameraMatrix());
+
+    // combine the view and projection matrixes
+    return mat4.multiply(projection, viewMatrix);
+  }

   ...

  function render() {
    ...


-    const aspect = canvas.clientWidth / canvas.clientHeight;
-    const projection = mat4.perspective(
-        settings.fieldOfView,
-        aspect,
-        1,      // zNear
-        2000,   // zFar
-    );
-
    root.updateWorldMatrix();
-
-    // make a view matrix from the camera's
-    const viewMatrix = mat4.inverse(orbitCamera.getCameraMatrix());
-
-    // combine the view and projection matrixes
-    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);
+    const viewProjectionMatrix = getViewProjectionMatrix(orbitCamera, canvas);
</pre>
<p>Now we can use that to start making <code class="notranslate" translate="no">pickMeshes</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function pickMeshes(e, cam) {
+    const clipX = e.clientX / e.target.clientWidth  *  2 - 1;
+    const clipY = e.clientY / e.target.clientHeight * -2 + 1;
+
+    const viewProjectionValue = getViewProjectionMatrix(cam, canvas);
+    const intersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);
+    ???
+  }
</pre>
<p><code class="notranslate" translate="no">pickMeshes</code> computes a clip space X and Y, a view projection matrix,
and passes them to <code class="notranslate" translate="no">getIntersectionMeshes</code> expecting an array of
meshes.</p>
<p>Let’s make <code class="notranslate" translate="no">getIntersectingMeshes</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function getIntersectingMeshes(clipX, clipY, viewProjection) {
    const clipNear = [clipX, clipY, 0];
    const clipFar = [clipX, clipY, 1];

    // make some temp math variables
    const worldViewProjection = mat4.identity();
    const mat = mat4.identity();
    const near = vec3.create();
    const far = vec3.create();

    const verts = [
      vec3.create(),
      vec3.create(),
      vec3.create(),
    ];

    const intersectingMeshes = [];
    for (const mesh of meshes) {
      // put mat in model space (the space of the vertex data)
      mat4.multiply(viewProjection, mesh.node.worldMatrix, worldViewProjection);

      // invert it so putting in clip space coords will transform them
      // to model space.
      mat4.inverse(worldViewProjection, mat);

      // now transform the clip space coords to model space
      // so we can compare them to the model vertices and AABB
      vec3.transformMat4(clipNear, mat, near);
      vec3.transformMat4(clipFar, mat, far);

      const { vertexData, numVertices } = mesh.vertices;

      const numTriangles = numVertices / 3;
      let closest;
      for (let t = 0; t &lt; numTriangles; ++t) {
        // get the 3 positions for the triangle
        verts.forEach((v, i) =&gt; {
          const offset = (t * 3 + i) * 4;
          v[0] = vertexData[offset + 0];
          v[1] = vertexData[offset + 1];
          v[2] = vertexData[offset + 2];
        });

        const result = intersectLineSegmentAndTriangle(near, far, ...verts);
        if (result) {
          // Convert back to clip space so we can check Z to keep
          // the closest hit.
          vec3.transformMat4(result, worldViewProjection, result);
          if (closest = == undefined || result[2] &lt; closest[2]) {
            closest = result;
          }
        }
      }

      if (closest !== undefined) {
        intersectingMeshes.push({
          position: closest,
          mesh,
        });
      }
    }

    return intersectingMeshes;
  }
</pre>
<p>I hope this code is relatively straight forward. It creates <code class="notranslate" translate="no">clipNear</code>
and <code class="notranslate" translate="no">clipFar</code>. These are easy as they’re just the <code class="notranslate" translate="no">clipX</code> and <code class="notranslate" translate="no">clipY</code>
that were passed in with <code class="notranslate" translate="no">clipNear</code> z set to 0 and <code class="notranslate" translate="no">clipFar</code> set to 1.</p>
<p>Then, for each mesh we get its <code class="notranslate" translate="no">worldMatrix</code> and multiply with our
camera’s view projection. We then take the inverse. This lets us
convert <code class="notranslate" translate="no">clipNear</code> and <code class="notranslate" translate="no">clipFar</code> to the same positions but in the
same space as the vertex data. We call the results <code class="notranslate" translate="no">near</code> and <code class="notranslate" translate="no">far</code>.</p>
<p>We then walk the triangles of the vertex data and for each one
call <code class="notranslate" translate="no">intersectLineSegmentAndTriangle</code> which will return undefined
if the <code class="notranslate" translate="no">near</code> <code class="notranslate" translate="no">far</code> line segment does not intersect, or, it returns
where the intersection happened if it did.</p>
<p>We convert back to clip space so the positions are oriented back
relative to the viewer. This lets us keep the closest point relative
to the camera.</p>
<p>If we found any one of the triangles interested then we push that
mesh onto our results.</p>
<p>With that in place we can go back and finish <code class="notranslate" translate="no">pickMeshes</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function pickMeshes(e, cam) {
    const clipX = e.clientX / e.target.clientWidth  *  2 - 1;
    const clipY = e.clientY / e.target.clientHeight * -2 + 1;

    const viewProjectionValue = getViewProjectionMatrix(cam, canvas);
    const intersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);

    // sort the results by their z
    intersectingMeshes.sort((a, b) =&gt; a.position[2] - b.position[2]);

    // pick the first one
    if (intersectingMeshes.length &gt; 0) {
      let node = intersectingMeshes[0].mesh.node;
      if (!settings.showMeshNodes) {
        while (node.name.includes('mesh')) {
          node = node.parent;
        }
      }
      setCurrentSceneGraphNode(node);
    }
  }
</pre>
<p>We still have a few more things we need to do. We need to
supply <code class="notranslate" translate="no">intersectLineSegmentAndTriangle</code>. This is called
<a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">The Möller–Trumbore ray-triangle intersection algorithm</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
  function intersectLineSegmentAndTriangle(p0, p1, v0, v1, v2) {
    const edge1 = vec3.subtract(v1, v0);
    const edge2 = vec3.subtract(v2, v0);
    const dir = vec3.subtract(p1, p0); // Line segment direction

    const h = vec3.cross(dir, edge2);
    const a = vec3.dot(edge1, h);

    // If 'a' is near zero, the line is parallel
    // to the triangle's plane
    if (Math.abs(a) &lt; 0.00001) {
      return undefined;
    }

    const f = 1 / a;
    const s = vec3.subtract(p0, v0);
    const u = f * vec3.dot(s, h);

    // Check if the intersection point is outside
    // the triangle's U parameter range [0, 1]
    if (u &lt; 0.0 || u &gt; 1.0) {
      return undefined;
    }

    const q = vec3.cross(s, edge1);
    const v = f * vec3.dot(dir, q);

    // Check if the intersection point is outside
    // the triangle's V parameter range [0, 1] or S+T range [0, 1]
    if (v &lt; 0.0 || u + v &gt; 1.0) {
      return undefined;
    }

    // At this stage, the intersection point lies on
    // the infinite line and within the triangle
    const t = f * vec3.dot(edge2, q);

    // Check if the intersection point lies within
    // the line segment's T parameter range [0, 1]
    if (t &lt; 0.0 || t &gt; 1.0) {
      return undefined;
    }

    // Return the intersection point
    return vec3.addScaled(p0, dir, t);
  }
</pre>
<p>That calls <code class="notranslate" translate="no">vec3.dot</code> so we need to supply it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...

+  dot(a, b) {
+    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
+  },

}
</pre>
<p>We’ve used <code class="notranslate" translate="no">dot</code> in <a href="webgpu-lighting-directional.html">the articles on lighting</a> among other places. It multiplies corresponding components
of 2 vec3s and adds the results.</p>
<p>We also need to keep around the vertex data.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function createVertices({vertexData, numVertices, aabb}, name) {
    const vertexBuffer = device.createBuffer({
      label: `${name}: vertex buffer vertices`,
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(vertexBuffer, 0, vertexData);
    return {
      vertexBuffer,
      numVertices,
      aabb,
+      vertexData,
    };
  }
</pre>
<p>And with that we can pick!</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-cpu-step-01.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-cpu-step-01.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>It would be nice if we click no where we unselect
whatever is currently selected. Let’s do that</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function pickMeshes(e, cam) {
    const clipX = e.clientX / e.target.clientWidth  *  2 - 1;
    const clipY = e.clientY / e.target.clientHeight * -2 + 1;

    const viewProjectionValue = getViewProjectionMatrix(cam, canvas);
    const intersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);

    // sort the results by their z
    intersectingMeshes.sort((a, b) =&gt; a.position[2] - b.position[2]);

    // pick the first one
    if (intersectingMeshes.length &gt; 0) {
      let node = intersectingMeshes[0].mesh.node;
      if (!settings.showMeshNodes) {
        while (node.name.includes('mesh')) {
          node = node.parent;
        }
      }
      setCurrentSceneGraphNode(node);
-    }
+    } else {
+      setCurrentSceneGraphNode(undefined);
+    }
  }

  ...

  // Presents a TRS to the UI. Letting set which TRS
  // is being edited.
  class TRSUIHelper {
    #trs = new TRS();

    constructor() {}

    setTRS(trs) {
-      this.#trs = trs;
+      this.#trs = trs ?? new TRS();
    }

    ...
  }

  ...

  let currentNode;
  function setCurrentSceneGraphNode(node) {
    currentNode = node;
-    trsUIHelper.setTRS(node.source);
-    trsFolder.name(`orientation: ${node.name}`);
+    trsUIHelper.setTRS(node?.source);
+    trsFolder.name(`orientation: ${node?.name ?? '--none--'}`);
    trsFolder.updateDisplay();

    showTRS();

    // Mark which node is selected.
    for (const b of nodeButtons) {
      const name = b.button.getName().replace(prefixRE, '');
      b.button.name(`${b.node === node ? kSelected : kUnelected}${name}`);
    }

    selectedMeshes = meshes.filter(mesh =&gt; meshUsesNode(mesh, node));

    render();
  }
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-cpu-step-02.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-cpu-step-02.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>A problem we have right now is we can only select the closest object.
A good thing about our code is we get a list of all objects that are under
the user’s pointer. It’s common in an editor that on the first click
the closest object is picked. On a 2nd click, if the pointer has not moved,
then the next object is picked. This repeats until we’ve cycled through all
the objects under the pointer. Let’s do that.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let lastPickX;
+  let lastPickY;
+  let lastPickNdx;
+  let lastIntersectingMeshes;
  function pickMeshes(e, cam) {
+    if (!lastIntersectingMeshes ||
+        lastPickX !== e.clientX ||
+        lastPickY !== e.clientY) {
+      lastPickNdx = 0;
+      lastPickX = e.clientX;
+      lastPickY = e.clientY;
       const clipX = e.clientX / e.target.clientWidth  *  2 - 1;
       const clipY = e.clientY / e.target.clientHeight * -2 + 1;
 
       const viewProjectionValue = getViewProjectionMatrix(cam, canvas);
-      const intersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);
-
-    // sort the results by their z
-    intersectingMeshes.sort((a, b) =&gt; a.position[2] - b.position[2]);
-
-    // pick the first one
-    if (intersectingMeshes.length &gt; 0) {
-      let node = intersectingMeshes[0].mesh.node;
+      lastIntersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);
+      lastIntersectingMeshes.sort((a, b) =&gt; a.position[2] - b.position[2]);
+    }
+
+    // Cycle through the results
+    if (lastIntersectingMeshes.length &gt; 0) {
+      let node = lastIntersectingMeshes[lastPickNdx].mesh.node;
+      lastPickNdx = ++lastPickNdx % lastIntersectingMeshes.length;
      if (!settings.showMeshNodes) {
        while (node.name.includes('mesh')) {
          node = node.parent;
        }
      }
      setCurrentSceneGraphNode(node);
    } else {
      setCurrentSceneGraphNode(undefined);
    }
</pre>
<p>Now if you click a drawer you’ll select the drawer. If you click again
without moving the pointer, you’ll select the cabinet behind the drawer</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-cpu-step-03.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-cpu-step-03.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>A common optimization we can make is to check if the ray intersects
the AABB of the vertex data. If it does not intersect then there’s
no reason to check all of the triangles.</p>
<p>We added an AABB in
<a href="webgpu-camera-controls.html#a-frame-selected">the previous article</a> in
order to implement “frame selected” so we have the data. All we need
to do is add the check.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function getIntersectingMeshes(clipX, clipY, viewProjection) {

    ...
    const intersectingMeshes = [];
    for (const mesh of meshes) {
      // put mat in model space (the space of the vertex data)
      mat4.multiply(viewProjection, mesh.node.worldMatrix, worldViewProjection);

      // invert it so putting in clip space coords will transform them
      // to model space.
      mat4.inverse(worldViewProjection, mat);

      // now transform the clip space coords to model space
      // so we can compare them to the model vertices and AABB
      vec3.transformMat4(clipNear, mat, near);
      vec3.transformMat4(clipFar, mat, far);

      const { vertexData, numVertices, aabb } = mesh.vertices;

+      // check if the ray passes through the AABB.
+      if (!intersectSegmentAABB(near, far, aabb)) {
+        // no so skip checking every triangle
+        continue;
+      }

      ...
    }

    return intersectingMeshes;
  }
</pre>
<p>Here’s the code for checking the a ray with an AABB.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Branchless slab ray/segment–AABB intersection (Williams et al.)
  // note: unoptimized for JS.
  const kEpsilon = 1e-12;
  function intersectSegmentAABB(p0, p1, aabb) {
    const delta = vec3.subtract(p1, p0);

    const invDelta = delta.map(v =&gt;
      1 / (Math.abs(v) &gt; kEpsilon ? v : Math.sign(v) * kEpsilon));

    const t0 = vec3.multiply(vec3.subtract(aabb.min, p0), invDelta);
    const t1 = vec3.multiply(vec3.subtract(aabb.max, p0), invDelta);

    const min = vec3.min(t0, t1);
    const max = vec3.max(t0, t1);

    const tMin = Math.max(0, ...min);
    const tMax = Math.min(1, ...max);

    for (let c = 0; c &lt; 3; ++c) {
      if (Math.abs(delta[c]) &lt;= kEpsilon &amp;&amp;
          (p0[c] &lt; aabb.min[c] || p0[c] &gt; aabb.max[c])) {
        return undefined;
      }
    }

    return tMin &gt; tMax
      ? undefined
      : { tMin, tMax };
  }
</pre>
<p>We need to add <code class="notranslate" translate="no">vec3.multiply</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...

+  multiply(a, b, dst) {
+    dst = dst ?? new Float32Array(3);
+
+    dst[0] = a[0] * b[0];
+    dst[1] = a[1] * b[1];
+    dst[2] = a[2] * b[2];
+
+    return dst;
+  },

  ...
};
</pre>
<p>Because our cabinets are made from scaled unit cubes, our bounding
box perfect matches our cubes. So, just to make sure it’s all working
let’s add our F back in that we used in other articles.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+function computeAABBForVertices(vertexData, stride = 3) {
+  const numVertices = vertexData.length / stride;
+  const min = [...vertexData.slice(0, 3)];
+  const max = [...min];
+
+  for (let i = 1; i &lt; numVertices; ++i) {
+    const offset = i * stride;
+    const p = vertexData.slice(offset, offset + 3);
+    vec3.min(min, p, min);
+    vec3.max(max, p, max);
+  }
+  return { min, max };
+}
+
+function createFVertices() {
  ...

  return {
    vertexData,
    numVertices,
+    aabb: computeAABBForVertices(vertexData, 4),
  };
}
</pre>
<p>We just needed to compute the F’s AABB</p>
<p>Now let’s add it to the scene just before we add the cabinets.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  {
+    const fVertices = createVertices(createFVertices(), 'f');
+    const node = addTRSSceneGraphNode('f', root, {
+      translation: [100, 75, 30],
+      rotation: [Math.PI, Math.PI * 0.33, 0],
+      scale: [0.5, 0.5, 0.5],
+    });
+    addMesh(node, fVertices, [1, 1, 1, 1]);
+  }

  const cabinets = addTRSSceneGraphNode('cabinets', root);
  // Add cabinets
  for (let cabinetNdx = 0; cabinetNdx &lt; kNumCabinets; ++cabinetNdx) {
    addCabinet(cabinets, cabinetNdx);
  }
</pre>
<p>There’s not really anything to see. It’s just slightly optimized.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-cpu-step-04.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-cpu-step-04.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>The problem with CPU based picking is it’s potentially slow and it’s a bunch
of work to make it keep up with any new GPU based rendering features we add.
It also requires we keep access to the vertex data for the CPU.</p>
<h2 id="gpu-picking"><a id="a-gpu-picking"></a> GPU Picking</h2>
<p>We can also pick with the GPU. We do it by, instead of drawing each object
with a color, we draw each object with an integer ID. We then look at the texel under
the pointer. Whatever ID we see is the ID of the object that was clicked on.</p>
<div class="webgpu_center">
  <div data-diagram="id-render" style="width: 1200px; max-width: 80%;"></div>
  <div>drag to rotate</div>
</div>
<p>Above is a render of a cube, a sphere, an a pyramid. Each has its id rendered over it.</p>
<p>To do that we need a way to render the objects with ids. We have a few options.</p>
<ol>
<li>
<h2 id="we-could-add-a-2nd-output-to-our-shader">We could add a 2nd output to our shader</h2>
<p>Our fragment shader is currently returning a single color</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
   return vsOut.color * uni.color;
}
</pre>
<p>We could change it to return both a color and an id.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no"> struct Uniforms {
   matrix: mat4x4f,
   color: vec4f,
+   id: u32,
 };

+struct MyOutput {
+  @location(0) color: vec4f,
+  @location(1) id: vec4u,
+};

-@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
-   return vsOut.color * uni.color;
+@fragment fn fs(vsOut: VSOutput) -&gt; MyOutput {
+   return MyOutput(
+     vsOut.color * uni.color,
+     uni.id,
+   );
}
</pre>
<p>This method has the advantage that we only need to render once and we get
both the image and ids.</p>
</li>
<li>
<h2 id="we-could-render-twice-once-for-color-once-for-ids">We could render twice, once for color, once for ids</h2>
<p>I’m going to choose method for now for reasons that will  hopefully become clear.</p>
</li>
</ol>
<p>So, first let’s add the id to our uniforms and create a fragment shader
that outputs ids.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  matrix: mat4x4f,
  color: vec4f,
+  id: u32,
};

struct Vertex {
  @location(0) position: vec4f,
  @location(1) color: vec4f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(vert: Vertex) -&gt; VSOutput {
  var vsOut: VSOutput;
  vsOut.position = uni.matrix * vert.position;
  vsOut.color = vert.color;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color * uni.color;
}

+@fragment fn fsPicking(vsOut: VSOutput) -&gt; @location(0) vec4u {
+  return vec4u(uni.id);
+}
</pre>
<p>As we mentioned early on, bindGroups made from pipelines that use <code class="notranslate" translate="no">layout: 'auto'</code>
can not be shared. We’d like to use the same bindGroups with both
fragment shaders so we need to manually create a bindGroupLayout and
pipelineLayout.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { minBindingSize: 96 },
      },
    ],
  });

  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [bindGroupLayout],
  });
</pre>
<p>We can then update our existing pipeline and also create a new one for rendering
the ids.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes with color',
+    layout: 'auto',
+    layout: pipelineLayout,
    vertex: {
      module,
      buffers: [
        {
          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
          ],
        },
      ],
    },
    fragment: {
      module,
+      entryPoint: 'fs',
      targets: [{ format: presentationFormat }],
    },
    primitive: {
      cullMode: 'back',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    },
  });

+  const pickPipeline = device.createRenderPipeline({
+    label: '2 attributes with id for picking',
+    layout: pipelineLayout,
+    vertex: {
+      module,
+      buffers: [
+        {
+          arrayStride: (4) * 4, // (3) floats 4 bytes each + one 4 byte color
+          attributes: [
+            {shaderLocation: 0, offset: 0, format: 'float32x3'},  // position
+            {shaderLocation: 1, offset: 12, format: 'unorm8x4'},  // color
+          ],
+        },
+      ],
+    },
+    fragment: {
+      module,
+      entryPoint: 'fsPicking',
+      targets: [{ format: 'r32uint' }],
+    },
+    primitive: {
+      cullMode: 'back',
+    },
+    depthStencil: {
+      depthWriteEnabled: true,
+      depthCompare: 'less',
+      format: 'depth24plus',
+    },
+  });
</pre>
<p>We need to update our per object uniform buffers so they have
room for the id and a way to set them.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const objectInfos = [];
  function createObjectInfo() {
-    // matrix and color
-    const uniformBufferSize = (16 + 4) * 4;
+    // matrix, color, id, padding
+    const uniformBufferSize = (16 + 4 + 1 + 3) * 4;
    const uniformBuffer = device.createBuffer({
      label: 'uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformValues = new Float32Array(uniformBufferSize / 4);
+    const asU32 = new Uint32Array(uniformValues.buffer);

    // offsets to the various uniform values in float32 indices
    const kMatrixOffset = 0;
    const kColorOffset = 16;
+    const kIdOffset = 20;

    const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);
    const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4);
+    const idValue = asU32.subarray(kIdOffset, kIdOffset + 1);

    const bindGroup = device.createBindGroup({
      label: 'bind group for object',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer }},
      ],
    });

    return {
      uniformBuffer,
      uniformValues,
      colorValue,
      matrixValue,
+      idValue,
      bindGroup,
    };
  }
</pre>
<p>and we need to update the rendering code to include the id</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  let depthTexture;
  let postTexture;
  let objectNdx = 0;

  function drawObject(ctx, vertices, matrix, color) {
    const { pass, viewProjectionMatrix } = ctx;
    const { vertexBuffer, numVertices } = vertices;
    if (objectNdx === objectInfos.length) {
      objectInfos.push(createObjectInfo());
    }
    const {
      matrixValue,
      colorValue,
+      idValue,
      uniformBuffer,
      uniformValues,
      bindGroup,
    } = objectInfos[objectNdx++];

    mat4.multiply(viewProjectionMatrix, matrix, matrixValue);
    colorValue.set(color);
 +   idValue[0] = objectNdx;

    // upload the uniform values to the uniform buffer
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

    pass.setVertexBuffer(0, vertexBuffer);
    pass.setBindGroup(0, bindGroup);
    pass.draw(numVertices);
  }
</pre>
<p>We need to make it possible to render twice so let’s
refactor <code class="notranslate" translate="no">render</code> into <code class="notranslate" translate="no">renderToTexture</code>.
We’ll pass it a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandEncoder"><code class="notranslate" translate="no">GPUCommandEncoder</code></a>, a <code class="notranslate" translate="no">target</code> texture
to render to, a <code class="notranslate" translate="no">pipeline</code> so we can pass on the drawing
pipeline or the id rendering pipeline, and the <code class="notranslate" translate="no">viewProjectionMatrix</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function renderToTexture(
+      encoder, target, pipeline, viewProjectionMatrix) {
    objectNdx = 0;

-    // Get the current texture from the canvas context and
-    // set it as the texture to render to.
-    const canvasTexture = context.getCurrentTexture();
-    renderPassDescriptor.colorAttachments[0].view = canvasTexture.createView();
+    renderPassDescriptor.colorAttachments[0].view = target.createView();

    depthTexture = makeNewTextureIfSizeDifferent(
      depthTexture,
-      canvasTexture, // for size
+      target,  // for size
      'depth24plus',
      GPUTextureUsage.RENDER_ATTACHMENT,
    );
    renderPassDescriptor.depthStencilAttachment.view = depthTexture.createView();

-    root.updateWorldMatrix();
-    const viewProjectionMatrix = getViewProjectionMatrix(orbitCamera, canvas);
-
-    const encoder = device.createCommandEncoder();
    {
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);

      const ctx = { pass, viewProjectionMatrix };
      for (const mesh of meshes) {
        drawMesh(ctx, mesh);
      }

      pass.end();
    }
  }

+  function render() {
+    root.updateWorldMatrix();
+    const viewProjectionMatrix = getViewProjectionMatrix(orbitCamera, canvas);
+
+    const encoder = device.createCommandEncoder();
+
+    // Get the current texture from the canvas context and
+    // pass it as the texture to render to.
+    const canvasTexture = context.getCurrentTexture();
+    renderToTexture(
+      encoder,
+      canvasTexture,
+      pipeline,
+      viewProjectionMatrix,
+      meshes);

      ...
}
</pre>
<p>Now in order to render the pick texture let’s make a <code class="notranslate" translate="no">pick</code>
function.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pickBuffer = device.createBuffer({
    size: 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });

  let pickTexture;
  async function pick(clipX, clipY, viewProjectionMatrix) {
    const x = Math.floor((clipX *  0.5 + 0.5) * canvas.width);
    const y = Math.floor((clipY * -0.5 + 0.5) * canvas.height);
    const encoder = device.createCommandEncoder();
    pickTexture = makeNewTextureIfSizeDifferent(
      pickTexture,
      canvas,  // for size
      'r32uint',
      GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
    );

    renderToTexture(
      encoder,
      pickTexture,
      pickPipeline,
      viewProjectionMatrix,
    );

    // Copy the texel under the pointer to pickBuffer
    encoder.copyTextureToBuffer(
      { texture: pickTexture, origin: [x, y] },
      { buffer: pickBuffer },
      [1, 1]
    );

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    // Get the value from the pickBuffer
    await pickBuffer.mapAsync(GPUMapMode.READ);
    const id = new Uint32Array(pickBuffer.getMappedRange())[0];
    pickBuffer.unmap();
    return id;
  }
</pre>
<p>It’s pretty straight forward. We convert <code class="notranslate" translate="no">clipX</code> and <code class="notranslate" translate="no">clipY</code>
into the texel coordinate under the pointer. We then create
a an <code class="notranslate" translate="no">r32uint</code> texture the same size as the canvas. We render
the scene to this texture using <code class="notranslate" translate="no">renderToTexture</code>. We then
copy the single texel under the pointer to <code class="notranslate" translate="no">pickBuffer</code>.
Then map it and read the value.</p>
<p>To use it we can replace our old <code class="notranslate" translate="no">pickMeshes</code> with this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  let lastPickX;
-  let lastPickY;
-  let lastPickNdx;
-  let lastIntersectingMeshes;
  function pickMeshes(e, cam) {
-    if (!lastIntersectingMeshes ||
-        lastPickX !== e.clientX ||
-        lastPickY !== e.clientY) {
-      lastPickNdx = 0;
-      lastPickX = e.clientX;
-      lastPickY = e.clientY;

*    const clipX = e.clientX / e.target.clientWidth  *  2 - 1;
*    const clipY = e.clientY / e.target.clientHeight * -2 + 1;

-      const viewProjectionValue = getViewProjectionMatrix(cam, canvas);
-      lastIntersectingMeshes = getIntersectingMeshes(clipX, clipY, viewProjectionValue);
-      lastIntersectingMeshes.sort((a, b) =&gt; a.position[2] - b.position[2]);
-    }
-
-    // Cycle through the results
-    if (lastIntersectingMeshes.length &gt; 0) {
-      let node = lastIntersectingMeshes[lastPickNdx].mesh.node;
-      lastPickNdx = ++lastPickNdx % lastIntersectingMeshes.length;

    const viewProjectionMatrix = getViewProjectionMatrix(cam, canvas);
    const id = await pick(clipX, clipY, viewProjectionMatrix);
    if (id &gt; 0) {
      let node = meshes[id - 1].node;
      if (!settings.showMeshNodes) {
        while (node.name.includes('mesh')) {
          node = node.parent;
        }
      }
      setCurrentSceneGraphNode(node);
    } else {
      setCurrentSceneGraphNode(undefined);
    }
  }
</pre>
<p>That was quite a few changes but with that we have GPU picking.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-gpu-step-01.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-gpu-step-01.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Unfortunately we lost the ability to cycle though all the
objects under the pointer. Let’s fix that. We’ll do it
by making a <code class="notranslate" translate="no">pickableMeshes</code> array that is all of the
meshes it’s possible to pick. Each time we pick a mesh
we’ll remove that mesh from <code class="notranslate" translate="no">pickableMeshes</code>. That means
the next time we click the previously picked mesh won’t
be rendered and so we’ll get whatever id it was overwriting.
If we don’t get any id we’ll put all of the meshes back in
<code class="notranslate" translate="no">pickableMeshes</code> and try a 2nd time.</p>
<p>First let’s make <code class="notranslate" translate="no">renderToTexture</code> take an array of meshes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function renderToTexture(
-      encoder, target, pipeline, viewProjectionMatrix) {
+      encoder, target, pipeline, viewProjectionMatrix, meshes) {

      ...

      const ctx = { pass, viewProjectionMatrix };
      for (const mesh of meshes) {
        drawMesh(ctx, mesh);
      }

    ...
  }
</pre>
<p>And let’s make the existing <code class="notranslate" translate="no">render</code> pass the meshes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...

    // Get the current texture from the canvas context and
    // pass it as the texture to render to.
    const canvasTexture = context.getCurrentTexture();
    renderToTexture(
      encoder,
      canvasTexture,
      pipeline,
      viewProjectionMatrix,
+      meshes,
    );

    ...
</pre>
<p>And let’s make <code class="notranslate" translate="no">pick</code> let us pass an array of meshes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  let pickTexture;
-  async function pick(clipX, clipY, viewProjectionMatrix) {
+  async function pick(clipX, clipY, viewProjectionMatrix, pickableMeshes) {

    ...

    renderToTexture(
      encoder,
      pickTexture,
      pickPipeline,
      viewProjectionMatrix,
+      pickableMeshes,
    );

    ...
  }
</pre>
<p>Then we need the adjust the <code class="notranslate" translate="no">pickMeshes</code> code like
we mentioned above.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  let lastPickX;
+  let lastPickY;
+  let pickableMeshes;
  async function pickMeshes(e, cam) {
+    // if we have no meshes OR the pointer moved
+    if (!pickableMeshes ||
+        lastPickX !== e.clientX ||
+        lastPickY !== e.clientY) {
+      lastPickX = e.clientX;
+      lastPickY = e.clientY;
+
+      // get all the meshes.
+      pickableMeshes = meshes.slice();
+    }

    const clipX = e.clientX / e.target.clientWidth * 2 - 1;
    const clipY = e.clientY / e.target.clientHeight * -2 + 1;

    const viewProjectionMatrix = getViewProjectionMatrix(cam, canvas);
    // pick from the available meshes
-    const id = await pick(clipX, clipY, viewProjectionMatrix);
-    if (id &gt; 0) {
+     let id = await pick(clipX, clipY, viewProjectionMatrix, pickableMeshes);
+    if (id === 0) {
+      // if we didn't find one, try all of them again
+      pickableMeshes = meshes.slice();
+      id = await pick(clipX, clipY, viewProjectionMatrix, pickableMeshes);
+      // If we still didn't find one there was nothing under the pointer
+      if (id === 0) {
+        setCurrentSceneGraphNode(undefined);
+        return;
+      }
+    }

-      let node = meshes[id - 1].node;
+    // remove the picked mesh and get its node
+    let node = pickableMeshes.splice(id - 1, 1)[0].node;
    if (!settings.showMeshNodes) {
      while (node.name.includes('mesh')) {
        node = node.parent;
      }
    }
    setCurrentSceneGraphNode(node);
-    } else {
-      setCurrentSceneGraphNode(undefined);
-    }
  }
</pre>
<p><sup>Those changes might be hard to see. Consider clicking “hide deleted”.</sup></p>
<p>With that, we’re back to being able to click cycle through
the objects under the pointer.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-picking-gpu-step-02.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-picking-gpu-step-02.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Some advantages to GPU picking:</p>
<ul>
<li>
<p>All GPU vertex effects are applied</p>
<p>A good example is skinning. <a href="webgpu-skinning.html">Skinning</a> is often only
applied on the GPU. To do CPU picking on a skinned object you need to
reproduce all of the skinning logic on the CPU. Similarly for
<a href="webgpu-blend-targets.html">blend targets</a> you would need to make a CPU
version of that as well. Even in our current code, in the CPU picking we had
to walk the vertices knowing what their formats and stride were. We hard
coded our solution to our one vertex format. It’s not uncommon for an app to only
have one vertex format. But, if it had more than one, we’d need to update the CPU
code to support each format.</p>
</li>
<li>
<p>Transparency can be taken into account if appropriate</p>
<p>Imagine you have a plane and to that plane is applied a leaf texture
where areas outside of the leaf are 100% transparent so you can see
things behind. With CPU picking, as we implemented it, all the picking
code sees is the 2 triangles making the leaf plane.</p>
<p>With GPU picking we could easy check the alpha value for the texture
and <code class="notranslate" translate="no">discard</code> writing the object id if it’s below some threshold.
This would let us pick things we can see through transparent parts of
the leaf plane which would feel more natural.</p>
</li>
</ul>
<p>An issue compared to the CPU one we wrote above is that it only gives
us the front most object. To implement clicking to rotate through all objects,
if the pointer hasn’t moved, then don’t draw the last selected object when
doing the picking. This will make the next closest object be the result.</p>
<h2 id="optimizations">Optimizations</h2>
<p>There are 3 relatively simple optimizations we could make
though at the moment these will be left as exercises for
the reader 😛</p>
<ol>
<li>
<p>Set the scissor to the texel under the pointer</p>
<p>We can call <code class="notranslate" translate="no">pass.setScissorRect(clipX, clipY, 1 1)</code>
and this would make the GPU render only to that 1 pixel.
That would be faster than rendering a millions of id
pixels since in the end we’re only reading a single pixel
anyway.</p>
</li>
<li>
<p>Use frustum culling or other “potential visible set”</p>
<p>If you can easily determine if an object is definitely not in front of the
camera then you can skip asking the GPU to look at all of that object’s triangles.</p>
<p>This isn’t special to picking,
drawing benefits from frustum culling as well.
Checking if an object is inside the view frustum,
helps the next item so it was worth mentioning.</p>
</li>
<li>
<p>Use a 1x1 pixel texture and a different projection matrix.</p>
<p>It’s possible to make a projection matrix that represents just the frustum
that includes the pixel under the cursor. If we did that we could just use a
1x1 pixel texture for picking. This has 2 benefits. First, we only need a 1x1
pixel texture which is a lot less memory than a canvas sized texture. Second,
the same frustum culling check mentioned above will have much smaller frustum
and so reject even more objects.</p>
</li>
</ol>
<!-- keep this at the bottom of the article -->
<link href="webgpu-picking.css" rel="stylesheet">
<script type="module" src="webgpu-picking.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-picking.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-picking.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-picking.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-picking.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-picking.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-picking.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-picking.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-picking.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Basic CRT Effect</a></li>
<li><a href="/webgpu/lessons/webgpu-image-adjustments.html">Image Adjustments</a></li>
<li><a href="/webgpu/lessons/webgpu-1dlut.html">1D Lookup Table (LUT)</a></li>
<li><a href="/webgpu/lessons/webgpu-3dlut.html">3D Lookup Table (LUT)</a></li>
        </ul>
  <li>Editor</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-highlighting.html">Highlighting</a></li>
<li><a href="/webgpu/lessons/webgpu-camera-controls.html">Camera Controls</a></li>
<li><a href="/webgpu/lessons/webgpu-picking.html">Picking</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Picking`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/js/prettify.js"></script>
<script src="/webgpu/lessons/resources/js/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>