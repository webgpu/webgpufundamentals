<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-compatibility-mode.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Running on older machines">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_en.jpg">

<meta property="og:title" content="WebGPU Compatibility Mode">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_en.jpg">
<meta property="og:description" content="Running on older machines">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Compatibility Mode">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html">
<meta name="twitter:description" content="Running on older machines">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compatibility-mode_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html",
      "inLanguage":"en",
      "name":"WebGPU Compatibility Mode",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compatibility-mode.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Compatibility Mode</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-compatibility-mode.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-compatibility-mode.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compatibility-mode.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compatibility-mode.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compatibility-mode.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compatibility-mode.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compatibility-mode.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Compatibility Mode</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGPU Compatibility mode is a version of WebGPU that,
with some limits, can run on older devices. The idea is,
if you can make your app run within some extra limits and
restrictions then you can request a webgpu compatibility adapter
and have your app run in more places.</p>
<blockquote>
<p>Note: Compatibility mode has not officially shipped. It may be available in
your browser as an experiment. In, <a href="https://www.google.com/chrome/canary/">Chrome Canary</a>,
as of version 136.0.7063.0
(2025-03-11), you can allow compatibility mode by enabling the flag
“enable-unsafe-webgpu” by going to
<code class="notranslate" translate="no">chrome://flags/#enable-unsafe-webgpu</code>.</p>
</blockquote>
<p>To give some idea what what you can do in compatibility mode,
effectively <em>nearly</em> all WebGL2 programs could be converted to
run on compatibility mode.</p>
<p>Here’s how you do it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const device = await adapter.requestDevice();
</pre>
<p>Simple! Note that every app that follows all the
limits of compatibility mode is a valid “core”
webgpu app and will run anywhere WebGPU is already
running.</p>
<h1 id="major-limits-and-restrictions">Major limits and restrictions</h1>
<h2 id="possibly-0-storage-buffers-in-vertex-shaders">Possibly 0 storage buffers in vertex shaders.</h2>
<p>The major restriction that is most likely to affect WebGPU apps is that ~45%
of these old devices do not support storage buffers in vertex shaders.</p>
<p>We used this feature in <a href="webgpu-storage-buffers.html">the article on storage buffers</a>
which is the 3nd article on this site. After that article we
<a href="webgpu-vertex-buffers.html">switched to using vertex buffers</a>.
Using vertex buffers is common and works everywhere but certain solutions are easier
with storage buffers. One example is
<a href="https://webgpu.github.io/webgpu-samples/?sample=wireframe">this example of drawing wireframes</a>. It uses storage buffers to generate triangles from vertex data.</p>
<p>With vertex data stored in storage buffers we can randomly access the vertex
data. With the vertex data in vertex buffer we can not. Of course there are
always other solutions.</p>
<h2 id="medium-limits-and-restrictions">Medium limits and restrictions</h2>
<h2 id="only-a-single-viewdimension-is-allowed-for-a-texture">Only a single viewDimension is allowed for a texture.</h2>
<p>In normal WebGPU you can make a 2d texture like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const myTexture = device.createTexture({
  size: [width, height, 6],
  usage: ...
  format: ...
});
</pre>
<p>You can then view it 3 different view dimensions</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// a view of myTexture as a 2d array with 6 layers
const as2DArray = myTexture.createView();

// view layer 3 of myTexture as a 2d texture
const as2D = myTexture.createView({
  viewDimension: '2d',
  baseArrayLayer: 3,
  arrayLayerCount: 1,
});

// view of myTexture as a cubemap
const asCube = myTexture.createView({
  viewDimension: 'cube',
});
</pre>
<p>In compatibility mode you can only use one view dimension and you have to
choose which viewDimension when you create the texture. A 2D texture with
1 layer defaults to only being usable as a <code class="notranslate" translate="no">'2d'</code> view. A 2D texture with
more than 1 layer defaults to only being usable as a <code class="notranslate" translate="no">'2d-array</code>’ view.
If you want something other than the default you must tell WebGPU. For example,
If you want a cube map then you must tell WebGPU when you create the texture.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cubeTexture = device.createTexture({
  size: [width, height, 6],
  usage: ...
  format: ...
  textureBindingViewDimension: 'cube', 
});
</pre>
<p>Note, this extra parameter is called <code class="notranslate" translate="no">textureBindingViewDimension</code> because
it relates to using the texture with usage <code class="notranslate" translate="no">TEXTURE_BINDING</code>. You can still
use a single layer of a cubemap or 2d-array as a 2d texture as a <code class="notranslate" translate="no">RENDER_ATTACHMENT</code>.</p>
<p>In compatibility mode, using the texture with another type of view will
generate a validation error</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// a view of cubeTexture as a 2d array with 6 layers
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // ERROR in compatibility mode: texture is a cubemap not a 2d-array
      resource: cubeTexture.createView(),
    },
  ],
})
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// view layer 3 of cubeTexture as a 2d texture
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // ERROR in compatibility mode: texture is a cubemap not 2d
      resource: cubeTexture.createView({
        viewDimension: '2d',
        baseArrayLayer: 3,
        arrayLayerCount: 1,
      }),
    },
  ]
});
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// view of cubeTexture as a cubemap
const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // GOOD!
      resource: cubeTexture.createView({
        viewDimension: 'cube',
      }),
    },
  ],
});
</pre>
<p>This restriction is not that big of a deal.
Few programs want to use a texture with different kinds of views.</p>
<h2 id="when-calling-texturecreateview-you-can-not-select-a-subset-of-layers-in-a-bindgroup">When calling <code class="notranslate" translate="no">texture.createView</code> you can not select a subset of layers in a bindGroup</h2>
<p>In core WebGPU we can create a texture with some layers</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const texture = device.createTexture({
  size: [64, 128, 8],   // 8 layers,
  ...
});
</pre>
<p>We can then select a subset of layers</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroup = device.createBindGroup({
  ...
  entries: [
    {
      binding,
      // ERROR  in compatibility mode - select layers 3 and 4
      resource: cubeTexture.createView({
        baseArrayLayer: 3,
        arrayLayerCount: 2,
      }),
    },
  ],
});
</pre>
<p>This restriction is also not that big of a deal. Few programs
want to select a subset of layers from a texture.</p>
<h2 id="generating-mipmaps-in-compatibility-mode"><a id="a-generating-mipmaps"></a> Generating Mipmaps in compatibility mode.</h2>
<p>There is one place though both of these restrictions comes up and that is when generating
mipmaps, which is a common use-case.</p>
<p>Recall that we made a gpu based mipmap generator in
<a href="webgpu-importing-textures.html#a-generating-mips-on-the-gpu">the article in importing images into textures</a>.
We modified that function to generate mipmaps for 2d-array and cubemaps in
<a href="webgpu-cube-maps.html#a-texture-helpers">the article on cube maps</a>. In that version
we always view each layer of the texture with a <code class="notranslate" translate="no">'2d'</code> dimension to reference
just one layer of the texture.
This won’t work in compatibility mode for the reasons above. We can’t use a <code class="notranslate" translate="no">'2d'</code>
view of <code class="notranslate" translate="no">'2d-array'</code> or <code class="notranslate" translate="no">'cube'</code> texture. We also can not select individual layers
in a bind group to select which layer to read from.</p>
<p>To make the code work in compatibility mode we have to work with textures
with the same view dimension they were created with and we need to pass in the texture
with access to all layers and select the layer we want in the shader itself, rather
than selecting the layer via <code class="notranslate" translate="no">createView</code> as we were doing.</p>
<p>So let’s do that! We’ll start with the code for <code class="notranslate" translate="no">generateMips</code> from <a href="webgpu-cube-maps.html#a-texture-helpers">the article on cubemaps</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {
    let sampler;
    let module;
    const pipelineByFormat = {};

    return function generateMips(device, texture) {
      if (!module) {
        module = device.createShaderModule({
          label: 'textured quad shaders for mip level generation',
          code: `
            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32
            ) -&gt; VSOutput {
              let pos = array(

                vec2f( 0.0,  0.0),  // center
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 0.0,  1.0),  // center, top

                // 2st triangle
                vec2f( 0.0,  1.0),  // center, top
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 1.0,  1.0),  // right, top
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);
              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;
            @group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;

            @fragment fn fs(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(ourTexture, ourSampler, fsInput.texcoord);
            }
          `,
        });

        sampler = device.createSampler({
          minFilter: 'linear',
          magFilter: 'linear',
        });
      }

      if (!pipelineByFormat[texture.format]) {
        pipelineByFormat[texture.format] = device.createRenderPipeline({
          label: 'mip level generator pipeline',
          layout: 'auto',
          vertex: {
            module,
          },
          fragment: {
            module,
            targets: [{ format: texture.format }],
          },
        });
      }
      const pipeline = pipelineByFormat[texture.format];

      const encoder = device.createCommandEncoder({
        label: 'mip gen encoder',
      });

      for (let baseMipLevel = 1; baseMipLevel &lt; texture.mipLevelCount; ++baseMipLevel) {
        for (let layer = 0; layer &lt; texture.depthOrArrayLayers; ++layer) {
          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: sampler },
              {
                binding: 1,
                resource: texture.createView({
                  dimension: '2d',
                  baseMipLevel: baseMipLevel - 1,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
              },
            ],
          });

          const renderPassDescriptor = {
            label: 'our basic canvas renderPass',
            colorAttachments: [
              {
                view: texture.createView({
                  dimension: '2d',
                  baseMipLevel: baseMipLevel,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
                loadOp: 'clear',
                storeOp: 'store',
              },
            ],
          };

          const pass = encoder.beginRenderPass(renderPassDescriptor);
          pass.setPipeline(pipeline);
          pass.setBindGroup(0, bindGroup);
          pass.draw(6);  // call our vertex shader 6 times
          pass.end();
        }
      }

      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    };
  })();
</pre>
<p>We need to change the WGSL so for each type of texture (2d, 2d-array, cube, etc…) we
use a different fragment shader and we need to be able to pass in a layer to read from.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+const faceMat = array(
+  mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x
+  mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x
+  mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y
+  mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y
+  mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z
+  mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
+  @location(1) @interpolate(flat, either) baseArrayLayer: u32,
};

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
+  @builtin(instance_index) baseArrayLayer: u32,
) -&gt; VSOutput {
  var pos = array&lt;vec2f, 3&gt;(
    vec2f(-1.0, -1.0),
    vec2f(-1.0,  3.0),
    vec2f( 3.0, -1.0),
  );

  var vsOutput: VSOutput;
  let xy = pos[vertexIndex];
  vsOutput.position = vec4f(xy, 0.0, 1.0);
  vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
+  vsOutput.baseArrayLayer = baseArrayLayer;
  return vsOutput;
}

@group(0) @binding(0) var ourSampler: sampler;
-@group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;

+@group(0) @binding(1) var ourTexture2d: texture_2d&lt;f32&gt;;
@fragment fn fs2d(fsInput: VSOutput) -&gt; @location(0) vec4f {
-  return textureSample(ourTexture, ourSampler, fsInput.texcoord);
+  return textureSample(ourTexture2d, ourSampler, fsInput.texcoord);
}

+@group(0) @binding(1) var ourTexture2dArray: texture_2d_array&lt;f32&gt;;
+@fragment fn fs2darray(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTexture2dArray,
+    ourSampler,
+    fsInput.texcoord,
+    fsInput.baseArrayLayer);
+}
+
+@group(0) @binding(1) var ourTextureCube: texture_cube&lt;f32&gt;;
+@fragment fn fscube(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTextureCube,
+    ourSampler,
+    faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1));
+}
+
+@group(0) @binding(1) var ourTextureCubeArray: texture_cube_array&lt;f32&gt;;
+@fragment fn fscubearray(fsInput: VSOutput) -&gt; @location(0) vec4f {
+  return textureSample(
+    ourTextureCubeArray,
+    ourSampler,
+    faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1), fsInput.baseArrayLayer);
+}
</pre>
<p>This code has 4 fragment shaders, one for each of <code class="notranslate" translate="no">'2d'</code>, <code class="notranslate" translate="no">'2d-array'</code>, <code class="notranslate" translate="no">'cube'</code>, and <code class="notranslate" translate="no">'cube-array'</code>.
It uses the <a href="webgpu-large-triangle-to-cover-clip-space.html">large triangle to cover clip space</a> technique
<a href="webgpu-large-triangle-to-cover-clip-space.html">covered elsewhere</a> to draw.
It also uses <code class="notranslate" translate="no">@builtin(instance_index)</code> to select the layer. This is an interesting and quick way
to pass in a single integer value to a shader without having to use a uniform buffer.
When we call <code class="notranslate" translate="no">draw</code>, the 4th parameter is the first instance which will be passed
to the shader as <code class="notranslate" translate="no">@builtin(instance_index)</code>. We pass that from the vertex shader to fragment
shader via <code class="notranslate" translate="no">VSOutput.baseArrayLayer</code> which we can reference has <code class="notranslate" translate="no">fsInput.baseArrayLayer</code>
in the fragment shader.</p>
<p>The cubemap code converts a 2d-array layer and normalized UV coordinate into a
cubemap 3d coordinate. We need this because again, in compatibility mode, a cubemap
can only be viewed as a cubemap.</p>
<p>Back to our JavaScript, We need to let the user pass in the viewDimension they used when they created
the texture so that we can select one of these shaders. If they don’t pass it
in we’ll guess from the defaults.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  /**
+  * Get the default viewDimension
+  * Note: It's only a guess. The user needs to tell us to be
+  * correct in all cases because we can't distinguish between
+  * a 2d texture and a 2d-array texture with 1 layer, nor can
+  * we distinguish between a 2d-array texture with 6 layers and
+  * a cubemap.
+  */
+  function getDefaultViewDimensionForTexture(dimension, depthOrArrayLayers) {
+   switch (dimension) {
+      case '1d':
+        return '1d';
+      default:
+      case '2d':
+        return depthOrArrayLayers &gt; 1 ? '2d-array' : '2d';
+      case '3d':
+        return '3d';
+    }
+  }

  const generateMips = (() =&gt; {
    let sampler;
    let module;
    const pipelineByFormat = {};

-    return function generateMips(device, texture) {
+    return function generateMips(device, texture, textureBindingViewDimension) {
+      // If the user doesn't pass in a textureBindingViewDimension then guess
+      textureBindingViewDimension = textureBindingViewDimension ??
+        getDefaultViewDimensionForTexture(texture.dimension, texture.depthOrArrayLayers);
      if (!module) {
        module = device.createShaderModule({
          label: 'textured quad shaders for mip level generation',
          code: `
            const faceMat = array(
              mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x
              mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x
              mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y
              mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y
              mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z
              mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z

            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
              @location(1) @interpolate(flat, either) baseArrayLayer: u32,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32,
              @builtin(instance_index) baseArrayLayer: u32,
            ) -&gt; VSOutput {
              var pos = array&lt;vec2f, 3&gt;(
                vec2f(-1.0, -1.0),
                vec2f(-1.0,  3.0),
                vec2f( 3.0, -1.0),
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy, 0.0, 1.0);
              vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
              vsOutput.baseArrayLayer = baseArrayLayer;
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;

            @group(0) @binding(1) var ourTexture2d: texture_2d&lt;f32&gt;;
            @fragment fn fs2d(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(ourTexture2d, ourSampler, fsInput.texcoord);
            }

            @group(0) @binding(1) var ourTexture2dArray: texture_2d_array&lt;f32&gt;;
            @fragment fn fs2darray(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTexture2dArray,
                ourSampler,
                fsInput.texcoord,
                fsInput.baseArrayLayer);
            }

            @group(0) @binding(1) var ourTextureCube: texture_cube&lt;f32&gt;;
            @fragment fn fscube(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTextureCube,
                ourSampler,
                faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1));
            }

            @group(0) @binding(1) var ourTextureCubeArray: texture_cube_array&lt;f32&gt;;
            @fragment fn fscubearray(fsInput: VSOutput) -&gt; @location(0) vec4f {
              return textureSample(
                ourTextureCubeArray,
                ourSampler,
                faceMat[fsInput.baseArrayLayer] * vec3f(fract(fsInput.texcoord), 1), fsInput.baseArrayLayer);
            }
          `,
        });

        sampler = device.createSampler({
          minFilter: 'linear',
          magFilter: 'linear',
        });
      }

    ...
</pre>
<p>Before we tracked a pipeline per format so we could reuse the pipeline for
textures of the same format. We need to update that to be a pipeline per format
per viewDimension.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {
    let sampler;
    let module;
-    const pipelineByFormat = {};
+    const pipelineByFormatAndView = {};

    return function generateMips(device, texture, textureBindingViewDimension) {
      // If the user doesn't pass in a textureBindingViewDimension then guess
      textureBindingViewDimension = textureBindingViewDimension ??
        getDefaultViewDimensionForTexture(texture);
      let module = moduleByViewDimension[textureBindingViewDimension];
      if (!module) {
        ...
      }

+      const id = `${texture.format}.${textureBindingViewDimension}`;

-      if (!pipelineByFormat[texture.format]) {
-        pipelineByFormat[texture.format] = device.createRenderPipeline({
-          label: 'mip level generator pipeline',
+      if (!pipelineByFormatAndView[id]) {
+        // chose an fragment shader based on the viewDimension (removes the '-' from 2d-array and cube-array)
+        const entryPoint = `fs${textureBindingViewDimension.replace(/[\W]/, '')}`;
+        pipelineByFormatAndView[id] = device.createRenderPipeline({
+          label: `mip level generator pipeline for ${textureBindingViewDimension}, format: ${texture.format}`,
          layout: 'auto',
          vertex: {
            module,
          },
          fragment: {
            module,
            entryPoint,
            targets: [{ format: texture.format }],
          },
        });
      }
-      const pipeline = pipelineByFormat[texture.format];
+      const pipeline = pipelineByFormatAndView[id];

      ...
}
</pre>
<p>Then our loop to generate the mipmap needs to change to use the full layers, since
compatibility mode does not allow a sub-range of layers. We also need to use
our ability to pass in the instance index via draw to select the layer we want to read from.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const generateMips = (() =&gt; {

      ...

      const pipeline = pipelineByFormatAndView[id];

      for (let baseMipLevel = 1; baseMipLevel &lt; texture.mipLevelCount; ++baseMipLevel) {
        for (let layer = 0; layer &lt; texture.depthOrArrayLayers; ++layer) {
          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: sampler },
              {
                binding: 1,
                resource: texture.createView({
-                  dimension: '2d',
+                  dimension: textureBindingViewDimension,
                  baseMipLevel: baseMipLevel - 1,
                  mipLevelCount: 1,
-                  baseArrayLayer: layer,
-                  arrayLayerCount: 1,
                }),
              },
            ],
          });

          const renderPassDescriptor = {
            label: 'our basic canvas renderPass',
            colorAttachments: [
              {
                view: texture.createView({
                  dimension: '2d',
                  baseMipLevel,
                  mipLevelCount: 1,
                  baseArrayLayer: layer,
                  arrayLayerCount: 1,
                }),
                loadOp: 'clear',
                storeOp: 'store',
              },
            ],
          };

          const pass = encoder.beginRenderPass(renderPassDescriptor);
          pass.setPipeline(pipeline);
          pass.setBindGroup(0, bindGroup);
-          pass.draw(6);
+          // draw 3 vertices, 1 instance, first instance (instance_index) = layer
+          pass.draw(3, 1, 0, layer);
          pass.end();
        }
      }

      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    };
  })();
</pre>
<p>With that our mipmap generation code works in compatibility mode, and it still
works in core WebGPU.</p>
<p>We have a few other things we need to update to make the example work though.</p>
<p>We have a function <code class="notranslate" translate="no">createTextureFromSources</code> that we pass sources
to and it creates a texture. It was always creating a <code class="notranslate" translate="no">'2d'</code> texture
since in core we can view a <code class="notranslate" translate="no">'2d'</code> texture with 6 layers as a cubemap.
Instead, we need to make it so we can pass in a viewDimension and/or
a dimension so that when we create the texture we can tell compatibility
mode how we will view it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  function textureViewDimensionToDimension(viewDimension) {
+   switch (viewDimension) {
+      case '1d': return '1d';
+      case '3d': return '3d';
+      default: return '2d';
+    }
+  }

  function createTextureFromSources(device, sources, options = {}) {
+    const viewDimension = options.viewDimension ??
+      getDefaultViewDimensionForTexture(options.dimension, sources.length);
+    const dimension = options.dimension ?? textureViewDimensionToDimension(viewDimension);
    // Assume are sources all the same size so just use the first one for width and height
    const source = sources[0];
    const texture = device.createTexture({
      format: 'rgba8unorm',
      mipLevelCount: options.mips ? numMipLevels(source.width, source.height) : 1,
      size: [source.width, source.height, sources.length],
      usage: GPUTextureUsage.TEXTURE_BINDING |
             GPUTextureUsage.COPY_DST |
             GPUTextureUsage.RENDER_ATTACHMENT,
+      dimension,
+      textureBindingViewDimension: viewDimension,
    });
    copySourcesToTexture(device, texture, sources, options);
    return texture;
  }
</pre>
<p>We also need to update <code class="notranslate" translate="no">copySourcesToTexture</code> to get the <code class="notranslate" translate="no">viewDimension</code> and
pass it to <code class="notranslate" translate="no">generateMips</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function copySourcesToTexture(device, texture, sources, {flipY, viewDimension} = {}) {
    sources.forEach((source, layer) =&gt; {
      device.queue.copyExternalImageToTexture(
        { source, flipY, },
        { texture, origin: [0, 0, layer] },
        { width: source.width, height: source.height },
      );
    });
    if (texture.mipLevelCount &gt; 1) {
+      viewDimension = viewDimension ??
+        getDefaultViewDimensionForTexture(texture.dimension, sources.length);
+      generateMips(device, texture, viewDimension);
-      generateMips(device, texture);
    }
  }
</pre>
<p>And, we need to update our call to <code class="notranslate" translate="no">createTextureFromSources</code> to tell it in advance
that we want a cubemap.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const texture = await createTextureFromSources(
-      device, faceCanvases, {mips: true, flipY: false});
+      device, faceCanvases, {mips: true, flipY: false, viewDimension: 'cube'});
</pre>
<p>To make the example run in compatibility mode we need to request it like we covered
at the top of this article.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
-  const adapter = await navigator.gpu?.requestAdapter()
+  const adapter = await navigator.gpu?.requestAdapter({
+    featureLevel: 'compatibility',
+  });
  const device = await adapter?.requestDevice();

  ...
</pre>
<p>And with that, our cube map sample works in compatibility mode.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-compatibility-mode-generatemips.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-compatibility-mode-generatemips.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>You now have a compatibility mode friendly <code class="notranslate" translate="no">generateMips</code> which you could
use in any of the examples on this site. It works on both core and compatibility mode.
In compatibility mode you must pass in a <code class="notranslate" translate="no">viewDimension</code> if you want a cube map or if
you want a 1 layer 2d-array. In core WebGPU you can pass one in or not. It doesn’t matter.</p>
<h1 id="minor-limits-and-restrictions">Minor limits and restrictions</h1>
<p>The following are limits and restrictions <em>most</em> programs are unlikely to
run into</p>
<ul>
<li>
<h2 id="color-blending-must-match-on-all-color-targets">Color blending must match on all color targets.</h2>
<p>In core, when you create a render pipeline, each color target
can specify blending settings. We used blending settings in
<a href="webgpu-transparency.html">the article on blending and transparency</a>.
In compatibility mode, all the settings across all color targets
in a single pipeline must be the same.</p>
</li>
<li>
<h2 id="copytexturetobuffer-and-copytexturetotexture-do-not-work-with-compressed-textures"><code class="notranslate" translate="no">copyTextureToBuffer</code> and <code class="notranslate" translate="no">copyTextureToTexture</code> do not work with compressed textures</h2>
</li>
<li>
<h2 id="copytexturetotexture-does-not-work-with-multisampled-textures"><code class="notranslate" translate="no">copyTextureToTexture</code> does not work with multisampled textures</h2>
</li>
<li>
<h2 id="cube-array-is-not-supported"><code class="notranslate" translate="no">cube-array</code> is not supported</h2>
</li>
<li>
<h2 id="views-of-a-textures-may-not-differ-in-aspect-or-mip-levels-in-a-single-drawdispatch-call">views of a textures may not differ in aspect or mip levels in a single draw/dispatch call.</h2>
<p>In core WebGPU you can make multiple texture views of a texture to different mip
levels AND use them in the same draw call. This is uncommon. Note that this
restriction is on <code class="notranslate" translate="no">TEXTURE_BINDING</code> usage, using a texture via a bindGroup. You
can still use a different view as a <code class="notranslate" translate="no">RENDER_ATTACHMENT</code> as we did in the mipmap generation
code above.</p>
</li>
<li>
<h2 id="builtinsample_mask-and-builtinsample_index-are-not-supported"><code class="notranslate" translate="no">@builtin(sample_mask)</code> and <code class="notranslate" translate="no">@builtin(sample_index)</code> are not supported</h2>
</li>
<li>
<h2 id="rg32uint-rg32sint-and-rg32float-texture-formats-can-not-be-used-as-storage-textures"><code class="notranslate" translate="no">rg32uint</code>, <code class="notranslate" translate="no">rg32sint</code> and <code class="notranslate" translate="no">rg32float</code> texture formats can not be used as storage textures.</h2>
</li>
<li>
<h2 id="depthclampbias-must-be-0"><code class="notranslate" translate="no">depthClampBias</code> must be 0</h2>
<p>This is a setting when creating a render pipeline.</p>
</li>
<li>
<h2 id="interpolationlinear-and-interpolation-sample-are-not-supported"><code class="notranslate" translate="no">@interpolation(linear)</code> and <code class="notranslate" translate="no">@interpolation(..., sample)</code> are not supported</h2>
<p>These were briefly mentioned in <a href="webgpu-inter-stage-variables.html#a-interpolate">the article on inter-stage variables</a>.</p>
</li>
<li>
<h2 id="interpolateflat-and-interpolateflat-first-are-not-supported"><code class="notranslate" translate="no">@interpolate(flat)</code> and <code class="notranslate" translate="no">@interpolate(flat, first)</code> are not supported</h2>
<p>In compatibility mode you must use <code class="notranslate" translate="no">@interpolate(flat, either)</code> when you want
flat interpolation. <code class="notranslate" translate="no">either</code> means the value passed to the fragment shader
could be the value from either the first or last vertex of the triangle or line
being drawn.</p>
<p>It is common for this not to matter. The most common use cases for passing something
with flat interpolation from the vertex shader to the fragment shader are usually
per model, per material, or per instance types of values. For example the mipmap
generation code above used flat interpolation above to pass the <code class="notranslate" translate="no">instance_index</code>
to the fragment shader. It will be the same for all vertices of a triangle and
so works just fine with <code class="notranslate" translate="no">@interpolate(flat, either)</code></p>
</li>
<li>
<h2 id="texture-formats-can-not-be-reinterpreted">Texture formats can not be reinterpreted</h2>
<p>In core WebGPU you can create an <code class="notranslate" translate="no">'rgba8unorm'</code> texture and view it as an <code class="notranslate" translate="no">'rgba8unorm-srgb'</code>
texture and visa-versa as well as other <code class="notranslate" translate="no">'-srgb'</code> formats and their corresponding non <code class="notranslate" translate="no">'-srgb'</code>
formats. Compatibility mode does not allow this. Whatever format you create the texture
is the only format it can be used as.</p>
</li>
<li>
<h2 id="bgra8unorm-srgb-is-not-supported"><code class="notranslate" translate="no">bgra8unorm-srgb</code> is not supported.</h2>
</li>
<li>
<h2 id="rgba16float-and-r32float-textures-can-not-be-multisampled"><code class="notranslate" translate="no">rgba16float</code> and <code class="notranslate" translate="no">r32float</code> textures can not be multisampled.</h2>
</li>
<li>
<h2 id="all-integer-texture-formats-can-not-be-multisampled">All integer texture formats can not be multisampled.</h2>
</li>
<li>
<h2 id="depthorarraylayers-must-be-compatible-with-texturebindingviewdimension"><code class="notranslate" translate="no">depthOrArrayLayers</code> must be compatible with <code class="notranslate" translate="no">textureBindingViewDimension</code></h2>
<p>This means a texture marked with <code class="notranslate" translate="no">textureBindingViewDimension: '2d'</code> must
have a <code class="notranslate" translate="no">depthOrArrayLayers: 1</code> (the default). A texture marked with <code class="notranslate" translate="no">textureBindingViewDimension: 'cube'</code>
must have <code class="notranslate" translate="no">depthOrArrayLayers: 6</code>.</p>
</li>
<li>
<h2 id="textureload-does-not-work-with-depth-textures"><code class="notranslate" translate="no">textureLoad</code> does not work with depth textures.</h2>
<p>A “depth texture” is a texture referenced in WGSL with <code class="notranslate" translate="no">texture_depth</code>,
<code class="notranslate" translate="no">texture_depth_2d_array</code>, or <code class="notranslate" translate="no">texture_depth_cube</code>. Those can not be used with
<code class="notranslate" translate="no">textureLoad</code> in compatibility mode.ß</p>
<p>On the other hand, <code class="notranslate" translate="no">textureLoad</code> can be used with <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>, <code class="notranslate" translate="no">texture_2d_array&lt;f32&gt;</code> and
<code class="notranslate" translate="no">texture_cube&lt;f32&gt;</code> and a texture that has a depth format can be bound to these bindings…</p>
</li>
<li>
<h2 id="depth-textures-can-not-be-used-with-non-comparison-samplers">depth textures can not be used with non-comparison samplers.</h2>
<p>Again, a “depth texture” is a texture referenced in WGSL with <code class="notranslate" translate="no">texture_depth</code>,
<code class="notranslate" translate="no">texture_depth_2d_array</code>, or <code class="notranslate" translate="no">texture_depth_cube</code>. Those can not be used
with a non-comparison sampler in compatibility mode.</p>
<p>This effectively means <code class="notranslate" translate="no">texture_depth</code>, <code class="notranslate" translate="no">texture_depth_2d_array</code>, and <code class="notranslate" translate="no">texture_depth_cube</code>
can only be used with <code class="notranslate" translate="no">textureSampleCompare</code>, <code class="notranslate" translate="no">textureSampleCompareLevel</code> and <code class="notranslate" translate="no">textureGatherCompare</code>
in compatibility mode.</p>
<p>On the other hand, you can bind a texture that uses a depth format to a <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>, <code class="notranslate" translate="no">texture_2d_array&lt;f32&gt;</code> and <code class="notranslate" translate="no">texture_cube&lt;f32&gt;</code> binding,
subject to the normal restriction that it must use a non-filtering sampler.</p>
</li>
<li>
<h2 id="the-combinations-of-texture--sampler-are-more-limited">The combinations of texture + sampler are more limited</h2>
<p>In core you can bind 16+ textures and 16+ samplers and then in your shader
you can use all 256+ combinations.</p>
<p>In compatibility mode you can only use 16 total combinations in a single stage.</p>
<p>The actual rule is a little more complicated. Here it is spelled out in pseudo code.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">maxCombinationsPerStage =
   min(device.limits.maxSampledTexturesPerShaderStage, device.limits.maxSamplersPerShaderStage)
for each stage of the pipeline:
  sum = 0
  for each texture binding in the pipeline layout which is visible to that stage:
    sum += max(1, number of texture sampler combos for that texture binding)
  for each external texture binding in the pipeline layout which is visible to that stage:
    sum += 1 // for LUT texture + LUT sampler
    sum += 3 * max(1, number of external_texture sampler combos) // for Y+U+V
  if sum &gt; maxCombinationsPerStage
    generate a validation error.
</pre>
</li>
<li>
<h2 id="some-of-the-default-limits-are-lower-in-compatibility-mode">Some of the default limits are lower in compatibility mode</h2>
<table>
<thead>
<tr>
<th style="text-align:left">limit</th>
<th style="text-align:right">compat</th>
<th style="text-align:right">core</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxColorAttachments</code></td>
<td style="text-align:right">4</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeWorkgroupSizeX</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxComputeWorkgroupSizeY</code></td>
<td style="text-align:right">128</td>
<td style="text-align:right">256</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxInterStageShaderVariables</code></td>
<td style="text-align:right">15</td>
<td style="text-align:right">16</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxTextureDimension1D</code></td>
<td style="text-align:right">4096</td>
<td style="text-align:right">8192</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxTextureDimension2D</code></td>
<td style="text-align:right">4096</td>
<td style="text-align:right">8192</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxUniformBufferBindingSize</code></td>
<td style="text-align:right">16384</td>
<td style="text-align:right">65536</td>
</tr>
<tr>
<td style="text-align:left"><code class="notranslate" translate="no">maxVertexAttributes</code></td>
<td style="text-align:right">16<sup>a</sup></td>
<td style="text-align:right">16</td>
</tr>
</tbody>
</table>
<p>(a) In compatibility mode, using <code class="notranslate" translate="no">@builtin(vertex_index)</code>
and/or <code class="notranslate" translate="no">@builtin(instance_index)</code> each count as an
attribute.</p>
<p>Of course the adapter may support higher limits for any of these.</p>
</li>
<li>
<h2 id="there-are-4-new-limits">There are 4 new limits.</h2>
<ul>
<li><code class="notranslate" translate="no">maxStorageBuffersInVertexStage</code> (default 0)</li>
<li><code class="notranslate" translate="no">maxStorageTexturesInVertexStage</code> (default 0)</li>
<li><code class="notranslate" translate="no">maxStorageBuffersInFragmentStage</code> (default 4)</li>
<li><code class="notranslate" translate="no">maxStorageTexturesInFragmentStage</code> (default 4)</li>
</ul>
<p>Like other limits, you can check when you request an adapter
what the adapter supports and require higher than the defaults
if you need more.</p>
<p>As mentioned above, about 45% of devices support <code class="notranslate" translate="no">0</code>
storage buffers and storage textures in vertex shaders.</p>
</li>
</ul>
<h1 id="upgrading-from-compatibility-mode-to-core">Upgrading from compatibility mode to core</h1>
<p>Compatibility mode was designed for you to opt-in. If you
can design your application to live with the restrictions above
then you ask for compatibility mode. If not, ask for core, the
default, if the device can’t handle core it will not return
an adapter.</p>
<p>On the the other hand, you can also to design your app to function
in compatibility mode but take advantage of all the core features
if the user has a device that supports core WebGPU.</p>
<p>To do this, ask for a compatibility mode adapter, then check
for and enable the <code class="notranslate" translate="no">core-features-and-limits</code> feature. If it
exists on the adapter AND you require it on the device the
device will be a core device and none of the restrictions above
will apply.</p>
<p>Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const hasCore = adapter.features.has('core-features-and-limits');
const device = await adapter.requestDevice({
  requiredFeatures: [
    ...(hasCore ? ['core-features-and-limits'] : []),
  ],
});
</pre>
<p>If <code class="notranslate" translate="no">hasCore</code> is true then none of the above restrictions and limits apply.</p>
<p>Note that other code that wants to check if the device is a core or
compatibility device should check the device’s features.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const isCore = device.features.has('core-features-and-limits');
</pre>
<p>This will always be true on a core device.</p>
<blockquote>
<p>Note: As of 2025-03-11, some browsers have not yet fully shipped WebGPU and
have not added <code class="notranslate" translate="no">'core'features-and'limits'</code> to their implementations.
They should be updated soon.</p>
</blockquote>
<h1 id="testing-compatibility-mode">Testing compatibility mode</h1>
<p>On a browser that supports compatibility mode you can test your
application follows the restrictions by NOT requesting <code class="notranslate" translate="no">'core-features-and-limits'</code> (as we did at the top).
You may want to check that you actually have a compatibility
device so you can know that the restrictions and limits are
being enforced.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const adapter = await navigator.gpu.requestAdapter({
  featureLevel: 'compatibility',
});
const device = await adapter.requestDevice();

const isCompatibilityMode = !device.features.has('core-features-and-limits');
</pre>
<p>This is a good way to test if your app will run on these older devices.</p>
<blockquote>
<p>Note: As of 2025-03-11, some browsers have not yet fully shipped WebGPU and
have not added <code class="notranslate" translate="no">'core'features-and'limits'</code> to their implementations.
They should be updated soon.</p>
</blockquote>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-compatibility-mode.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-compatibility-mode.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compatibility-mode.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compatibility-mode.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compatibility-mode.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compatibility-mode.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compatibility-mode.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Basic CRT Effect</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Compatibility Mode`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>