<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-compute-shaders.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to use compute shaders in WebGPU">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_en.jpg">

<meta property="og:title" content="WebGPU Compute Shader Basics">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_en.jpg">
<meta property="og:description" content="How to use compute shaders in WebGPU">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Compute Shader Basics">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html">
<meta name="twitter:description" content="How to use compute shaders in WebGPU">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-compute-shaders_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html",
      "inLanguage":"en",
      "name":"WebGPU Compute Shader Basics",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Compute Shader Basics</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-compute-shaders.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-compute-shaders.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compute-shaders.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compute-shaders.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compute-shaders.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compute-shaders.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compute-shaders.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compute-shaders.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Compute Shader Basics</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article continues from <a href="webgpu-fundamentals.html">the article on fundamentals</a>.
We’re going to start with some basic of compute shaders and then hopefully move on
to examples of solving real world problems.</p>
<p>In the <a href="webgpu-fundamentals.html">previous article</a> we made an extremely simple
compute shader that doubled numbers in place.</p>
<p>Here’s the shader</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

@compute @workgroup_size(1) fn computeSomething(
  @builtin(global_invocation_id) id: vec3&lt;u32&gt;
) {
  let i = id.x;
  data[i] = data[i] * 2.0;
}
</pre>
<p>We then effectively ran the compute shader like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  ...
  pass.dispatchWorkgroups(count);
</pre>
<p>We need to go over the definition of workgroup.</p>
<p>You can think of a workgroup as small collection of threads. Each thread
runs in parallel. You define the size of workgroup statically in WGSL.
Workgroup sizes are defined in 3 dimensions but default to 1 so
our <code class="notranslate" translate="no">@workgroup_size(1)</code> is equivalent to <code class="notranslate" translate="no">@workgroup_size(1, 1, 1)</code>.</p>
<p><a id="a-local-invocation-id"></a>If we define a workgroup as say <code class="notranslate" translate="no">@workgroup_size(3, 4, 2)</code> then we’re
defining 3 * 4 * 2 threads or another way put it, we’re defining a 24 thread workgroup.</p>
<div class="webgpu_center">
  <img src="resources/gpu-workgroup.svg" style="width: 500px;">
  <div><code class="notranslate" translate="no">local_invocation_id</code> of threads in a workgroup</div>
</div>
<p><a id="a-workgroup-id"></a>If we then call <code class="notranslate" translate="no">pass.dispatchWorkgroups(4, 3, 2)</code> we’re saying, execute a workgroup of 24 threads,
4 * 3 * 2 times (24) for a total of 576 threads.</p>
<div class="webgpu_center">
  <img src="resources/gpu-workgroup-dispatch.svg" style="width: 500px;">
  <div><code class="notranslate" translate="no">workgroup_id</code> of dispatched workgroups</div>
</div>
<p>Inside each “invocation” of our compute shader the following builtin variables
are available.</p>
<ul>
<li>
<p><code class="notranslate" translate="no">local_invocation_id</code>: The id of this thread within a workgroup</p>
<p><a href="#a-local-invocation-id">See the diagram above</a>.</p>
</li>
<li>
<p><code class="notranslate" translate="no">workgroup_id</code>: The id of the workgroup.</p>
<p>Every thread within a workgroup will have the same workgroup id.
<a href="#a-workgroup-id">See the diagram above</a>.</p>
</li>
<li>
<p><code class="notranslate" translate="no">global_invocation_id</code>: A unique id for each thread</p>
<p>You can think of this as</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">global_invocation_id = workgroup_id * workgroup_size + local_invocation_id
</pre>
</li>
<li>
<p><code class="notranslate" translate="no">num_workgroups</code>: What you passed to <code class="notranslate" translate="no">pass.dispatchWorkgroups</code></p>
</li>
<li>
<p><code class="notranslate" translate="no">local_invocation_index</code>: The id of this thread linearized</p>
<p>You can think of this as</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">rowSize = workgroup_size.x
sliceSize = rowWidth * workgroup_size.y
local_invocation_index =
      local_invocation_id.x +
      local_invocation_id.y * rowSize +
      local_invocation_id.z * sliceSize
</pre>
</li>
</ul>
<p>Let’s make a sample to use these values. We’ll just write the values
from each invocation to buffers and then print out the values</p>
<p>Here’s the shader</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const dispatchCount = [4, 3, 2];
const workgroupSize = [2, 3, 4];

// multiply all elements of an array
const arrayProd = arr =&gt; arr.reduce((a, b) =&gt; a * b);

const numThreadsPerWorkgroup = arrayProd(workgroupSize);

const code = `
// NOTE!: vec3u is padded to by 4 bytes
@group(0) @binding(0) var&lt;storage, read_write&gt; workgroupResult: array&lt;vec3u&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; localResult: array&lt;vec3u&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; globalResult: array&lt;vec3u&gt;;

@compute @workgroup_size(${workgroupSize}) fn computeSomething(
    @builtin(workgroup_id) workgroup_id : vec3&lt;u32&gt;,
    @builtin(local_invocation_id) local_invocation_id : vec3&lt;u32&gt;,
    @builtin(global_invocation_id) global_invocation_id : vec3&lt;u32&gt;,
    @builtin(local_invocation_index) local_invocation_index: u32,
    @builtin(num_workgroups) num_workgroups: vec3&lt;u32&gt;
) {
  // workgroup_index is similar to local_invocation_index except for
  // workgroups, not threads inside a workgroup.
  // It is not a builtin so we compute it ourselves.

  let workgroup_index =  
     workgroup_id.x +
     workgroup_id.y * num_workgroups.x +
     workgroup_id.z * num_workgroups.x * num_workgroups.y;

  // global_invocation_index is like local_invocation_index
  // except linear across all invocations across all dispatched
  // workgroups. It is not a builtin so we compute it ourselves.

  let global_invocation_index =
     workgroup_index * ${numThreadsPerWorkgroup} +
     local_invocation_index;

  // now we can write each of these builtins to our buffers.
  workgroupResult[global_invocation_index] = workgroup_id;
  localResult[global_invocation_index] = local_invocation_id;
  globalResult[global_invocation_index] = global_invocation_id;
`;
</pre>
<p>We used a JavaScript template literal so we can set the workgroup size
from the JavaScript variable <code class="notranslate" translate="no">workgroupSize</code>. This ends up being
hard coded into the shader.</p>
<p>Now that we have the shader we can make 3 buffers to store these results.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const numWorkgroups = arrayProd(dispatchCount);
  const numResults = numWorkgroups * numThreadsPerWorkgroup;
  const size = numResults * 4 * 4;  // vec3f * u32

  let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC;
  const workgroupBuffer = device.createBuffer({size, usage});
  const localBuffer = device.createBuffer({size, usage});
  const globalBuffer = device.createBuffer({size, usage});
</pre>
<p>As we pointed out before, we can not map storage buffers into
JavaScript so we need some buffers to we can map. We’ll copy
the results from the storage buffers to these mappable result
buffers and then read the results.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  usage = GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST;
  const workgroupReadBuffer = device.createBuffer({size, usage});
  const localReadBuffer = device.createBuffer({size, usage});
  const globalReadBuffer = device.createBuffer({size, usage});
</pre>
<p>We make a bindgroup to bind all our storage buffers</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: workgroupBuffer }},
      { binding: 1, resource: { buffer: localBuffer }},
      { binding: 2, resource: { buffer: globalBuffer }},
    ],
  });
</pre>
<p>We start an encoder and a compute pass encoder, the same as our previous
example, then add the commands to run the compute shader.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Encode commands to do the computation
  const encoder = device.createCommandEncoder({ label: 'compute builtin encoder' });
  const pass = encoder.beginComputePass({ label: 'compute builtin pass' });

  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(...dispatchCount);
  pass.end();
</pre>
<p>We need to copy the results from the storage buffers to the mappable
result buffers.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  encoder.copyBufferToBuffer(workgroupBuffer, 0, workgroupReadBuffer, 0, size);
  encoder.copyBufferToBuffer(localBuffer, 0, localReadBuffer, 0, size);
  encoder.copyBufferToBuffer(globalBuffer, 0, globalReadBuffer, 0, size);
</pre>
<p>And then end the encoder and submit the command buffer.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Finish encoding and submit the commands
  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);
</pre>
<p>Like before, to read the results we map the buffers and once they are
ready we get typed array views of their contents.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Read the results
   await Promise.all([
    workgroupReadBuffer.mapAsync(GPUMapMode.READ),
    localReadBuffer.mapAsync(GPUMapMode.READ),
    globalReadBuffer.mapAsync(GPUMapMode.READ),
  ]);

  const workgroup = new Uint32Array(workgroupReadBuffer.getMappedRange());
  const local = new Uint32Array(localReadBuffer.getMappedRange());
  const global = new Uint32Array(globalReadBuffer.getMappedRange());
</pre>
<blockquote>
<p>Important: We mapped 3 buffers here and used <code class="notranslate" translate="no">await Promise.all</code> to wait
for them all to be ready to use. You can *<em>NOT</em> just wait on the last
buffer. You must wait on all 3 buffers.</p>
</blockquote>
<p>Finally we can print them out</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const get3 = (arr, i) =&gt; {
    const off = i * 4;
    return `${arr[off]}, ${arr[off + 1]}, ${arr[off + 2]}`;
  };

  for (let i = 0; i &lt; numResults; ++i) {
    if (i % numThreadsPerWorkgroup === 0) {
      log(`\
 ---------------------------------------
 global                 local     global   dispatch: ${i / numThreadsPerWorkgroup}
 invoc.    workgroup    invoc.    invoc.
 index     id           id        id
 ---------------------------------------`);
    }
    log(` ${i.toString().padStart(3)}:      ${get3(workgroup, i)}      ${get3(local, i)}   ${get3(global, i)}`)
  }
}

function log(...args) {
  const elem = document.createElement('pre');
  elem.textContent = args.join(' ');
  document.body.appendChild(elem);
}
</pre>
<p>Here’s the result</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-compute-shaders-builtins.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-compute-shaders-builtins.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>These builtins are generally the only inputs that change
per thread of a compute shader for one call to <code class="notranslate" translate="no">pass.dispatchWorkgroups</code>
so to be effective you need to figure out how to use them to design
a compute shader function to do what you want, given these <code class="notranslate" translate="no">..._id</code>
builtins as input.</p>
<h2 id="workgroup-size">Workgroup Size</h2>
<p>What size should you make a workgroup? The question often comes up,
why not just always use <code class="notranslate" translate="no">@workgroup_size(1, 1, 1)</code> and then it would
be more trivial to decide how many iterations to run by only the
parameters to <code class="notranslate" translate="no">pass.dispatchWorkgroups</code>.</p>
<p>The reason is multiple threads within a workgroup are faster than
individual dispatches.</p>
<p>For one, threads in a workgroup often run in lockstep so running
16 of them is just as fast as running 1.</p>
<p>The default limits for WebGPU are as follows</p>
<ul>
<li><code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code>: 256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeX</code>: 256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeY</code>:	256</li>
<li><code class="notranslate" translate="no">maxComputeWorkgroupSizeZ</code>:	64</li>
</ul>
<p>As you can see, the first limit <code class="notranslate" translate="no">maxComputeInvocationsPerWorkgroup</code> means the 3 parameters
to <code class="notranslate" translate="no">@workgroup_size</code> can not multiply to a number larger than 256. In other words</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">   @workgroup_size(256, 1, 1)   // ok
   @workgroup_size(128, 2, 1)   // ok
   @workgroup_size(16, 16, 1)   // ok
   @workgroup_size(16, 16, 2)   // bad 16 * 16 * 2 = 512
</pre>
<p>Unfortunately, the perfect size is GPU dependent and WebGPU can not provide that info.
<strong>The general advice for WebGPU is to choose a workgroup size of 64</strong> unless you have
some specific reason to choose another size. Apparently most GPUs can efficiently
run 64 things in lockstep. If you choose a higher number and the GPU can’t do it
as a fast path it will chose a slower path. If on the other hand you chose a number
below what the GPU can do then you may not get the maximum performance.</p>
<h2 id="races-in-compute-shaders"><a href="a-race-conditions"></a>Races in Compute Shaders</h2>
<p>A common mistake in WebGPU is not handling race conditions. A race
condition is where multiple threads are running at the same time and
effectively they are in a race for who comes in first or last.</p>
<p>Let’s say you had this compute shader</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; result: array&lt;f32&gt;;

@compute @workgroup_size(32) fn computeSomething(
    @builtin(local_invocation_id) local_invocation_id : vec3&lt;u32&gt;,
) {
  result[0] = local_invocation_id.x;
`;
</pre>
<p>If that’s hard to read, here’s kind of the same JavaScript</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const result = [];
for (let i = 0; i &lt; 32; ++i) {
  result[0] = i;
}
</pre>
<p>In the JavaScript case, after the code runs, <code class="notranslate" translate="no">result[0]</code> is clearly 31. In the compute shader case though,
all 32 iterations of the shader are running in parallel. Which ever one finishes
last is the one who’s value will be in <code class="notranslate" translate="no">result[0]</code>. Which one runs last is undefined.</p>
<p>From the spec:</p>
<blockquote>
<p>WebGPU provides no guarantees about:</p>
<ul>
<li>
<p>Whether invocations from different workgroups execute concurrently. That is,
you cannot assume more than one workgroup executes at a time.</p>
</li>
<li>
<p>Whether, once invocations from a workgroup begin executing, that other
workgroups are blocked from execution. That is, you cannot assume that only
one workgroup executes at a time. While a workgroup is executing, the
implementation may choose to concurrently execute other workgroups as well,
or other queued but unblocked work.</p>
</li>
<li>
<p>Whether invocations from one particular workgroup begin executing before the
invocations of another workgroup. That is, you cannot assume that workgroups
are launched in a particular order.</p>
</li>
</ul>
</blockquote>
<p>We’ll go over some of the ways to deal with this issue in future examples. For now, our
two examples have no race conditions as each iteration of the compute shader does something
unaffected by the other iterations.</p>
<p>Next up: <a href="webgpu-compute-shaders-histogram.html">Example Compute Shaders - Image Histogram</a></p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-compute-shaders.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-compute-shaders.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-compute-shaders.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-compute-shaders.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-compute-shaders.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-compute-shaders.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-compute-shaders.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-compute-shaders.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Post Processing</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Compute Shader Basics`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>