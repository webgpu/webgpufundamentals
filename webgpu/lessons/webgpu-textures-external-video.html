<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-textures-external-video.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to use video in WebGPU">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_en.jpg">

<meta property="og:title" content="WebGPU Using Video Efficiently">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_en.jpg">
<meta property="og:description" content="How to use video in WebGPU">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Using Video Efficiently">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html">
<meta name="twitter:description" content="How to use video in WebGPU">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-textures-external-video_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html",
      "inLanguage":"en",
      "name":"WebGPU Using Video Efficiently",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Using Video Efficiently</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-textures-external-video.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-textures-external-video.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-textures-external-video.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-textures-external-video.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-textures-external-video.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-textures-external-video.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-textures-external-video.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-textures-external-video.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Using Video Efficiently</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>In the <a href="webgpu-importing-textures.html">previous article</a>, we covered
how to load images, canvases, and video into a texture.
This article will cover a more efficient way to use video in WebGPU.</p>
<p>In the previous article we loaded video data into a webgpu texture
by calling <code class="notranslate" translate="no">copyExternalImageToTexture</code>. This function copies
the current frame of video from the video itself into a pre-existing
texture that we created.</p>
<p>WebGPU has another method for using video. It’s called <code class="notranslate" translate="no">importExternalTexture</code>
and, like the name suggests, it provides a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUExternalTexture"><code class="notranslate" translate="no">GPUExternalTexture</code></a>. This external
texture represents the data in the video directly. No copy is made. <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>
You pass <code class="notranslate" translate="no">importExternalTexture</code> a video and it returns a texture, ready to use.</p>
<p>There are a few big caveats to using an texture from <code class="notranslate" translate="no">importExternalTexture</code>.</p>
<ul>
<li>
<h2 id="the-texture-is-only-valid-until-you-exit-the-current-javascript-task">The texture is only valid until you exit the current JavaScript task.</h2>
<p>For most WebGPU apps that means the texture only exists until your
<code class="notranslate" translate="no">requestAnimationCallback</code> function ends. Or whatever event you’re rendering on; <code class="notranslate" translate="no">requestVideoFrameCallback</code>, <code class="notranslate" translate="no">setTimeout</code>,
<code class="notranslate" translate="no">mouseMove</code>, etc…  When your function exits the texture is expired.
To use the video again you must call <code class="notranslate" translate="no">importExternalTexture</code> again.</p>
<p>An implication of this is that you must make a new bindgroup each
time you call <code class="notranslate" translate="no">importExternalTexture</code> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> so that
you can pass the new texture into your shader.</p>
</li>
<li>
<h2 id="you-must-use-texture_external-in-your-shaders">You must use <code class="notranslate" translate="no">texture_external</code> in your shaders</h2>
<p>We’ve been using <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code> in all previous texture examples
but textures from <code class="notranslate" translate="no">importExternalTexture</code> can only be bound to
binding points using <code class="notranslate" translate="no">texture_external</code>.</p>
</li>
<li>
<h2 id="you-must-use-texturesamplebaseclamptoedge-in-your-shaders">You must use <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code> in your shaders</h2>
<p>We’ve been using <code class="notranslate" translate="no">textureSample</code> in all previous texture examples
but textures from <code class="notranslate" translate="no">importExternalTexture</code> can only use
<code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>. <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> Like the name suggests,
<code class="notranslate" translate="no">textureSampleBaseClampToEdge</code> will only sample the base texture mip level
(level 0). In other words, external textures can not have a mipmap.
Further, the function clamps to the edge, meaning, setting a sampler
to <code class="notranslate" translate="no">addressModeU: 'repeat'</code> will be ignored.</p>
<p>Note that you can do your own repeating by using <code class="notranslate" translate="no">fract</code> as in:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">let color = textureSAmpleBaseClampToEdge(
   someExternalTexture,
   someSampler,
   fract(texcoord)
);`
</pre>
</li>
</ul>
<p>If these restrictions are not okay for your needs then you’ll need to use
<code class="notranslate" translate="no">copyExternalImageToTexture</code> like we covered in <a href="webgpu-importing-textures.html">the previous article</a>.</p>
<p>Let’s make a working example using <code class="notranslate" translate="no">importExternalTexture</code>. Here’s a video</p>
<div class="webgpu_center">
  <div>
     <video muted="" controls="" src="../resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4" style="width: 320px" ;=""></video>
     <div class="copyright"><a href="https://www.pexels.com/video/dog-walking-outside-the-house-5534310/">by Anna Bondarenko</a></div>
  </div>
</div>
<p>Here are the changes need from our previous example.</p>
<p>First we need to update our shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurVertexShaderOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
};

struct Uniforms {
  matrix: mat4x4f,
};

@group(0) @binding(2) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32
) -&gt; OurVertexShaderOutput {
  let pos = array(
    // 1st triangle
    vec2f( 0.0,  0.0),  // center
    vec2f( 1.0,  0.0),  // right, center
    vec2f( 0.0,  1.0),  // center, top

    // 2nd triangle
    vec2f( 0.0,  1.0),  // center, top
    vec2f( 1.0,  0.0),  // right, center
    vec2f( 1.0,  1.0),  // right, top
  );

  var vsOutput: OurVertexShaderOutput;
  let xy = pos[vertexIndex];
  vsOutput.position = uni.matrix * vec4f(xy, 0.0, 1.0);
-  vsOutput.texcoord = xy * vec2f(1, 50);
+  vsOutput.texcoord = xy;
  return vsOutput;
}

@group(0) @binding(0) var ourSampler: sampler;
-@group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;
+@group(0) @binding(1) var ourTexture: texture_external;

@fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-  return textureSample(ourTexture, ourSampler, fsInput.texcoord);
+  return textureSampleBaseClampToEdge(
+      ourTexture,
+      ourSampler,
+      fsInput.texcoord,
+  );
}
</pre>
<p>Above we stopped multiplying the texture coordinates by 50
since that was only there to show repeating and external textures
do not repeat.</p>
<p>We also made the required changes as mentioned above. <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>
becomes <code class="notranslate" translate="no">texture_external</code> and <code class="notranslate" translate="no">textureSample</code> becomes <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code>.</p>
<p>We removed all of the code related to creating a texture and
to generating mips.</p>
<p>We of course need to point to our video</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  video.src = 'resources/videos/Golden_retriever_swimming_the_doggy_paddle-360-no-audio.webm';
+  video.src = 'resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4';
</pre>
<p>Since we can’t have mip levels there’s no need to create samplers that
would use them.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const objectInfos = [];
-  for (let i = 0; i &lt; 8; ++i) {
+  for (let i = 0; i &lt; 4; ++i) {
    const sampler = device.createSampler({
      addressModeU: 'repeat',
      addressModeV: 'repeat',
      magFilter: (i &amp; 1) ? 'linear' : 'nearest',
      minFilter: (i &amp; 2) ? 'linear' : 'nearest',
-      mipmapFilter: (i &amp; 4) ? 'linear' : 'nearest',
    });

  ...
</pre>
<p>Since we don’t get a texture until we call <code class="notranslate" translate="no">importExternalTexture</code> we can’t
create our bindgroups in advance so we’ll save off the information needed to
create them later . <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const objectInfos = [];
  for (let i = 0; i &lt; 4; ++i) {

    ...

-    const bindGroups = textures.map(texture =&gt;
-      device.createBindGroup({
-        layout: pipeline.getBindGroupLayout(0),
-        entries: [
-          { binding: 0, resource: sampler },
-          { binding: 1, resource: texture.createView() },
-          { binding: 2, resource: { buffer: uniformBuffer }},
-        ],
-      }));

    // Save the data we need to render this object.
    objectInfos.push({
-      bindGroups,
+     sampler,
      matrix,
      uniformValues,
      uniformBuffer,
    });
</pre>
<p>At render time we’ll call <code class="notranslate" translate="no">importExternalTexture</code> and create
the bindgroups</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
-    copySourceToTexture(device, texture, video);
    ...

    const encoder = device.createCommandEncoder({
      label: 'render quad encoder',
    });
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

+    const texture = device.importExternalTexture({source: video});

    objectInfos.forEach(({sampler, matrix, uniformBuffer, uniformValues}, i) =&gt; {
+      const bindGroup = device.createBindGroup({
+        layout: pipeline.getBindGroupLayout(0),
+        entries: [
+          { binding: 0, resource: sampler },
+          { binding: 1, resource: texture },
+          { binding: 2, resource: { buffer: uniformBuffer }},
+        ],
+      });

      ...

      pass.setBindGroup(0, bindGroup);
      pass.draw(6);  // call our vertex shader 6 times
    });
</pre>
<p>Also, given we can’t repeat the texture, let’s adjust the
matrix math to make the quads we are drawing more visible
and not stretch them out 50 to 1 like we had before.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    ...
    objectInfos.forEach(({bindGroups, matrix, uniformBuffer, uniformValues}, i) =&gt; {
      const bindGroup = bindGroups[texNdx];

      const xSpacing = 1.2;
-      const ySpacing = 0.7;
-      const zDepth = 50;
+      const ySpacing = 0.5;
+      const zDepth = 1;

-      const x = i % 4 - 1.5;
-      const y = i &lt; 4 ? 1 : -1;
+      const x = i % 2 - .5;
+      const y = i &lt; 2 ? 1 : -1;

      mat4.translate(viewProjectionMatrix, [x * xSpacing, y * ySpacing, -zDepth * 0.5], matrix);
-      mat4.rotateX(matrix, 0.5 * Math.PI, matrix);
-      mat4.scale(matrix, [1, zDepth * 2, 1], matrix);
+      mat4.rotateX(matrix, 0.25 * Math.PI * Math.sign(y), matrix);
+      mat4.scale(matrix, [1, -1, 1], matrix);
      mat4.translate(matrix, [-0.5, -0.5, 0], matrix);

      // copy the values from JavaScript to the GPU
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      pass.setBindGroup(0, bindGroup);
      pass.draw(6);  // call our vertex shader 6 times
    });

</pre>
<p>And with that we get a zero copy video texture in WebGPU</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-textured-quad-external-video.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-textured-quad-external-video.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="why-texture_external">Why <code class="notranslate" translate="no">texture_external</code>?</h2>
<p>Some of you might notice the fact that this way if using video uses
<code class="notranslate" translate="no">texture_external</code> instead of something more common like <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>
and it uses <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code> instead of just <code class="notranslate" translate="no">textureSample</code>
and that means if you want to use this way of using textures and you want
to mix it with with other parts of your rendering, you’ll need different
shaders. Shaders that using <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code> when using a static
texture and different shaders using <code class="notranslate" translate="no">texture_external</code> when you want
to use a video.</p>
<p>I think it’s important to understand what’s happing under the hood here.</p>
<p>Video is often delivered with the luminance part of the video (the brightness of each pixel),
separate from the chroma part of the video (the color of each pixel). Often the resolution
of the color is lower than the luminance part. A common way of separating and encoding this is
<a href="https://en.wikipedia.org/wiki/Y%E2%80%B2UV">YUV</a> where the data is separated into
luminance (Y), and (UV) color info. This representation generally compresses better
too.</p>
<p>WebGPU’s goal for external textures is to use the video directly in the format it’s provided.
To do this it <em>pretends</em> there is a video texture but in the actual implementation
there may be multiple textures. For example, one texture with the luminance values (Y)
and a separate texture with the UV values. And, those UV values might be specially separated.
Instead being a texture of something like 2 values per pixel interleaved</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
uvuvuvuvuvuvuvuv
</pre>
<p>They might be arranged like this</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
uuuuuuuu
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
vvvvvvvv
</pre>
<p>one (u) value per pixel in one area of a texture and one (v) value in another area.
Again, because arranging the data like this often compresses better.</p>
<p>When you add <code class="notranslate" translate="no">texture_external</code> and <code class="notranslate" translate="no">textureSampleBaseClampToEdge</code> to your
shader, WebGPU, behind the scenes, injects code into your shader that takes this
video data and gives you back an RGBA value. It may sample from multiple
textures and or have to do texture coordinate math in order to pull the correct
data out from 2, 3 or more places and convert to RGB.</p>
<p>Here are the Y, U, and V channels from the video above</p>
<div class="webgpu_center">
  <div class="side-by-side">
    <div class="separate">
      <img src="../resources/videos/pexels-anna-bordarenko-5534310-y-channel.png" style="width: 300px;">
      <div>Y channel (luminance)</div>
    </div>
    <div class="separate">
      <div class="side-by-side">
        <div class="separate">
          <img src="../resources/videos/pexels-anna-bordarenko-5534310-u-channel.png" style="width: 150px;">
          <div>U channel<br>(red ↔ yellow)</div>
        </div>
        <div class="separate">
          <img src="../resources/videos/pexels-anna-bordarenko-5534310-v-channel.png" style="width: 150px;">
          <div>V channel<br>( blue ↔ yellow)</div>
        </div>
      </div>
    </div>
  </div>
</div>
<p>WebGPU is effectively providing an optimization here. Traditional graphics
libraries this would be left to you. Either you’d write the code yourself
to convert from YUV to RGB, or you’d ask the OS to do it. You’d copy the data
to an RGBA texture and then use that RGBA texture as <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code>. This
way is more flexible. You don’t have to write different shaders for video vs
static textures. But, it’s slower because the conversion has to happen from
the YUV textures, to the RGBA texture.</p>
<p>This slower more flexible method is still available in WebGPU and we covered it
<a href="webgpu-importing-textures.html#a-loading-video">in the previous article</a>.
If you need the flexibility, if you want to be able to use video everywhere without
needing different shaders for video vs static images then use that method.</p>
<p>One reason WebGPU provides this optimization for <code class="notranslate" translate="no">texture_external</code> is because this
is the web. What formats of video are supported in the browser change over time.
WebGPU will handle this for you where as if you had to write the shader yourself
to convert from YUV to RGB, you’d also need to know the format of videos will not
change and that is not a guarantee the web can make.</p>
<p>The most obvious places to use the <code class="notranslate" translate="no">texture_external</code> method described
in this article would be video related features like say meet, zoom, FB messenger
related features, like when doing face recognition for adding visualizations or
background separation. Another might be for VR video once WebGPU is supported in WebXR.</p>
<h2 id="using-the-camera"><a id="a-web-camera"></a> Using the Camera</h2>
<p>In fact, let’s use the camera. It’s a very small change.</p>
<p>First, we don’t specify a video to play.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const video = document.createElement('video');
-  video.muted = true;
-  video.loop = true;
-  video.preload = 'auto';
-  video.src = 'resources/videos/pexels-anna-bondarenko-5534310 (540p).mp4'; /* webgpufundamentals: url */
  await waitForClick();
  await startPlayingAndWaitForVideo(video);
</pre>
<p>Then, when the user clicks play, we call <code class="notranslate" translate="no">getUserMedia</code> and ask for the camera. The resulting stream
is then applied to the video. There are no changes to the WebGPU parts of the code.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function waitForClick() {
    return new Promise(resolve =&gt; {
      window.addEventListener(
        'click',
-        () =&gt; {
+        async() =&gt; {
          document.querySelector('#start').style.display = 'none';
-          resolve();
+          try {
+            const stream = await navigator.mediaDevices.getUserMedia({
+              video: true,
+            });
+            video.srcObject = stream;
+            resolve();
+          } catch (e) {
+            fail(`could not access camera: ${e.message ?? ''}`);
+          }
        },
        { once: true });
    });
  }
</pre>
<p>Done!</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-textured-quad-external-video-camera.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-textured-quad-external-video-camera.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>We could make similar changes to
<a href="webgpu-importing-textures.html#a-loading-video">the video example in the previous article</a>
if wanted the camera image as the more flexible <code class="notranslate" translate="no">texture&lt;f32&gt;</code> type texture instead of
the more efficient <code class="notranslate" translate="no">texture_external</code> type of texture.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>What actually happens is up to the browser implementation.
The WebGPU spec was designed in the hope that browser would not need
to make a copy. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The spec actually says the implementation
can return the same texture but it is not required to. If you
want to check if you got the same texture, compare it to the previous
texture as in </p><pre class="prettyprint showlinemods notranslate notranslate" translate="no">const newTexture = device.importExternalTexture(…);<br>const same = oldTexture === newTexture;</pre> If it is
the same texture then you can reuse your existing bindgroup and
referenced <code class="notranslate" translate="no">oldTexture</code>. <a href="#fnref2" class="footnote-backref">↩︎</a><p></p>
</li>
<li id="fn3" class="footnote-item"><p>You can also use <code class="notranslate" translate="no">textureLoad</code> with external textures. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>We could split the bind groups so there’s
one that holds the sampler and uniformBuffer which we could create
in advance and another that just references the external texture that
we create at render time. Whether that’s worth it is up to your particular needs. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-textures-external-video.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-textures-external-video.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-textures-external-video.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-textures-external-video.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-textures-external-video.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-textures-external-video.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-textures-external-video.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-textures-external-video.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Post Processing</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Using Video Efficiently`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>