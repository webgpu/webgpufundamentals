<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-resizing-the-canvas.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to resize a WebGPU canvas and the issues involved">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-resizing-the-canvas_en.jpg">

<meta property="og:title" content="WebGPU Resizing the Canvas.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-resizing-the-canvas_en.jpg">
<meta property="og:description" content="How to resize a WebGPU canvas and the issues involved">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Resizing the Canvas.">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html">
<meta name="twitter:description" content="How to resize a WebGPU canvas and the issues involved">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-resizing-the-canvas_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-resizing-the-canvas_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html",
      "inLanguage":"en",
      "name":"WebGPU Resizing the Canvas.",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Resizing the Canvas.</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-resizing-the-canvas.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-resizing-the-canvas.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Êó•Êú¨Ë™û
    </option><option value="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">ÌïúÍµ≠Ïñ¥
    </option><option value="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">–†—É—Å—Å–∫–∏–π
    </option><option value="/webgpu/lessons/uk/webgpu-resizing-the-canvas.html">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞
    </option><option value="/webgpu/lessons/zh_cn/webgpu-resizing-the-canvas.html">ÁÆÄ‰Ωì‰∏≠Êñá
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Resizing the Canvas.</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>In <a href="webgpu-fundamentals.html">the article on webgpu fundamentals</a> we setup a basic
structure for setting the resolution of the canvas to match the size it‚Äôs displayed.
Let‚Äôs go over some of the details of resizing a canvas.</p>
<p>Every canvas has 2 sizes. The size of its <em>drawing buffer</em>.
This is how many pixels are in the canvas itself.
The second size is the size the canvas is displayed. CSS determines the size the canvas is
displayed.</p>
<p>You can set the size of the canvas‚Äôs drawing buffer in 2 ways. One using HTML</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas id="c" width="400" height="300"&gt;&lt;/canvas&gt;
</pre>
<p>The other using JavaScript</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas id="c"&gt;&lt;/canvas&gt;
</pre>
<p>JavaScript</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const canvas = document.querySelector("#c");
canvas.width = 400;
canvas.height = 300;
</pre>
<p>As for setting a canvas‚Äôs display size, if you don‚Äôt have any CSS that affects the canvas‚Äôs display size
the display size will be the same size as its drawing buffer. So, in the 2 examples above, the canvas‚Äôs drawingbuffer is 400x300
and its display size is also 400x300.</p>
<p>Here‚Äôs an example of a canvas whose drawing buffer is 10x15 pixels that is displayed 400x300 pixels on the page</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas id="c" width="10" height="15" style="width: 400px; height: 300px;"&gt;&lt;/canvas&gt;
</pre>
<p>or for example like this</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;style&gt;
#c {
  width: 400px;
  height: 300px;
}
&lt;/style&gt;
&lt;canvas id="c" width="10" height="15"&gt;&lt;/canvas&gt;
</pre>
<p>If we draw a single pixel wide rotating line into that canvas we‚Äôll see something like this</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-10x15-canvas-400x300-css.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-10x15-canvas-400x300-css.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Why is it so blurry? Because the browser takes our 10x15 pixel canvas and stretches it to 400x300 pixels and
generally it <em>filters</em> it when it stretches it.</p>
<p>So, what do we do if, for example, we want the canvas to fill the window? Well, first we can get
the browser to stretch the canvas to fill the window with CSS. Example:</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
    html, body {
      margin: 0;       /* remove the default margin          */
      height: 100%;    /* make the html,body fill the page   */
    }
    #c {
      display: block;  /* make the canvas act like a block   */
      width: 100%;     /* make the canvas fill its container */
      height: 100%;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id="c"&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Now we just need to make the drawing buffer match whatever size the browser has stretched the canvas.
This is unfortunately a more complicated topic than you might expect. Let‚Äôs go over some different methods</p>
<h2 id="use-resizeobserver">Use <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a></h2>
<p>We covered this in <a href="webgpu-fundamentals.html">the article on webgpu fundamentals</a>.
This is the modern way and every browser that supports WebGPU also supports
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>.</p>
<p>To repeat what we wrote in the other article: You create a
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> and give it a function to call whenever the elements you‚Äôve
asked it to observe change their size. You then tell it which elements to
observe.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const observer = new ResizeObserver(entries =&gt; {
  for (const entry of entries) {
    const width = entry.contentBoxSize[0].inlineSize;
    const height = entry.contentBoxSize[0].blockSize;
    const canvas = entry.target;
    canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
    canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
  }
});
observer.observe(canvas);
</pre>
<p>In the code above we go over all the entries but there should only ever be one
because we‚Äôre only observing one canvas. We need to limit the size of the canvas
to the largest size our device supports otherwise WebGPU will start generating
errors that we tried to make a texture that is too large. We also need to make
sure it doesn‚Äôt go to zero or again we‚Äôll get errors.</p>
<p>If we‚Äôre only rendering on demand then we might put a call to our render
function inside the code above. Otherwise, if we‚Äôre animating by using a
<code class="notranslate" translate="no">requestAnimationFrame</code> loop (rAF loop), or other means, then the next time we
render we‚Äôll get a texture that matches the size we set on the canvas when we
call <code class="notranslate" translate="no">context.getCurrentTexture()</code>.</p>
<blockquote>
<p>Note that <code class="notranslate" translate="no">inlineSize</code> and <code class="notranslate" translate="no">blockSize</code> are not integers</p>
</blockquote>
<h2 id="use-clientwidth-and-clientheight">Use <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code></h2>
<p>Before <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> existed it was common to use
<code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code>.
These are properties every element in HTML has that tell us
the size of the element in CSS pixels.</p>
<blockquote>
<p>Note: The client rect includes any CSS padding so if you‚Äôre using <code class="notranslate" translate="no">clientWidth</code>
and/or <code class="notranslate" translate="no">clientHeight</code> it‚Äôs best not to put any padding on your canvas element.</p>
</blockquote>
<p>Using JavaScript we can check what size that element is being displayed and then adjust
its drawing buffer size to match.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
  canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
</pre>
<p>We‚Äôd use this code just before calling <code class="notranslate" translate="no">context.getCurrentTexture()</code>.</p>
<p>This way seems out of date personally but you‚Äôll likely see it here and there
probably copy and pasted from old examples using other APIs.</p>
<h2 id="use-getboundingclientrect">Use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect</code></a></h2>
<p>Another way to do this is to call <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const rect = canvas.getBoundingClientRect();
  const width = rect.width; 
  const height = rect.height; 
  canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
  canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
</pre>
<p>The difference between <code class="notranslate" translate="no">clientWidth</code>, <code class="notranslate" translate="no">clientHeight</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect</code></a>
is that the width and height from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect</code></a> is not required to
be an integer where as the values of <code class="notranslate" translate="no">clientWidth</code> and <code class="notranslate" translate="no">clientHeight</code> are.</p>
<p>Why would the width or height not be integers? <a href="#a-dpr">See below</a>.</p>
<h2 id="use-windowinnerwidth-and-windowinnerheight">Use <code class="notranslate" translate="no">window.innerWidth</code> and <code class="notranslate" translate="no">window.innerHeight</code></h2>
<p>I see this often and it really seems like an <strong>anti-pattern</strong>.
The reason is it‚Äôs inflexible. The 2 techniques above work in every situation
whereas using <code class="notranslate" translate="no">window.innerWidth</code> and <code class="notranslate" translate="no">window.innerHeight</code> only work in one
specific situation, when you want to fill the page. We‚Äôve already shown
the techniques above fill the page just fine but they also work in every other
situation.</p>
<p>Having the canvas <em>not</em> fill the page. Like a diagram in an article
Or in an editor with a toolbar.</p>
<p>It‚Äôs not more work to use the first 2 techniques so it seems silly to use
this less useful technique. Unfortunately the ‚Äúcopy and paste‚Äù force is strong üòÇ</p>
<h2 id="handling-devicepixelratio-and-zoom"><a id="a-dpr"></a>Handling <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> and Zoom</h2>
<p>Why is that not the end of it? Well, This is where it gets complicated.</p>
<p>The first thing to understand is that most sizes in the browser are in CSS pixel
units. This is an attempt to make the sizes device independent. So for example
at the top of this article we set the canvas‚Äôs display size to 400x300 CSS
pixels. Depending on if the user has an HD-DPI display, or is zoomed in or
zoomed out, or has an OS zoom level set, how many actual pixels that becomes on
the monitor will be different.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> will tell us, in general, the ratio of actual pixels
to CSS pixels on your monitor. For example here‚Äôs your browser‚Äôs current setting</p>
<blockquote>
<div>devicePixelRatio = <span data-diagram="dpr"></span></div>
</blockquote>
<p>If you‚Äôre on a desktop or laptop try pressing
<kbd>ctrl</kbd>+<kbd>+</kbd> and <kbd>ctrl</kbd>+<kbd>-</kbd> to zoom in and out
(<kbd>‚åò</kbd>+<kbd>+</kbd> and <kbd>‚åò</kbd>+<kbd>-</kbd> on Mac). You should see
the number change in Firefox, Chrome, Edge (but not Safari)</p>
<p>So if we want the number of pixels in the canvas to match the number of pixels
actually used to display it the seemingly obvious solution would be to multiply
the values we looked up above like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const observer = new ResizeObserver(entries =&gt; {
  for (const entry of entries) {
-    const width = entry.contentBoxSize[0].inlineSize;
-    const height = entry.contentBoxSize[0].blockSize;
+    const width = entry.contentBoxSize[0].inlineSize * devicePixelRatio;
+    const height = entry.contentBoxSize[0].blockSize * devicePixelRatio;
</pre>
<p>Or this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const width = canvas.clientWidth;
-  const height = canvas.clientHeight;
+ const width = canvas.clientWidth * devicePixelRatio;
+ const height = canvas.clientHeight * devicePixelRatio;
</pre>
<p>Or this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const rect = canvas.getBoundingClientRect();
-  const width = rect.width; 
-  const height = rect.height; 
+  const width = rect.width * devicePixelRatio; 
+  const height = rect.height * devicePixelRatio; 
</pre>
<blockquote>
<p><strong>THE EXAMPLES ABOVE WILL NOT ACTUALLY GIVE THE CORRECT RESULT!!!</strong></p>
</blockquote>
<p>That said, it‚Äôs close and might be good enough for your needs. If you don‚Äôt
care you‚Äôre not getting a perfect 1 to 1 pixel rendering on the screen
then you can use the solutions above.</p>
<p>There are 2 ways to see why the code above doesn‚Äôt provide the correct answer</p>
<ol>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> is not an integer</p>
<p>If you are on Firefox, Edge, or Chrome and press the zoom keys like mentioned
above you can easily see fractional <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> values.</p>
</li>
<li>
<p>The size of any element itself is not an integer</p>
<p>Above we saw that both <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code class="notranslate" translate="no">getBoundingClientRect</code></a>
return non-integer values for the size of an element.</p>
</li>
</ol>
<p>To as a concrete example of where this issue comes up we can make a div
with 3 children, each set be the 33% the width of their parent</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;div id="parent"&gt;
  &lt;div id="left"&gt;left&lt;/div&gt;
  &lt;div id="middle"&gt;middle&lt;/div&gt;
  &lt;div id="right"&gt;right&lt;/div&gt;
&lt;/div&gt;
</pre>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">#parent {
  display: flex;
  width: 299px;
  height: 40px;
  align-items: stretch;
  background-color: red;
}
#parent&gt;* {
  flex: 1 1 33%;
}
#left { background-color: #A44; }
#middle { background-color: #4A4; }
#right { background-color: #66C; }
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Ffractional-element-size-issues.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../fractional-element-size-issues.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>On one of my machines, with a default (un-zoomed) browser window, I get these
results</p>
<pre class="fixed-size-text">devicePixelRatio: 2
--------------- #left ---------------
                 inlineSize: 99.65625
                clientWidth: 100
getBoundingClientRect.width: 99.6640625
--------------- #middle ---------------
                 inlineSize: 99.65625
                clientWidth: 100
getBoundingClientRect.width: 99.6640625
--------------- #right ---------------
                 inlineSize: 99.65625
                clientWidth: 100
getBoundingClientRect.width: 99.6640625
--------------- #parent ---------------
                 inlineSize: 299
                clientWidth: 299
getBoundingClientRect.width: 299
</pre>
<p>The #1 thing to notice is <strong>the numbers for all 3 children are exactly the same!!</strong>
But, our parent is 299 css pixels wide. If we multiply that by the devicePixelRatio
of 2 we get 598 actual pixels. We have 3 children. <code class="notranslate" translate="no">598 / 3 = 199.33333333333334</code>
We can‚Äôt have 199.33333333334 actual pixels. If we round to 199 then
199 + 199 + 199 = 597. But our parent is 598. To get to 598, one of those
elements needs an extra pixel but, given the info for all 3 is exactly the same,
which one gets the extra pixel?</p>
<h2 id="devicepixelcontentboxsize"><a id="a-devicepixelcontentboxsize"></a> <code class="notranslate" translate="no">devicePixelContentBoxSize</code></h2>
<p>The solution is that <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> provides the answer. It‚Äôs called
<code class="notranslate" translate="no">devicePixelContentBoxSize</code></p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">const observer = new ResizeObserver(entries =&gt; {
  for (const entry of entries) {
-    const width = entry.contentBoxSize[0].inlineSize;
-    const height = entry.contentBoxSize[0].blockSize;
+    const width = entry.devicePixelContentBoxSize[0].inlineSize;
+    const height = entry.devicePixelContentBoxSize[0].blockSize;
</pre>
<p>If we add that measurement to our example it gives us the actual answer</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Ffractional-element-size-device-pixel-content-box-size.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../fractional-element-size-device-pixel-content-box-size.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>On the machine I used for the results above I get these results</p>
<pre class="fixed-size-text">devicePixelRatio: 2
--------------- #left ---------------
                          inlineSize: 99.65625
devicePixelContentBoxSize.inlineSize: 199    &lt;=====
                         clientWidth: 100
         getBoundingClientRect.width: 99.6640625
--------------- #middle ---------------
                          inlineSize: 99.65625
devicePixelContentBoxSize.inlineSize: 200    &lt;=====
                         clientWidth: 100
         getBoundingClientRect.width: 99.6640625
--------------- #right ---------------
                          inlineSize: 99.65625
devicePixelContentBoxSize.inlineSize: 199    &lt;=====
                         clientWidth: 100
         getBoundingClientRect.width: 99.6640625
--------------- #parent ---------------
                          inlineSize: 299
devicePixelContentBoxSize.inlineSize: 598    &lt;=====
                         clientWidth: 299
         getBoundingClientRect.width: 299
</pre>
<p>As you can see, on my machine the browser gave the center element the extra pixel.
It‚Äôs 200 device pixels wide vs the other 2 elements which are 199 device pixels
wide.</p>
<p>This issue isn‚Äôt limited to this case, it‚Äôs just the easiest way to show
a concrete example of not being able to get this info any other way.
The point being, if you want pixel perfection, you can not just multiply
some other measurement by <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a>. You must use <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>
and <code class="notranslate" translate="no">devicePixelContentBoxSize</code>.</p>
<p>Note: Safari, as of November 2023, does not support <code class="notranslate" translate="no">devicePixelContentBoxSize</code>
nor does Safari change the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> in response to zooming. This means
<strong>It‚Äôs impossible on Safari to display a 1x1 pixel perfect canvas</strong>.</p>
<h2 id="content-box-vs-device-pixel-content-box"><code class="notranslate" translate="no">content-box</code> vs <code class="notranslate" translate="no">device-pixel-content-box</code></h2>
<p>When you call <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver.observe"><code class="notranslate" translate="no">ResizeObserver.observe</code></a> you can tell it to observe the changes
of 1 of 2 box sizes. The default is to observe the <code class="notranslate" translate="no">content-box</code> size.
This is the CSS size of the element.
Above, the elements may never change CSS size. The parent is set to 299px CSS pixels
and regardless of zoom level. The children are set to 33% which is 33% of 299 which
is always 99.666666 (or whatever they compute, see results above).
On the other hand, if the element is the full size of the page then it would change
as you zoom. <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>You can also observe <code class="notranslate" translate="no">device-pixel-content-box</code>. This is the size of the actual
number of device pixels the element takes. This will change when the zoom level
changes <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>. It won‚Äôt change if the size in device pixels of the element
didn‚Äôt actually change. For example if the element is the full size of the page
then zooming doesn‚Äôt change the fact that it‚Äôs still the full size of the page
and therefore still the same number of device pixels.</p>
<p>To tell <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> which size to observe you pass it in when calling
<code class="notranslate" translate="no">observe</code>.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">resizeObserver.observe(someElement1, {box: 'device-pixel-content-box'});
resizeObserver.observe(someElement2, {box: 'content-box'});
</pre>
<p>Unfortunately, again, Safari does not support this and will throw an
exception if you try to pass <code class="notranslate" translate="no">'device-pixel-content-box'</code>.</p>
<h2 id="actual-pixels---solution"><a id="a-actual-pixels"></a> Actual pixels - solution</h2>
<p>As of November 2023 then, the solution to getting the actual number of pixels
is to request both types of boxes above, trap the safari issue, and, if
<code class="notranslate" translate="no">devicePixelContentBoxSize</code> is not available, fallback to <code class="notranslate" translate="no">contentBoxSize</code>.</p>
<p>Here‚Äôs is our boilerplate canvas resizing code updated to support pixel
perfect rendering on all standards compliant browsers <sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const observer = new ResizeObserver(entries =&gt; {
    for (const entry of entries) {
      const width = entry.devicePixelContentBoxSize?.[0].inlineSize ||
                    entry.contentBoxSize[0].inlineSize * devicePixelRatio;
      const height = entry.devicePixelContentBoxSize?.[0].blockSize ||
                     entry.contentBoxSize[0].blockSize * devicePixelRatio;
      const canvas = entry.target;
      canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
      canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
      // re-render
      render();
    }
  });
  try {
    observer.observe(canvas, { box: 'device-pixel-content-box' });
  } catch {
    observer.observe(canvas, { box: 'content-box' });
  }
</pre>
<p>We can test this by drawing a pattern that will show a <a href="https://www.google.com/search?q=moire+effect">moir√© effect</a> if
the rendering is not pixel perfect. We drew a pattern like this in <a href="webgpu-inter-stage-variables.html#a-builtin-position">the article on inter-stage variables</a>.</p>
<p>Replacing the canvas resizing code with the snippet above and changing
the pattern to a magenta, green, white, black checkerboard.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-    let red = vec4f(1, 0, 0, 1);
-    let cyan = vec4f(0, 1, 1, 1);
-    return select(red, cyan, checker);

+    let hv = vec2f(floor(fsInput.position.xy % 2));
+    return vec4f(1, 0, 1, 1) * hv.x +
+           vec4f(0, 1, 0, 1) * hv.y;
  }
</pre>
<p>Let‚Äôs also make the triangle big enough to cover the canvas <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    let pos = array(
-      vec2f( 0.0,  0.5),  // top center
-      vec2f(-0.5, -0.5),  // bottom left
-      vec2f( 0.5, -0.5)   // bottom right
+      vec2f(-1.0,  3.0),
+      vec2f( 3.0, -1.0),
+      vec2f(-1.0, -1.0),
    );
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-resize-pixel-perfect.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-resize-pixel-perfect.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Open it in new window and zoom in or out. You should see a monotone pattern that looks almost like a solid color that doesn‚Äôt change regardless of zoom level
except on Safari where if you zoom you may see <a href="https://www.google.com/search?q=moire+pattern">moir√© patterns</a> showing
that it was impossible to get pixel perfection on Safari.</p>
<blockquote>
<p>Note: If you‚Äôd like to
add your polite voice for Safari to support <code class="notranslate" translate="no">devicePixelContentBox</code> you can
add to the bug report <a href="https://bugs.webkit.org/show_bug.cgi?id=264158">here</a>
as well as the bug about Safari not changing <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a> in response
to zoom <a href="https://bugs.webkit.org/show_bug.cgi?id=124862">here</a>. Bugs are often
worked on by how much attention they get so please add your voice to the bugs.</p>
</blockquote>
<h2 id="do-you-need-to-use-devicepixelratio">Do you need to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a>?</h2>
<p>Drawing to higher resolutions is slower than drawing to lower resolutions.
It‚Äôs not always important to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio"><code class="notranslate" translate="no">devicePixelRatio</code></a>. Even if you do decide
to support it, <a href="https://yesviz.com/viewport/">many phones have device pixel ratios as high as 4</a>. That‚Äôs
a total of 16 pixels for every CSS pixel. Drawing 16x the pixels is literally
up to 16x slower than drawing 1. So maybe you‚Äôd like to consider limiting
how you use devicePixelRatio like <code class="notranslate" translate="no">dpr = Math.min(2, devicePixelRatio)</code>.</p>
<p>Further, given that games often have a poor experience if they are slow, you
might consider letting the user choose a multiplier which is what many native
computer games do in their graphics options settings. Then the user can choose
if they want resolution or speed.</p>
<!-- keep this at the bottom of the article -->
<script type="module" src="webgpu-resizing-the-canvas.js"></script>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Except on Safari ü§¨ <a href="#fnref1" class="footnote-backref">‚Ü©Ô∏é</a> <a href="#fnref1:1" class="footnote-backref">‚Ü©Ô∏é</a> <a href="#fnref1:2" class="footnote-backref">‚Ü©Ô∏é</a></p>
</li>
<li id="fn2" class="footnote-item"><p>See <a href="webgpu-large-triangle-to-cover-clip-space.html">this article</a> for why these vertex positions. <a href="#fnref2" class="footnote-backref">‚Ü©Ô∏é</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-resizing-the-canvas.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-resizing-the-canvas.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-resizing-the-canvas.html">Êó•Êú¨Ë™û
    </option><option value="/webgpu/lessons/ko/webgpu-resizing-the-canvas.html">ÌïúÍµ≠Ïñ¥
    </option><option value="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">–†—É—Å—Å–∫–∏–π
    </option><option value="/webgpu/lessons/uk/webgpu-resizing-the-canvas.html">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞
    </option><option value="/webgpu/lessons/zh_cn/webgpu-resizing-the-canvas.html">ÁÆÄ‰Ωì‰∏≠Êñá
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Resizing the Canvas.`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>