<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-inter-stage-variables.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Passing Data from a Vertex Shader to a Fragment Shader">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_en.jpg">

<meta property="og:title" content="WebGPU Inter-stage Variables">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_en.jpg">
<meta property="og:description" content="Passing Data from a Vertex Shader to a Fragment Shader">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Inter-stage Variables">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html">
<meta name="twitter:description" content="Passing Data from a Vertex Shader to a Fragment Shader">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html",
      "inLanguage":"en",
      "name":"WebGPU Inter-stage Variables",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-inter-stage-variables.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Inter-stage Variables</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Inter-stage Variables</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>In the <a href="webgpu-fundamentals.html">previous article</a>, we covered a few super
basics about WebGPU. In this article we’re going to go over <em>the basics</em> of
inter-stage variables.</p>
<p>Inter-stage variables come into play between a vertex shader and a fragment
shader.</p>
<p>When a vertex shader outputs 3 positions a triangle gets rasterized. The vertex
shader can output extra values at each of those positions and by default, those
values will be interpolated between the 3 points.</p>
<p>Let’s make a small example. We’ll start with the triangle shaders from the
previous article. All we’re going to do is change the shaders.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
-    label: 'our hardcoded red triangle shaders',
+    label: 'our hardcoded rgb triangle shaders',
    code: `
+      struct OurVertexShaderOutput {
+        @builtin(position) position: vec4f,
+        @location(0) color: vec4f,
+      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
+        var color = array&lt;vec4f, 3&gt;(
+          vec4f(1, 0, 0, 1), // red
+          vec4f(0, 1, 0, 1), // green
+          vec4f(0, 0, 1, 1), // blue
+        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
      }

-      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+        return fsInput.color;
      }
    `,
  });
</pre>
<p>First off we declare a <code class="notranslate" translate="no">struct</code>. This is one easy way to coordinate the
inter-stage variables between a vertex shader and a fragment shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>We then declare our vertex shader to return a structure of this type:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
</pre>
<p>Next, we create an array of 3 colors.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        var color = array&lt;vec4f, 3&gt;(
          vec4f(1, 0, 0, 1), // red
          vec4f(0, 1, 0, 1), // green
          vec4f(0, 0, 1, 1), // blue
        );
</pre>
<p>Then, instead of returning just a <code class="notranslate" translate="no">vec4f</code> for position, we declare an instance
of the structure, fill it out, and return it:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
</pre>
<p>In the fragment shader, we declare it to take one of these structs as an argument to
the function:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
        return fsInput.color;
      }
</pre>
<p>Finally returning the color.</p>
<p>If we run that we’ll see, that every time the GPU called our fragment shader, it
passed in a color that was interpolated between all 3 points.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Inter-stage variables are most often used to interpolate texture coordinates
across a triangle which we’ll cover in <a href="webgpu-textures.html">the article on textures</a>.
Another common use is interpolating normals across a triangle which we will cover
in <a href="webgpu-lighting-directional.html">the first article on lighting</a>.</p>
<h2 id="inter-stage-variables-connect-by-location">Inter-stage variables connect by <code class="notranslate" translate="no">location</code></h2>
<p>An important point, like nearly everything in WebGPU, the connection between the
vertex shader and the fragment shader is by index. For inter-stage variables,
they connect by location index.</p>
<p>To see what I mean, let’s change only the fragment shader to take <code class="notranslate" translate="no">vec4f</code> parameter
at <code class="notranslate" translate="no">location(0)</code> instead of the struct:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(@location(0) color: vec4f) -&gt; @location(0) vec4f {
        return color;
      }
</pre>
<p>Running that we see it still works.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle-by-fn-param.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle-by-fn-param.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="builtinposition"><a id="a-builtin-position"></a> <code class="notranslate" translate="no">@builtin(position)</code></h2>
<p>That helps point out another quirk. Our original shader that used the same
struct in both the vertex and fragment shaders had a field called <code class="notranslate" translate="no">position</code> but
it didn’t have a location. Instead, it was declared as <code class="notranslate" translate="no">@builtin(position)</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
*        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>That field is <strong>NOT</strong> an inter-stage variable. Instead, it’s a <code class="notranslate" translate="no">builtin</code>. It
happens that <code class="notranslate" translate="no">@builtin(position)</code> has a different meaning in a vertex shader vs
a fragment shader. In fact a better way to think about is is vertex shaders
and fragment shader are just 2 different functions that happen to have a parameter
with the same name.</p>
<p>Imagine we have 2 JavaScript functions</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Draw a circle size radius, at position: [x, y]
function drawCircle({ ctx, position, radius }) {
  // from CanvasRenderingContext2D
  ctx.beginPath();
  ctx.arc(...position, radius, 0, Math.PI * 2);
  ctx.fill();
}

// Return the index of an element in an array starting at position
function findIndex({ array, position, value }) {
  return array.indexOf(value, position);
}
</pre>
<p>Both of the functions above have a parameter called <code class="notranslate" translate="no">position</code>. There is generally
no confusion between the two. It’s similar with vertex shaders and fragment shaders.
Their builtins are different and unrelated, each of them just happen to have a
<code class="notranslate" translate="no">@builtin</code> named <code class="notranslate" translate="no">position</code> and when compiling each shader entry point, the WGSL
code is read for that entry point alone.</p>
<p>In a vertex shader <code class="notranslate" translate="no">@builtin(position)</code> is the coordinate you provide as output that
the GPU uses to draw triangles/lines/points.</p>
<p>In a fragment shader, <code class="notranslate" translate="no">@builtin(position)</code> is an input. It’s the pixel coordinate
of the pixel that the fragment shader is currently being asked to compute a color
or value for.</p>
<p>Pixel coordinates are specified by the edges of pixels. The values provided to
the fragment shader are the coordinates of the center of the pixel.</p>
<p>If the texture we were drawing to was 3x2 pixels in size, these would be the
coordinates:</p>
<div class="webgpu_center"><img src="resources/webgpu-pixels.svg" style="width: 500px;"></div>
<p>We can change our shader to use this position. For example, let’s draw a
checkerboard.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded checkerboard triangle shaders',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
-        @location(0) color: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
-        var color = array&lt;vec4f, 3&gt;(
-          vec4f(1, 0, 0, 1), // red
-          vec4f(0, 1, 0, 1), // green
-          vec4f(0, 0, 1, 1), // blue
-        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
-        vsOutput.color = color[vertexIndex];
        return vsOutput;
      }

      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-        return fsInput.color;
+        let red = vec4f(1, 0, 0, 1);
+        let cyan = vec4f(0, 1, 1, 1);
+
+        let grid = vec2u(fsInput.position.xy) / 8;
+        let checker = (grid.x + grid.y) % 2 == 1;
+
+        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>The code above takes <code class="notranslate" translate="no">fsInput.position</code>, which was declared as
<code class="notranslate" translate="no">@builtin(position)</code>, and converts its <code class="notranslate" translate="no">xy</code> coordinates to a <code class="notranslate" translate="no">vec2u</code> which is 2
unsigned integers. It then divides them by 8 giving us a count that increases
every 8 pixels. It then adds the <code class="notranslate" translate="no">x</code> and <code class="notranslate" translate="no">y</code> grid coordinates together, computes
modulo 2, and compares the result to 1. This will give us a boolean that is true
or false for every other integer. Finally, it uses the WGSL function <code class="notranslate" translate="no">select</code> which
given 2 values, selects one or the other based on a boolean condition. In
JavaScript <code class="notranslate" translate="no">select</code> would be written like this:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// If condition is false return `a`, otherwise return `b`
select = (a, b, condition) =&gt; condition ? b : a;
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Even if you don’t use <code class="notranslate" translate="no">@builtin(position)</code> in a fragment shader, it’s convenient
that it’s there because it means we can use the same struct for both a vertex
shader and a fragment shader. An important takeaway is that the <code class="notranslate" translate="no">position</code> struct
field in the vertex shader vs the fragment shader is entirely unrelated. They’re
completely different variables.</p>
<p>As pointed out above though, for inter-stage variables, all that matters is the
<code class="notranslate" translate="no">@location(?)</code>. So, it’s not uncommon to declare different structs for a vertex
shader’s output vs a fragment shader’s input.</p>
<p>To hopefully make this more clear, the fact that the vertex shader and
fragment shader are in the same string in our examples is just a convenience.
We could also split them into separate modules:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
-    label: 'hardcoded checkerboard triangle shaders',
+  const vsModule = device.createShaderModule({
+    label: 'hardcoded triangle',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
        return vsOutput;
      }
+    `,
+  });
+
+  const fsModule = device.createShaderModule({
+    label: 'checkerboard',
+    code: `
-      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+      @fragment fn fs(@builtin(position) pixelPosition: vec4f) -&gt; @location(0) vec4f {
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);

-        let grid = vec2u(fsInput.position.xy) / 8;
+        let grid = vec2u(pixelPosition.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;

        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>And we’d have to update our pipeline creation to use these:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded checkerboard triangle pipeline',
    layout: 'auto',
    vertex: {
-      module,
+      module: vsModule,
    },
    fragment: {
-      module,
+      module: fsModule,
      targets: [{ format: presentationFormat }],
    },
  });

</pre>
<p>And this works the same:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position-separate-modules.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position-separate-modules.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>The point is, the fact that both shaders are in the same string in most WebGPU
examples is just a convenience. In reality, first WebGPU parses the WGSL to make
sure it’s syntactically correct. Then, WebGPU looks at each <code class="notranslate" translate="no">entryPoint</code>
you specify, separately. It looks at the parts that each entryPoint references
and nothing else.</p>
<p>Shared strings are useful because multiple shaders can then share things like
structures, binding and group locations, constants, and functions.
But, from the POV of WebGPU, it’s as though you did duplicate
all of them, once for each entryPoint.</p>
<p>Note: It is not that common to generate a checkerboard using the
<code class="notranslate" translate="no">@builtin(position)</code>. Checkerboards or other patterns are far more commonly
implemented <a href="webgpu-textures.html">using textures</a>. In fact, you’ll see an issue
if you size the window. Because the checkerboard is based on the pixel coordinates
of the canvas it’s relative to the canvas, not relative to the triangle.</p>
<h2 id="interpolation-settings"><a id="a-interpolate"></a>Interpolation Settings</h2>
<p>We saw above that inter-stage variables, the outputs from a vertex shader, are
interpolated when passed to the fragment shader. There are 2 sets of settings
that can modify the behavior - interpolation type, and interpolation sampling. Setting them to anything
other than the defaults is not too common, but there are use cases which
will be covered in other articles.</p>
<p>Interpolation type:</p>
<ul>
<li><code class="notranslate" translate="no">perspective</code>: Values are interpolated in a perspective correct manner (<strong>default</strong>)</li>
<li><code class="notranslate" translate="no">linear</code>: Values are interpolated in a linear, non-perspective correct manner</li>
<li><code class="notranslate" translate="no">flat</code>: Values are not interpolated. Interpolation sampling is not used with flat interpolated</li>
</ul>
<p>Interpolation sampling:</p>
<ul>
<li><code class="notranslate" translate="no">center</code>: Interpolation is performed at the center of the pixel. (<strong>default</strong>)</li>
<li><code class="notranslate" translate="no">centroid</code>: Interpolation is performed at a point that lies within all the samples covered by the fragment within the current primitive. This value is the same for all samples in the primitive.</li>
<li><code class="notranslate" translate="no">sample</code>:  Interpolation is performed per sample. The fragment shader is invoked once per sample when this attribute is applied.</li>
<li><code class="notranslate" translate="no">first</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. (default) The value comes from the first vertex of the primitive being drawn</li>
<li><code class="notranslate" translate="no">either</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. The value comes from either the first or the last vertex of the primitive being drawn.</li>
</ul>
<p>You specify these as attributes, for example:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  @location(2) @interpolate(linear, center) myVariableFoo: vec4f;
  @location(3) @interpolate(flat) myVariableBar: vec4f;
</pre>
<p>Note that if the inter-stage variable is an integer type then you must set its
interpolation to <code class="notranslate" translate="no">flat</code>.</p>
<p>If you set the interpolation type to <code class="notranslate" translate="no">flat</code>, by default, the value passed to the fragment shader
is the value of the inter-stage variable for the first vertex in that triangle. For most
<code class="notranslate" translate="no">flat</code> use cases you should pick <code class="notranslate" translate="no">either</code>. We’ll cover why in <a href="webgpu-compatibility-mode.html">another article</a>.</p>
<p>In the <a href="webgpu-uniforms.html">next article we’ll cover uniforms</a> as another way to
pass data into shaders.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-inter-stage-variables.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Post Processing</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Inter-stage Variables`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>