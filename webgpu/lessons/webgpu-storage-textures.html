<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-storage-textures.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to use Storage Textures">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-textures_en.jpg">

<meta property="og:title" content="WebGPU Storage Textures">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-textures_en.jpg">
<meta property="og:description" content="How to use Storage Textures">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Storage Textures">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html">
<meta name="twitter:description" content="How to use Storage Textures">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-textures_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-textures_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html",
      "inLanguage":"en",
      "name":"WebGPU Storage Textures",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-textures.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Storage Textures</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-textures.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-textures.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-textures.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-textures.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-textures.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-storage-textures.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-textures.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Storage Textures</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Storage textures are just <a href="webgpu-textures.html">textures</a> that you can directly write or “store” to.
Normally we specify triangles in a vertex shader and the GPU updates the texture
for us indirectly but with a storage texture we can write directly to the
texture wherever we want.</p>
<p>Storage textures are not a special type of texture, rather, they are just a
texture like any other texture that you create with <code class="notranslate" translate="no">createTexture</code>. You add the
<code class="notranslate" translate="no">STORAGE_BINDING</code> usage flag and now you can use the texture as a storage
texture on top of whatever other usage flags you need and then you can also use
the texture as a storage texture.</p>
<p>In sense, a storage texture is like a storage buffer that we use as a 2d array. For example we
could make a storage buffer and reference it in code like this</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0)
  var&lt;storage&gt; buf: array&lt;f32&gt;;

...
fn loadValueFromBuffer(pos: vec2u) -&gt; f32 {
  return buffer[pos.y * width + pos.x];
}

fn storeValueToBuffer(pos: vec2u, v: f32) {
  buffer[pos.y * width + pos.x] = v;
}

...
  let pos = vec2u(2, 3);
  var v = loadValueFromBuffer(pos);
  storeValueToBuffer(pos, v * 2.0);

</pre>
<p>vs a storage texture</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">@group(0) @binding(0)
  var tex: texture_storage_2d&lt;r32float, read_write&gt;;

...

   let pos = vec2u(2, 3);
   let mipLevel = 0;
   var v = textureLoad(tex, pos, mipLevel);
   textureStore(tex, pos, mipLevel, v * 2);

</pre>
<p>So given that those seem equivalent, what are the differences between manually
using a storage buffer and a storage texture?</p>
<ul>
<li>
<p>A storage texture is still a texture.</p>
<p>You can use it with one shader as a storage texture and as regular texture
(with samplers, and mip-mapping, etc) in another shader.</p>
</li>
<li>
<p>A storage texture has format interpretation, a storage buffer does not.</p>
<p>Example:</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">@group(0) @binding(0) var tex: texture_storage_2d&lt;rgba8unorm, read&gt;;
@group(0) @binding(1) var buf: array&lt;f32&gt;;

   ...
    let t = textureLoad(tex, pos, 0);
    let b = buffer[pos.y * bufferWidth + pos.x];
</pre>
<p>Above, when we call <code class="notranslate" translate="no">textureLoad</code>, the texture is an <code class="notranslate" translate="no">rgba8unorm</code> texture
which means 4 bytes are loaded and automatically converted to 4 floating
point values between 0 and 1 and returned as a <code class="notranslate" translate="no">vec4f</code>.</p>
<p>In the buffer case, 4 bytes are loaded as a single <code class="notranslate" translate="no">f32</code> value. We could
change buffer to <code class="notranslate" translate="no">array&lt;u32&gt;</code> and then load a value, and manually split it into
4 byte values, and convert those to floats ourselves but, if that’s what we
wanted we get it for free with a storage texture.</p>
</li>
<li>
<p>A storage texture has dimensions</p>
<p>For a buffer, the only dimension is its length, or rather, the length of
its binding <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Above, when we used a buffer as a 2D array, we
needed <code class="notranslate" translate="no">width</code> to convert from a 2d coordinate to a 1d buffer index.
We’d have to either hard code the value for <code class="notranslate" translate="no">width</code> or pass it in
some how<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. With a texture we can call <code class="notranslate" translate="no">textureDimensions</code>
to get the texture’s dimensions.</p>
</li>
</ul>
<p>That said, there are limits on storage textures.</p>
<ul>
<li>
<p>Only certain formats can be <code class="notranslate" translate="no">read_write</code>.</p>
<p>Those are <code class="notranslate" translate="no">r32float</code>, <code class="notranslate" translate="no">r32sint</code>, and <code class="notranslate" translate="no">r32uint</code>.</p>
<p>Other supported formats can only be <code class="notranslate" translate="no">read</code> or <code class="notranslate" translate="no">write</code> within a single
shader.</p>
</li>
<li>
<p>Only certain formats can be used as storage textures.</p>
<p>There are a large number of texture formats but only certain ones
can be usage as storage textures.</p>
<ul>
<li><code class="notranslate" translate="no">rgba8(unorm/snorm/sint/uint)</code></li>
<li><code class="notranslate" translate="no">rgba16(float/sint/uint)</code></li>
<li><code class="notranslate" translate="no">rg32(float/sint/uint)</code></li>
<li><code class="notranslate" translate="no">rgba32(float/sint/uint)</code></li>
</ul>
<p>One format to notice missing is <code class="notranslate" translate="no">bgra8unorm</code> which we’ll cover below.</p>
</li>
<li>
<p>Storage textures can not use samplers</p>
<p>If we use a texture as normal <code class="notranslate" translate="no">TEXTURE_BINDING</code> then we can call
functions like <code class="notranslate" translate="no">textureSample</code> which load up to 16 texels across mip levels and
blend them together. When we use a texture as a <code class="notranslate" translate="no">STORAGE_BINDING</code>
we can only call <code class="notranslate" translate="no">textureLoad</code> and/or <code class="notranslate" translate="no">textureStore</code> which load
and store a single texel at a time.</p>
</li>
</ul>
<h2 id="canvas-as-a-storage-texture">Canvas as a Storage Texture</h2>
<p>You can use a canvas texture as a storage texture. To do so, you configure
the context to give you a texture that can be used as a storage texture.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const presentationFormat = navigator.gpu.getPreferredCanvasFormat()
  context.configure({
    device,
    format: presentationFormat,
+    usage: GPUTextureUsage.TEXTURE_BINDING |
+           GPUTextureUsage.STORAGE_BINDING,
  });
</pre>
<p><code class="notranslate" translate="no">TEXTURE_BINDING</code> is needed so the browser itself can render the texture
to the page. <code class="notranslate" translate="no">STORAGE_BINDING</code> lets us use the canvas’s textures as
storage textures. If we still wanted to render to the texture via a
render pass, like most examples on this site, we’d also add the
<code class="notranslate" translate="no">RENDER_ATTACHMENT</code> usage.</p>
<p>There’s a complication here though.  As we covered in
<a href="webgpu-fundamentals.html">the first article</a>, normally we call
<code class="notranslate" translate="no">navigator.gpu.getPreferredCanvasFormat</code> to get the preferred canvas format.
<code class="notranslate" translate="no">getPreferredCanvasFormat</code> will return either <code class="notranslate" translate="no">rgba8unorm</code> or <code class="notranslate" translate="no">bgra8unorm</code>
depending on whichever format is more performant for the user’s system.</p>
<p>But, as mentioned above, by default, we can not use a <code class="notranslate" translate="no">bgra8unorm</code>
texture as a storage texture.</p>
<p>Fortunately there is a <a href="webgpu-limits-and-features.html">feature</a> called
<code class="notranslate" translate="no">'bgra8unorm-storage'</code>. Enabling that feature will allow a <code class="notranslate" translate="no">bgra8unorm</code> texture as a storage texture.
In general, it <em>should</em> be available on any platform that reports
<code class="notranslate" translate="no">bgra8unorm</code> as its preferred canvas format but, there is some possibility
it’s not available. So, we need to check if the <code class="notranslate" translate="no">'bgra8unorm-storage'</code>
<em>feature</em> exists. If it exists, we’ll require it for our device and we’ll use
the preferred canvas format. If not, we’ll choose <code class="notranslate" translate="no">rgba8unorm</code> as our
canvas format.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const adapter = await navigator.gpu?.requestAdapter();
-  const device = await adapter?.requestDevice();
+  const hasBGRA8unormStorage = adapter.features.has('bgra8unorm-storage');
+  const device = await adapter?.requestDevice({
+    requiredFeatures: hasBGRA8unormStorage
+      ? ['bgra8unorm-storage']
+      : [],
+  });
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }

  // Get a WebGPU context from the canvas and configure it
  const canvas = document.querySelector('canvas');
  const context = canvas.getContext('webgpu');
-  const presentationFormat = navigator.gpu.getPreferredCanvasFormat()
+  const presentationFormat = hasBGRA8unormStorage
+     ? navigator.gpu.getPreferredCanvasFormat()
+     : 'rgba8unorm';
  context.configure({
    device,
    format: presentationFormat,
    usage: GPUTextureUsage.TEXTURE_BINDING |
           GPUTextureUsage.STORAGE_BINDING,
  });
</pre>
<p>Now we can use the canvas texture as a storage texture. Let’s make a simple
compute shader to draw concentric circles in the texture.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'circles in storage texture',
    code: `
      @group(0) @binding(0)
      var tex: texture_storage_2d&lt;${presentationFormat}, write&gt;;

      @compute @workgroup_size(1) fn cs(
        @builtin(global_invocation_id) id : vec3u
      )  {
        let size = textureDimensions(tex);
        let center = vec2f(size) / 2.0;

        // the pixel we're going to write to
        let pos = id.xy;

        // The distance from the center of the texture
        let dist = distance(vec2f(pos), center);

        // Compute stripes based on the distance
        let stripe = dist / 32.0 % 2.0;
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);
        let color = select(red, cyan, stripe &lt; 1.0);

        // Write the color to the texture
        textureStore(tex, pos, color);
      }
    `,
  });
</pre>
<p>Notice we marked the storage texture as <code class="notranslate" translate="no">write</code> and that we had to specify
the specific texture format in the shader itself. Unlike <code class="notranslate" translate="no">TEXTURE_BINDING</code>s,
<code class="notranslate" translate="no">STORAGE_BINDING</code>s need to know the exact format of the texture.</p>
<p>Setting it up is similar to <a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">the compute shader we wrote in the first article</a>.
After making a shader module we setup a compute pipeline to use it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createComputePipeline({
    label: 'circles in storage texture',
    layout: 'auto',
    compute: {
      module,
    },
  });
</pre>
<p>To render we get the canvas’s current texture, make a bind group so
we can pass the texture to the shader, and then do the normal things of setting
a pipeline, binding bind groups, and dispatching workgroups.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    const texture = context.getCurrentTexture();

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: texture.createView() },
      ],
    });

    const encoder = device.createCommandEncoder({ label: 'our encoder' });
    const pass = encoder.beginComputePass();
    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.dispatchWorkgroups(texture.width, texture.height);
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }
</pre>
<p>And here it is</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-storage-texture-canvas.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-storage-texture-canvas.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Using a regular texture would change nothing except we’d call
<code class="notranslate" translate="no">createTexture</code> instead of <code class="notranslate" translate="no">getCurrentTexture</code> to make our texture
and pass in <code class="notranslate" translate="no">STORAGE_BINDING</code> along with whatever other usage flags
we need.</p>
<h2 id="speed-and-data-races">Speed and data races.</h2>
<p>Above, we dispatched 1 workgroup per pixel. This is wasteful, and the
GPU can run much faster. Optimizing the shader for the optimal amount
of work would have complicated the example. The point was to demonstrate
using a storage texture, not the fastest possible shader.
You can read up on some methods of optimizing
compute shaders in <a href="webgpu-compute-shaders-histogram.html">the article on computing an image histogram</a>.</p>
<p>Similarly, because you can write anywhere in the storage texture, you
need to be aware of race conditions like we covered in
<a href="webgpu-compute-shaders.html">the other articles on compute shaders</a>.
The order the invocations run is not guaranteed. It’s
up to you to avoid races and/or insert <code class="notranslate" translate="no">textureBarriers</code> or other things
to make sure 2 or more invocations do not step on each other’s toes.</p>
<h2 id="examples">Examples</h2>
<p><a href="https://compute.toys">compute.toys</a> is a website with lots of examples
of writing directly to a storage texture. <strong>WARNING</strong>: While there
are many things to learn from the examples on <a href="https://compute.toys">compute.toys</a>
they are not necessarily best practice. Compute toys is about making
interesting things with only compute shaders. It’s a fun puzzle to figure
out how to do something creative with only compute shaders but be aware,
other methods <em>might</em> be 10s, 100s, or 1000s of times faster.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>When you create a bind group and you specify a buffer you can
optionally specify an offset and length. In the shader, the length of the
array is calculated from the length of the binding, not the length of
the buffer. If you don’t specify an offset it defaults to 0 and the
length defaults to the size of the entire buffer. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>You could pass in the buffer width via a <a href="webgpu-uniforms.html">uniform</a>,
another <a href="webgpu-storage-buffers.html">storage buffer</a> or even as
the first value in the same buffer. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-textures.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-textures.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-textures.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-textures.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-textures.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-storage-textures.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-textures.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Storage Textures`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>