<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ru/webgpu-storage-buffers.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ru"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Отправка больших данных в шейдеры">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ru.jpg">

<meta property="og:title" content="WebGPU storage буферы">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ru.jpg">
<meta property="og:description" content="Отправка больших данных в шейдеры">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU storage буферы">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html">
<meta name="twitter:description" content="Отправка больших данных в шейдеры">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-storage-buffers_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html",
      "inLanguage":"ru",
      "name":"WebGPU storage буферы",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-storage-buffers.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU storage буферы</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-buffers.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-buffers.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-buffers.html" selected="">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-storage-buffers.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-storage-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-buffers.html">简体中文
</option></select>


    <a href="#toc">оглавление</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ru/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU storage буферы</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья о storage буферах и продолжение <a href="webgpu-uniforms.html">предыдущей статьи</a>.</p>
<p>Storage буферы во многом похожи на uniform буферы.
Если мы просто поменяем <code class="notranslate" translate="no">UNIFORM</code> на <code class="notranslate" translate="no">STORAGE</code> в JavaScript
и <code class="notranslate" translate="no">var&lt;uniform&gt;</code> на <code class="notranslate" translate="no">var&lt;storage, read&gt;</code> в WGSL, то примеры из предыдущих статей будут работать.</p>
<p>Фактический, это и есть разница. Без переименования переменных имеем более соответствующие имена.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    const staticUniformBuffer = device.createBuffer({
      label: `static uniforms for obj: ${i}`,
      size: staticUniformBufferSize,
-      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });


...

    const uniformBuffer = device.createBuffer({
      label: `changing uniforms for obj: ${i}`,
      size: uniformBufferSize,
-      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
</pre>
<p>И в WSGL</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">-@group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
-@group(0) @binding(1) var&lt;uniform&gt; otherStruct: OtherStruct;
+@group(0) @binding(0) var&lt;storage, read&gt; ourStruct: OurStruct;
+@group(0) @binding(1) var&lt;storage, read&gt; otherStruct: OtherStruct;
</pre>
<p>И без других изменений это работает как раньше.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-storage-split-minimal-changes.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-storage-split-minimal-changes.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<h2 id="разница-между-uniform-буферами-и-storage-буферами">Разница между uniform буферами и storage буферами</h2>
<p>Главное отличие между ними это:</p>
<ol>
<li>
<p>Uniform буферы работают быстрее в типичных для них целях</p>
<p>Это и правда очень зависит от случая. Обычному приложение нужно отрисовывать множество разных вещей.
Например это трехмерная игра. Приложение может отрисовывать
машины, дома, камни, кусты, людей и многое другое… Для каждого
будет требоваться хранение в осях координат и свойства материалов, которые
зависят что нужно в нашем примере. В этом случае, использование uniform буфера является хорошим решением.</p>
</li>
<li>
<p>Storage буферы могут быть намного больше, чем uniform буферы.</p>
<ul>
<li>Минимальный и максимальный размер uniform буфера равен 64 килобайт.</li>
<li>Минимальный и максимальный размер storage буфера равен 128 мегабайтам.</li>
</ul>
<p>С помощью минимума и максимума, где максимальный размер буфера определенного типа может быть таким.
Для uniform буферов максимальный размер не больше 64 килобайтов.
Для storage буферов максимальный размер не больше 128 мегабайтам. Мы изучим лимиты в <a href="webgpu-limits-and-features.html">другой статье</a>.</p>
</li>
<li>
<p>Storage буферы могут быть прочтены/записаны, а Uniform буферы только для чтения.</p>
<p>Мы можем увидеть пример написания storage буфера в compute shader’e <a href="webgpu-fundamentals.html">в первой статье</a>.</p>
</li>
</ol>
<h2 id="создание-storage-буферов"><a id="a-instancing"></a>Создание storage буферов</h2>
<p>Отталкиваясь от двух пунктов выше, давайте возьмем наш последний пример и поменяем отрисовку всех ста треугольников в один вызов отрисовки.
Это пример, где <em>может</em> использоваться storage буферы. Я сказал может, потому что, повторюсь, WebGPU похож
на другие языки программирования. Есть много путей сделать одну и туже вещь.
<code class="notranslate" translate="no">array.forEach</code> против <code class="notranslate" translate="no">for (const elem of array)</code> против <code class="notranslate" translate="no">for (let i = 0; i &lt; array.length; ++i)</code>. Все это работает. Разнообразие вариантов решение - это правда об WebGPU. Каждая вещь, которую мы пытаемся сделать имеет множество путей решения.
Когда мы хотим отрисовать треугольник,
Все о чем волнуется WebGPU - это возврат значения для <code class="notranslate" translate="no">builtin(position)</code> из
vertex шейдера и возврат цвета/значения для <code class="notranslate" translate="no">location(0)</code> из fragment шейдера.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>Первая вещь, которую мы сделаем - это поменяем наш код нашего хранилище на runtime-sized массивы (от переводчика: изменяемые при работе приложения).</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-@group(0) @binding(0) var&lt;storage, read&gt; ourStruct: OurStruct;
-@group(0) @binding(1) var&lt;storage, read&gt; otherStruct: OtherStruct;
+@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
+@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
</pre>
<p>Далее мы изменяем шейдер для использования этих значений.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
+  @builtin(instance_index) instanceIndex: u32
) -&gt; @builtin(position) {
  let pos = array(
    vec2f( 0.0,  0.5),  // top center
    vec2f(-0.5, -0.5),  // bottom left
    vec2f( 0.5, -0.5)   // bottom right
  );

+  let otherStruct = otherStructs[instanceIndex];
+  let ourStruct = ourStructs[instanceIndex];

   return vec4f(
     pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
}
</pre>
<p>Мы добавляем новый параметр для нашего vertex шейдера вызывая
<code class="notranslate" translate="no">instanceIndex</code> и давая ему <code class="notranslate" translate="no">@builtin(instance_index)</code> атрибут
именя которых означают получение значения из WebGPU для каждого “созданного” ( в оригинале instance ) отрисованного обьекта.
Когда мы вызываем <code class="notranslate" translate="no">draw</code> мы можем прокинуть второй аргумент для <em>числа созданных обьектов</em>
И для каждого созданного отрисованного обьекта число созданных обьектов будет изменяться и переноситься в нашу функцию.</p>
<p>Использование <code class="notranslate" translate="no">instanceIndex</code> мы можем получить уникальные элементы структуры из нашего массива структур.</p>
<p>Нам также нужно получить цвет из правильного массива элементов и использовать это для нашего fragment shader’a.
Fragment shader не имеет доступа к
<code class="notranslate" translate="no">@builtin(instance_index)</code>, потому что это не имеет смысла. Мы должны прокинуть его как <a href="webgpu-inter-stage-variables.html">inter-stage переменную</a>
Но это будет более привычный способ поиска цвет в vertex shader’e и просто получить цвет.</p>
<p>Чтобы сделать это мы должны использовать другую структуры, похожую на ту, которую мы делали в
<a href="webgpu-inter-stage-variables.html">статье об inter-stage переменных</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">+struct VSOutput {
+  @builtin(position) position: vec4f,
+  @location(0) color: vec4f,
+}

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
  @builtin(instance_index) instanceIndex: u32
-) -&gt; @builtin(position) vec4f {
+) -&gt; VSOutput {
  let pos = array(
    vec2f( 0.0,  0.5),  // top center
    vec2f(-0.5, -0.5),  // bottom left
    vec2f( 0.5, -0.5)   // bottom right
  );

  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

-  return vec4f(
-    pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+  var vsOut: VSOutput;
+  vsOut.position = vec4f(
+      pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+  vsOut.color = ourStruct.color;
+  return vsOut;
}

-@fragment fn fs() -&gt; @location(0) vec4f {
-  return ourStruct.color;
+@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
+  return vsOut.color;
}

</pre>
<p>Теперь мы обновили наш WGSL шейдер и давайте изменим JavaScript код.</p>
<p>Здесь настройка.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kNumObjects = 100;
  const objectInfos = [];

  // Создает два storage буфера
  const staticUnitSize =
    4 * 4 + // Цвет - это 4 32-битных числа с плавающей запятой (4 байта каждое)
    2 * 4 + // Смещение - это 2 32-битных числа с плавающей запятой (4 байта каждое)
    2 * 4;  // padding
  const changingUnitSize =
    2 * 4;  // Размер - это 2 32-битных числа с плавающей запятой (4 байта каждое)
  const staticStorageBufferSize = staticUnitSize * kNumObjects;
  const changingStorageBufferSize = changingUnitSize * kNumObjects;

  const staticStorageBuffer = device.createBuffer({
    label: 'static storage for objects',
    size: staticStorageBufferSize,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  const changingStorageBuffer = device.createBuffer({
    label: 'changing storage for objects',
    size: changingStorageBufferSize,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  // Смещения для разных uniform значений в float32 индексах
  const kColorOffset = 0;
  const kOffsetOffset = 4;

  const kScaleOffset = 0;

  {
    const staticStorageValues = new Float32Array(staticStorageBufferSize / 4);
    for (let i = 0; i &lt; kNumObjects; ++i) {
      const staticOffset = i * (staticUnitSize / 4);

      // Здесь установка происходит только один раз, поэтому давайте сделаем это сейчас
      staticStorageValues.set([rand(), rand(), rand(), 1], staticOffset + kColorOffset);        // Устанавливаем цвет
      staticStorageValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], staticOffset + kOffsetOffset);      // Устанавливаем смещение

      objectInfos.push({
        scale: rand(0.2, 0.5),
      });
    }
    device.queue.writeBuffer(staticStorageBuffer, 0, staticStorageValues);
  }

  // Мы можем использовать строго-типизированный массив для обновления changingStorageBuffer
  const storageValues = new Float32Array(changingStorageBufferSize / 4);

  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: staticStorageBuffer},
      { binding: 1, resource: changingStorageBuffer},
    ],
  });
</pre>
<p>Выше мы создаем два storage буфера. Один для массива, состоящего из <code class="notranslate" translate="no">OurStruct</code>.
А другие используется для массива, состоящего из <code class="notranslate" translate="no">OtherStruct</code>.</p>
<p>We then fill out the values for the array of <code class="notranslate" translate="no">OurStruct</code> with offsets
and colors and then upload that data to the <code class="notranslate" translate="no">staticStorageBuffer</code>.</p>
<p>We make just one bind group that references both buffers.</p>
<p>The new rendering code is</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // Get the current texture from the canvas context and
    // set it as the texture to render to.
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

    // Set the uniform values in our JavaScript side Float32Array
    const aspect = canvas.width / canvas.height;

-    for (const {scale, bindGroup, uniformBuffer, uniformValues} of objectInfos) {
-      uniformValues.set([scale / aspect, scale], kScaleOffset); // set the scale
-      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
-
-      pass.setBindGroup(0, bindGroup);
-      pass.draw(3);  // call our vertex shader 3 times
-    }

+    // set the scales for each object
+    objectInfos.forEach(({scale}, ndx) =&gt; {
+      const offset = ndx * (changingUnitSize / 4);
+      storageValues.set([scale / aspect, scale], offset + kScaleOffset); // set the scale
+    });
+    // upload all scales at once
+    device.queue.writeBuffer(changingStorageBuffer, 0, storageValues);
+
+    pass.setBindGroup(0, bindGroup);
+    pass.draw(3, kNumObjects);  // call our vertex shader 3 times for each instance


    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }
</pre>
<p>Код выше отрисовывает <code class="notranslate" translate="no">kNumObjects</code> созданных обьектов. Для каждого созданного обьекта
WebGPU будет вызывать vertex shader 3 раза с <code class="notranslate" translate="no">vertex_index</code> установленным на 0, 1, 2
и <code class="notranslate" translate="no">instance_index</code> установленным на 0 ~ kNumObjects - 1</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-storage-buffer-split.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-storage-buffer-split.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Нам нужно отрисовать все 100 треугольников, каждый с разными размером, цветом и смещение в одном вызове отрисовке. Для ситуаций, где вы хотите отрисовать много разных обьектов имеется один из способов сделать это.</p>
<h2 id="использование-storage-буферов-для-данных-вершин">Использование storage буферов для данных вершин</h2>
<p>До этого момента мы использовали данные треугольника прямиком из шейдера.
Один из вариантов, где можно использовать storage буферы - это хранение данных вершин. Как мы храним индесы в нашем storage буферах
с помощью <code class="notranslate" translate="no">instance_index</code> в примере выше, а сейчас будем хранить индекс в другом storage буфере с помощью <code class="notranslate" translate="no">vertex_index</code>, чтобы получить данные вершин.</p>
<p>Приступим!</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  offset: vec2f,
};

struct OtherStruct {
  scale: vec2f,
};

+struct Vertex {
+  position: vec2f,
+};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
+@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;

@vertex fn vs(
  @builtin(vertex_index) vertexIndex : u32,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
-  let pos = array(
-    vec2f( 0.0,  0.5),  // top center
-    vec2f(-0.5, -0.5),  // bottom left
-    vec2f( 0.5, -0.5)   // bottom right
-  );

  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
-      pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+      pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
  vsOut.color = ourStruct.color;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color;
}
</pre>
<p>Теперь нам нужно установить еще один storage буфер с несколькими вершинами.
Сначала, давайте сделаем функцию для генерации данных вершин. Например круга.
<a id="a-create-circle"></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // 2 треугольника на кусочек, 3 вершины для треугольника, 2 значения (xy) везде.
  const numVertices = numSubdivisions * 3 * 2;
  const vertexData = new Float32Array(numSubdivisions * 2 * 3 * 2);

  let offset = 0;
  const addVertex = (x, y) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
  };

  // 2 треугольника на кусочек
  //
  // 0--1 4
  // | / /|
  // |/ / |
  // 2 3--5
  for (let i = 0; i &lt; numSubdivisions; ++i) {
    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;

    const c1 = Math.cos(angle1);
    const s1 = Math.sin(angle1);
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);

    // Первый треугольник
    addVertex(c1 * radius, s1 * radius);
    addVertex(c2 * radius, s2 * radius);
    addVertex(c1 * innerRadius, s1 * innerRadius);

    // Второй треугольник
    addVertex(c1 * innerRadius, s1 * innerRadius);
    addVertex(c2 * radius, s2 * radius);
    addVertex(c2 * innerRadius, s2 * innerRadius);
  }

  return {
    vertexData,
    numVertices,
  };
}
</pre>
<p>Код выше сделает круг из треугольник.</p>
<div class="webgpu_center"><div class="center"><div data-diagram="circle" style="width: 300px;"></div></div></div>
<p>Так мы сможем сделать это, чтобы заполнить наш storage буфер вершинами нашего круга.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Устанавливаем storage буфер для данных вершин
  const { vertexData, numVertices } = createCircleVertices({
    radius: 0.5,
    innerRadius: 0.25,
  });
  const vertexStorageBuffer = device.createBuffer({
    label: 'storage buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexStorageBuffer, 0, vertexData);
</pre>
<p>И далее нужно добавить это в bind group.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: staticStorageBuffer},
      { binding: 1, resource: changingStorageBuffer},
+      { binding: 2, resource: vertexStorageBuffer},
    ],
  });
</pre>
<p>И во время отрисовки нужно запрашивать все вершины из круга.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    pass.draw(3, kNumObjects);  // Вызывает vertex shader 3 раза для созданных обьектов
+    pass.draw(numVertices, kNumObjects);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-storage-buffer-vertices.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-storage-buffer-vertices.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Выше мы использовали</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">struct Vertex {
  pos: vec2f;
};

@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;
</pre>
<p>Мы можем хранить не структуру, а просто тип <code class="notranslate" translate="no">vec2f</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;
+@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;vec2f&gt;;
...
-pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
</pre>
<p>Но есть одно НО. Не будет ли проще с помощью структуры добавлять данные об вершине позже?</p>
<p>Прокидывание вершин в storage буферах становится все более популярным решением.
Я могу сказать, что на некоторых старых устройствах этот способ работает медленнее, чем более <em>классический</em> метод,
который мы изучим в следующий статье об <a href="webgpu-vertex-buffers.html">буфере вершин</a>.</p>
<!-- keep this at the bottom of the article ( Alice: Deal! ) -->
<script type="module" src=".././webgpu-storage-buffers.js"></script>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Мы можем иметь множество цветов и нам нужно вернуть следующие цвета/значения в <code class="notranslate" translate="no">location(1)</code>, <code class="notranslate" translate="no">location(2)</code> и многое другое… <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-storage-buffers.html">English
    </option><option value="/webgpu/lessons/es/webgpu-storage-buffers.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-storage-buffers.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-storage-buffers.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-storage-buffers.html" selected="">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-storage-buffers.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-storage-buffers.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-storage-buffers.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-fundamentals.html">Основы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Inter-stage Переменные</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-buffers.html">Storage буферы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ru/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-post-processing.html">Basic CRT Effect</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Изучение WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Документация</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Доп.</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Доп.</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Нашли ошибку? <a href="https://github.com/webgpu/webgpufundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU storage буферы`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>