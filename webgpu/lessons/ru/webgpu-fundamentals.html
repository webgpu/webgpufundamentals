<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ru/webgpu-fundamentals.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ru"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Основы WebGPU">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_ru.jpg">

<meta property="og:title" content="WebGPU Основы">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_ru.jpg">
<meta property="og:description" content="Основы WebGPU">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Основы">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html">
<meta name="twitter:description" content="Основы WebGPU">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html",
      "inLanguage":"ru",
      "name":"WebGPU Основы",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Основы</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-fundamentals.html">English
    </option><option value="/webgpu/lessons/es/webgpu-fundamentals.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-fundamentals.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-fundamentals.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-fundamentals.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-fundamentals.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-fundamentals.html">简体中文
</option></select>


    <a href="#toc">оглавление</a>
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ru/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Основы</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья обучит вас основам WebGPU.</p>
<div class="warn">
Рекомендую читателю ознакомится с JavaScript перед
прочтением этой статьи. Концепции вроде
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">mapping arrays</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring assignment</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">spreading values</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">es6 modules</a>,
и иногие другие концепции будут часто использоваться. Если вы ещё не знаете с JavaScript, и хотите изучить, посмотрите
<a href="https://javascript.info/">JavaScript.info</a>, <a href="https://eloquentjavascript.net/">Eloquent JavaScript</a>,
и/или <a href="https://www.codecademy.com/learn/introduction-to-javascript">CodeCademy</a>.
</div>
<div class="warn">Если вы уже знакомы с WebGL <a href="webgpu-from-webgl.html">читайте это</a>.</div>
<p>WebGPU это API которая позволяет делать 2 базовые вещи:</p>
<ol>
<li>
<p><a href="#a-drawing-triangles-to-textures">Рисовать треугольники/точки/линии на текстурах</a></p>
</li>
<li>
<p><a href="#a-run-computations-on-the-gpu">Запускать вычисления на графическом процессоре (GPU)</a></p>
</li>
</ol>
<p>Вот и все!</p>
<p>Все остальное об WebGPU после этого зависит от вас. Это как учить язык программирования
типа JavaScript, Rust или C++. Сначала вы изучаете самые основы и после лишь от вас зависит,
насколько творчески вы будете использовать эти знания для решения ваших задач.</p>
<p>WebGPU - это крайне низкоуровневое (low-level) API. Пока что вы можете делаете простые задачи, это не проблема,
но для множества приложений, скорее всего, потребуется большое количество кода и серьёзная
организация данных. Например, <a href="https://threejs.org">three.js</a>,
поддерживающий WebGPU, содержит около 600 тысяч строк минифицированного кода на JavaScript и это просто
базовая библиотека, которая не включает в себя загрузчики (loaders), элементы управления (controls), пост-процессинг (post-processing) и
многих других фишек. Аналогично, <a href="https://github.com/tensorflow/tfjs/tree/master/tfjs-backend-webgpu">TensorFlow с WebGPU backend (поддержкой)</a>
содержит около полумиллиона минифицированных строчек кода на JavaScript.</p>
<p>Но дело в том, что если вы хотите просто отрисовать что-нибудь на экране,
лучше выбрать библиотеку с большим количеством кода,
который в противном случае придётся писать самостоятельно.</p>
<p>С другой стороны, у вас может быть необычный (неподдерживаемый библиотекой) случай, или может вы хотите изменить
уже существующую библиотеку, или вам просто интересно, как оно работает. В таком случае -
бегом читать!</p>
<h1 id="приступая-к-работе">Приступая к работе</h1>
<p>Сложно точно сказать, с чего нужно начинать. На определённом уровне, WebGPU - это очень простая
система. Все, что WebGPU делает - запускает три типа функций вашейна графическом процессоре. Вершинные (vertex),
фрагментные (fragment) и вычислительные (compute) шейдеры (shaders).</p>
<p>Вершинный шейдер расчитывает вершины. Этот шейдер возвращает позиции вершин. Для каждой группы из трех вершин,
возвращенных шейдером, между этими тремя позициями отрисовывается треугольник. <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>Фрагментный шейдер расчитывает цвета <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Когда треугольник отрисован для каждого пикселя
графический процессор вызовет фрагментный шейдер. Шейдер возвращает цвет.</p>
<p>Вычислительный шейдер является более универсальным. Это просто функция, которую вы вызываете и
говорите: “вызови эту функцию N раз”. Графический процессор передаёт номер итерации каждый
раз, когда вызывает вашу функцию, так что вы можете использовать этот номер, чтобы сделать что-либо уникальное
на каждой итерации.</p>
<p>Если вы прищурились, то можете подумать об этом как о функциях,
передаваемых в
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code class="notranslate" translate="no">array.forEach</code></a>
или
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code class="notranslate" translate="no">array.map</code></a>.
Когда вы вызываете функцию на графическом процессоре - это те же самые функции как, например, в JavaScript.
Отличие в том, что они запускаются на графическом процессоре, поэтому, чтобы запустить их, вам
нужно скопировать на графический процессор все нужные им данные в виде
буферов и текстур, а ещё эти функции могут писать только в буферы и текстуры.
В функциях вам нужно указать привязки (bindings) и слоты (locations),
откуда брать данные. А в JavaScript, вам нужно привязать буферы и
текстуры к привязкам или слотам. Как только вы это сделаете, вы можете запустить
нужную функцию на графическом процессоре.</p>
<p><a id="a-draw-diagram"></a>Возможно, это поможет понять. Здесь <em>упрощенная</em> диаграмма о работе WebGPU для отрисовки треугольников
с помощью вершинных и фрагментных шейдеров</p>
<div class="webgpu_center"><img src="../resources/webgpu-draw-diagram.svg" style="width: 960px;"></div>
<p>Обратите внимание на:</p>
<ul>
<li>
<p><strong>Конвейер</strong> (pipeline). Содержит вершинный и фрагментный шейдеры, которые
будут запускаться на графическом процессоре. Также можно создать pipeline с вычислительным шейдером.</p>
</li>
<li>
<p>Ссылки на ресурсы для шейдеров (буферы, текстуры, семплеры) - неявно
через <strong>Bind Groups</strong>.</p>
</li>
<li>
<p>Pipeline определяет атрибуты, косвенно ссылающиеся на буферы через
внутреннее состояние.</p>
</li>
<li>
<p>Атрибуты вытаскивают данные из буферов и передают их в вершинный шейдер.</p>
</li>
<li>
<p>Вершинный шейдер может передавать данные в фрагментный шейдер.</p>
</li>
<li>
<p>Фрагментный шейдер неявно записывает данные в текстуры через описание прохода рендера
(render pass description).</p>
</li>
</ul>
<p>Чтобы запустить шейдеры на графическом процессоре, вам нужно создать все ресурсы и
выставить состояние (state). Создание ресурсов - относительно простой процесс. Одна
интересная фишка WebGPU заключается в том, что большинство ресурсов не могут быть изменены после создания. Вы
можете изменить их наполнение, но не их размер (size), использование (usage), формат (format) и т.д. Если вы хотите
изменить что-то из этого, нужно создать новый ресурс и удалить старый.</p>
<p>Некоторые из этих состояний устанавливаются их созданием и вызовом буферов команд (command buffers; не путать с буферами данных).
Буферы команд - это буквально то, как они названы. Это буферы
с командами. Вы создаете кодировщики команд (command encoders). Кодировщики кодируют команды в командный
буфер. После вы <em>завершаете</em> (finish) кодировщик, и он отдаёт вам созданный им командный буфер.
После чего вы можете <em>отправить</em> (submit) этот командный буфер, чтобы WebGPU исполнил
эти команды.</p>
<p>Вот немного псевдо-кода кодирования буфера команд с последующим получением
созданного командного буфера.</p>
<div class="webgpu_center side-by-side"><div style="min-width: 300px; max-width: 400px; flex: 1 1;"><pre class="prettyprint showlinemods notranslate notranslate" translate="no">encoder = device.createCommandEncoder()
// отрисовать что-нибудь
{
  pass = encoder.beginRenderPass(...)
  pass.setPipeline(...)
  pass.setVertexBuffer(0, …)
  pass.setVertexBuffer(1, …)
  pass.setIndexBuffer(...)
  pass.setBindGroup(0, …)
  pass.setBindGroup(1, …)
  pass.draw(...)
  pass.end()
}
// отрисовать что-нибудь еще
{
  pass = encoder.beginRenderPass(...)
  pass.setPipeline(...)
  pass.setVertexBuffer(0, …)
  pass.setBindGroup(0, …)
  pass.draw(...)
  pass.end()
}
// расчитать что-нибудь
{
  pass = encoder.beginComputePass(...)
  pass.beginComputePass(...)
  pass.setBindGroup(0, …)
  pass.setPipeline(...)
  pass.dispatchWorkgroups(...)
  pass.end();
}
commandBuffer = encoder.finish();
</pre></div>
<div><img src="../resources/webgpu-command-buffer.svg" style="width: 300px;"></div>
</div>
<p>После создания командного буфера вы можете <em>отправить</em> его на исполнение.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.submit([commandBuffer]);
</pre>
<p>Диаграмма показывает состояние в момент исполнения команды <code class="notranslate" translate="no">draw</code> из командного
буфера. Вызов команд будет устанавливать <em>внутреннее состояние</em>, а затем
команда <em>отрисовки</em> (<code class="notranslate" translate="no">draw</code>) скажет графическому процессору исполнить вершинный (и неявно
fragment shader). Команда <code class="notranslate" translate="no">dispatchWorkgroup</code> скажет графическому процессору исполнить
вычислительный шейдер.</p>
<p>Надеюсь, это дало вам представление о том, как работают состояния. Как
упоминалось выше, у WebGPU есть 2 основные вещи, которые он может делать.</p>
<ol>
<li>
<p><a href="#a-drawing-triangles-to-textures">Рисовать треугольники/точки/линии на текстурах</a></p>
</li>
<li>
<p><a href="#a-run-computations-on-the-gpu">Запускать расчёты на графическом процессоре</a></p>
</li>
</ol>
<p>Мы рассмотрим небольшие примеры, как делается каждая из этих вещей. Другие
статьи покажут разные пути передачи данных в эти штуки. Обратите внимание,
это всего лишь основы. Нам нужно построить из них фундамент. Позже
мы покажем, как использовать их для вещей, которые люди обычно делают на графических процессорах, таких как
2D-графика, 3D-графика и т.д…</p>
<h1 id="отрисовка-треугольников-с-текстурами"><a id="a-drawing-triangles-to-textures"></a>Отрисовка треугольников с текстурами</h1>
<p>WebGPU может отрисовывать треугольники на <a href="webgpu-textures.html">текстурах</a>. Для целей данной
статьи текстура - двумерный прямоугольник, состоящий из пикселей. <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> Элемент <code class="notranslate" translate="no">&lt;canvas&gt;</code> (холст)
представляет собой текстуру на веб-странице. В WebGPU мы можем попросить у canvas текстуру
и затем рендерить на неё.</p>
<p>Для рисования треугольников с помощью WebGPU нам нужно два “шейдера”. Повторюсь, шейдеры -
это функции, которые запускаются на графическом процессоре. Два вида шейдеров:</p>
<ol>
<li>
<p>Вершинные шейдеры</p>
<p>Вершинные шейдеры - это функции для расчета позиций вершин для отрисовки
треугольников/линий/точек</p>
</li>
<li>
<p>Фрагментные шейдеры</p>
<p>Фрагментные шейдеры - это функции для расчета цветов (или других данных)
для каждого пикселя, который надо отрисовать/растеризовать при отрисовке треугольников/линий/точек</p>
</li>
</ol>
<p>Давайте начнем с самого простой программы WebGPU для отрисовки треугольника.</p>
<p>Нам нужен холст (canvas), чтобы отобразить наш треугольник.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas&gt;&lt;/canvas&gt;
</pre>
<p>Теперь нам нужен тег <code class="notranslate" translate="no">&lt;script&gt;</code>, чтобы добавить JavaScript.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas&gt;&lt;/canvas&gt;
+&lt;script type="module"&gt;

... здесь находится javascript ...

+&lt;/script&gt;
</pre>
<p>Весь JavaScript ниже будет находиться внутри этого тега <code class="notranslate" translate="no">script</code>.</p>
<p>WebGPU - это асинхронный API, поэтому проще всего использовать асинхронные функции. Мы
начнем с получения адаптера (adapter) и получения устройства (device) из адаптера.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }
}
main();
</pre>
<p>Приведенный выше код достаточно простой. Сначала мы получаем адаптер используя
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">оператор опциональной цепочки <code class="notranslate" translate="no">?.</code></a>.
Если <code class="notranslate" translate="no">navigator.gpu</code> отсутствует, тогда <code class="notranslate" translate="no">adapter</code> будет не определён (undefined).
Если он существует, тогда мы вызовем <code class="notranslate" translate="no">requestAdapter</code>. Этот метод возвращает результат асинхронно,
поэтому нам нужно добавить оператор <code class="notranslate" translate="no">await</code>. Адаптер представляет собой видеокарту. Некоторые устройства
имеют несколько видеокарт.</p>
<p>Из адаптера мы получаем устройство (device), но снова используем оператор <code class="notranslate" translate="no">?.</code>, так как если адаптер окажется
undefined, то и устройство тоже будет undefined.</p>
<p>Если <code class="notranslate" translate="no">device</code> не назначен, то, скорее всего, у пользователя старый браузер.</p>
<p>Далее, мы получаем холст (canvas) и создаем контекст <code class="notranslate" translate="no">webgpu</code> для него. Это также
позволит нам получить текстуру для отрисовки. Эта текстура будет использоватся для отображения на холсте на
веб-странице.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Получаем контекст WebGPU из холста и настраиваем его
  const canvas = document.querySelector('canvas');
  const context = canvas.getContext('webgpu');
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device,
    format: presentationFormat,
  });
</pre>
<p>Опять же, этот код максимально простой. Мы получаем контекст <code class="notranslate" translate="no">"webgpu"</code> из холста. Мы спрашиваем систему, каков предпочитаемый формат. Это будет либо <code class="notranslate" translate="no">"rgba8unorm"</code>, либо <code class="notranslate" translate="no">"bgra8unorm"</code>. Не сказать что это важно, но от этого зависит производительность на системе пользователя.</p>
<p>Мы устанавливаем <code class="notranslate" translate="no">format</code> в контексте webgpu холст с помощью вызова <code class="notranslate" translate="no">configure</code>.
Мы также устанавливаем <code class="notranslate" translate="no">device</code> который связывает холст с созданым устройством.</p>
<p>Далее, мы создаем модуль шейдера. Модуль шейдера содержит одну или больше функций шейдеров.
В нашем случае, мы создадим одну функцию вершинного шейдера и одну функцию в фрагментного шейдера.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded red triangle shaders',
    code: `
      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        return vec4f(pos[vertexIndex], 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
        return vec4f(1.0, 0.0, 0.0, 1.0);
      }
    `,
  });
</pre>
<p>Шейдер написан на языке, который называется
<a href="https://gpuweb.github.io/gpuweb/wgsl/">WebGPU Shading Language (WGSL)</a>, который
часто произносится как виг-сил. WGSL это строго-типированный язык,
который мы будем изучать более глубоко в <a href="webgpu-wgsl.html">другой статье</a>.
А сейчас, я надеюсь небольшое погружение поможет вам понять основы.</p>
<p>Выше мы видим функцию <code class="notranslate" translate="no">vs</code> она обьявлена с атрибутом <code class="notranslate" translate="no">@vertex</code>.
Он указывает, что это функция вершинного шейдера.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
         ...
</pre>
<p>Функция принимает один параметр с именем <code class="notranslate" translate="no">vertexIndex</code>. <code class="notranslate" translate="no">vertexIndex</code> - это <code class="notranslate" translate="no">u32</code>,
означающее <em>32-битное целое число со знаком</em>. Он получает своё значение из встроенного (builtin)
<code class="notranslate" translate="no">vertex_index</code>. <code class="notranslate" translate="no">vertex_index</code> это что-то вроде номера итерации, схожее с <code class="notranslate" translate="no">index</code> в
JavaScript-овом <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array.map(function(value, index) { ... })"><code class="notranslate" translate="no">Array.map(function(value, index) { ... })</code></a>. Если мы говорим графическому процессору
вызвать функцию 10 раз с помощью функции <code class="notranslate" translate="no">draw</code>, в первый раз <code class="notranslate" translate="no">vertex_index</code> будет <code class="notranslate" translate="no">0</code>,
во второй раз - <code class="notranslate" translate="no">1</code>, в третий раз - <code class="notranslate" translate="no">2</code> и так далее…<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>Наш <code class="notranslate" translate="no">vs</code> функция будет возвращать <code class="notranslate" translate="no">vec4f</code>, являющийся вектором из 4
32-битных чисел с плавающей запятой. Думайте о нём, как о массиве с четырьмя значениями или об как обьекте
с четырьмя свойствами типа <code class="notranslate" translate="no">{x: 0, y: 0, z: 0, w: 0}</code>. Возвращённое значение будет
назначено встроенному значению (builtin) <code class="notranslate" translate="no">position</code>. В режиме “triangle-list”, каждые 3 запуска
вершинного шейдера будет отрисован треугольник, соединяющий 3 позиции <code class="notranslate" translate="no">position</code>,
возвращённые из шейдера.</p>
<p>Позиции в WebGPU возвращаются в <em>clip space</em>, где X - от -1.0
влево и до +1.0 в право, а Y - от -1.0 вниз и до +1.0
вверх. Это верно, независимо от размера текстуры, в которую мы рисуем.</p>
<div class="webgpu_center"><img src="../resources/clipspace.svg" style="width: 500px"></div>
<p><code class="notranslate" translate="no">vs</code> функция объявляет массив их трех <code class="notranslate" translate="no">vec2f</code>. Каждый <code class="notranslate" translate="no">vec2f</code> содержит два
32-битных числа с плавающей запятой.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
</pre>
<p>Это будет использовать <code class="notranslate" translate="no">vertexIndex</code>, чтобы вернуть одно из трех значений в массиве.
Функция требует четырех чисел с плавающей запятой для работы и <code class="notranslate" translate="no">pos</code> это массив <code class="notranslate" translate="no">vec2f</code>, этот код вернет <code class="notranslate" translate="no">0.0</code> до <code class="notranslate" translate="no">1.0</code> для этих значений.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        return vec4f(pos[vertexIndex], 0.0, 1.0);
</pre>
<p>Модуль шейдера также содержит функцию, которая называется <code class="notranslate" translate="no">fs</code> которая обозначена атрибутом <code class="notranslate" translate="no">@fragment</code> который делает из этой функции <strong>функцию fragment shader’a</strong></p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs() -&gt; @location(0) vec4f {
</pre>
<p>Эта функция не принимает параметров и возвращает <code class="notranslate" translate="no">vec4f</code> в <code class="notranslate" translate="no">location(0)</code>.
Это значит, что значение будет записано как первая цель для отрисовки. Мы сделаем первую цель для отрисовки для нашего canvas текстуры позже.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        return vec4f(1, 0, 0, 1);
</pre>
<p>Код возвращает <code class="notranslate" translate="no">1, 0, 0, 1</code>, то есть красный. Цвета в WebGPU часто представленны как числа с плавающей запятой ( напоминаю, не целые ) от <code class="notranslate" translate="no">0.0</code> до <code class="notranslate" translate="no">1.0</code> где четыре числа выше запишутся как красный, зеленый, синий и альфа канал.</p>
<p>Когда графический процессор будет растрирует треугольник ( нарисует из него пиксели ), вызовется fragment shader, чтобы найти цвет для каждого пикселя. В нашем случае, мы просто вернем красный.</p>
<p>Еще одна фишка - это <code class="notranslate" translate="no">label</code> или <code class="notranslate" translate="no">название</code> на русском. Для каждого обьекта созданого WebGPU может быть назначен <code class="notranslate" translate="no">label</code>. Назначать названия для сущностей не обязательно, но принято как <em>хороший тон</em> называть все что ты создаешь. Это поможет, когда вы получите ошибку. В большинстве случаев WebGPU напишет ошибку, которая будет содержать название того, где произошла ошибка.</p>
<p>В большом приложении может быть сто или тысячи буферов, текстур, модулей шейдеров, pipelines и другого… Если вы получите ошибку
<code class="notranslate" translate="no">"WGSL syntax error in shaderModule at line 10"</code> и у вас сто модулей шейдеров, то возникнет вопрос: “А в каком из них конкретно ошибка?”. Если вы дадите название модулю, то при получении ошибки это будет выглядеть как
<code class="notranslate" translate="no">"WGSL syntax error in shaderModule('our hardcoded red triangle shaders') at line 10</code> где будет указано название модуля и поможет вам сохранить тонны времени, которые уйдут на отладку.</p>
<p>Теперь, мы создали модуль шейдера и дальше нужно создать render pipeline.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'our hardcoded red triangle pipeline',
    layout: 'auto',
    vertex: {
      module,
      entryPoint: 'vs',
    },
    fragment: {
      module,
      entryPoint: 'fs',
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>Тут особо не на что смотреть. Мы устанавливаем <code class="notranslate" translate="no">layout</code> в режим <code class="notranslate" translate="no">'auto'</code> и вернем макет данных ( layout of data ) из шейдера. Сейчас мы ни где не используем эти данные.</p>
<p>Далее мы говорим render pipeline’у использовать <code class="notranslate" translate="no">vs</code> функцию из нашего модуля шейдера для vertex shader и <code class="notranslate" translate="no">fs</code> функцию для нашего fragment shader. В противном случае, мы скажем ему формат для первой цели отрисовки. “цель отрисовки” или как в оригинале “render target” значит, что мы будем рендерить эту текстуру. Далее мы создаем pipeline и необходимо указать формат текстуры/текстур. Мы будем использовать этот pipeline для рендеринга.</p>
<p>Элемент ноль для <code class="notranslate" translate="no">целей</code> массива соотвутствует локации ноль, которую мы возвращаем в fragment shader’е. Далее мы будем устанавливать эту цель как текстуру для канваса.</p>
<p>Далее нужно подготовить <a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor"><code class="notranslate" translate="no">GPURenderPassDescriptor</code></a> который описывает какие текстуры мы хотим отрендерить и как будем использовать их.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass',
    colorAttachments: [
      {
        // view: &lt;- Чтобы текстура была заполнена внутри
        clearValue: [0.3, 0.3, 0.3, 1],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
  };  
</pre>
<p><a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor"><code class="notranslate" translate="no">GPURenderPassDescriptor</code></a> хранит массив для <code class="notranslate" translate="no">colorAttachments</code>, то есть листы текстур для отрисовки и как хранить их.
Мы хотим дождаться обработки той текстуры, которую хотим отрендерить. Сейчас мы устанавливаем значение полу-темного серого в <code class="notranslate" translate="no">loadOp</code> и <code class="notranslate" translate="no">storeOp</code>.
<code class="notranslate" translate="no">loadOp: 'clear'</code> устанавливается, чтобы очистить текстуру для следующей отрисовки. Другой вариант - <code class="notranslate" translate="no">'load'</code> который значит загрузку существующего контента текстуры в видокарты, короче, мы можем рендерить заного уже то что отрендерено.
<code class="notranslate" translate="no">storeOp: 'store'</code> чначит что мы будет хранить результат того, что хотим отрисовывать. Мы также могли установить <code class="notranslate" translate="no">'discard'</code>
который не будет хранить то что мы хотим отрисовать. Мы обсудим это в <a href="webgpu-multisampling.html">другой статье</a>.</p>
<p>Теперь время рендеринга.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // Получаем текущую текстуру из canvas context и устанавливаем ее как текстуру для рендеринга
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    // создаем шаблон команды, чтобы запускать их
    const encoder = device.createCommandEncoder({ label: 'our encoder' });

    // создаем render pass encoder для установке нашего шаблона
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.draw(3);  // вызываем наш vertex shader три раза
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }

  render();
</pre>
<p>Сначала мы вызываем <code class="notranslate" translate="no">context.getCurrentTexture()</code> для получение текстуры, которая будет отрисовываться на canvas’е. Вызываем <code class="notranslate" translate="no">createView</code> и получаем представление об определенной части текстур, но без параметров, он будет возвращать стандартную часть которая нам нужна. Сейчас есть только <code class="notranslate" translate="no">colorAttachment</code> - это представление текстуры из нашего canvas’а, которую мы получаем в контексте, который был создан вначале. Повторюсь, элемент ноль из <code class="notranslate" translate="no">colorAttachments</code> массива, который соответствует <code class="notranslate" translate="no">@location(0)</code>, который соответствует возвращаемому значение из fragment shader’а.</p>
<p>Далее, мы создаем шаблон команды. Шаблон команды используется, чтобы создать команду буфера. Мы используем это, чтобы создать команду и после “подтвердить” команду буфера и вызвать ее.</p>
<p>Далее мы используем шаблон команды, чтобы создать render pass encoder с помощью вызова <code class="notranslate" translate="no">beginRenderPass</code>. Render pass encoder служит для создания команд рендеринга.
Мы передаем его в <code class="notranslate" translate="no">renderPassDescriptor</code>, чтобы сказать какую текстуру мы хотим отрендерить.</p>
<p>Мы создаем команду и используем <code class="notranslate" translate="no">setPipeline</code>, чтобы назначить наш pipeline и далее вызвать vertex shader три раза с помощью функции <code class="notranslate" translate="no">draw</code> со значением три. По умолчанию каждые три раза наш vertex shader расчитает треугольник, который будет отрисован по трем вершинам.</p>
<p>Мы завершаем render pass и тогда завершаем команду. Это дает нам команду буфера что предтавляет собой шаги для рендеринга треугольника. Теперь мы подтверждаем команду буфера и вызываем ее.</p>
<p>Когда мы вызываем команду <code class="notranslate" translate="no">draw</code> - это будет нашим стейтом ( state ).</p>
<div class="webgpu_center"><img src="../resources/webgpu-simple-triangle-diagram.svg" style="width: 723px;"></div>
<p>У нас нет ни текстур ни буфером ни bindGroups, но у нас есть pipeline, vertex shader, fragment shader и render pass descriptor, который говорит нашим шейдерам рендерить на канвасе текстуру.</p>
<p>Результат:</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Подчеркну, что все эти функции как <code class="notranslate" translate="no">setPipeline</code> и <code class="notranslate" translate="no">draw</code> только добавляют команду в буфер.
Они не вызывают команды. Команды вызываются, когда мы подтверждаем их с помощью command buffer в списке девайсов.</p>
<p><a id="a-rasterization"></a>WebGPU принимает каждые три вершины и возвращает из нашего vertex shader и используется им для растеризации треугольника. Это делается с помощью определения какие пиксели находятся внутри треугольника. Далее это вызывает наш fragment shader для каждого пикселя, чтобы сказать какого цвета они будут.</p>
<p>Представьте текстуру, которую мы рендерим размером 15 на 11 пикселей. Это пиксели, которые мы хотим отрисовать.</p>
<div class="webgpu_center">
  <div data-diagram="clip-space-to-texels" style="display: inline-block; max-width: 500px; width: 100%"></div>
  <div>drag the vertices</div>
</div>
<p>Штош, теперь мы можем видеть простой пример работы WebGPU. Это показывает всю сложность написание и это все выглядит не очень гибко. Нам нужны пути, чтобы добавить данные и мы изучим это в следующих статьях. На что стоит обратить внимание в коде выше:</p>
<ul>
<li>WebGPU просто запускает шейдеры. Вы должны обрабатывать результат, чтобы делать функциональные вещи</li>
<li>Шейдеры указаны в модуле шейдера и далее указываются в pipeline’е</li>
<li>WebGPU может рендерить треугольники</li>
<li>WebGPU отрисовывает треугольники НА текстуре ( мы получаем текстуру из canvas’а )</li>
<li>WebGPU работает с помощью шаблонов команд, их вызова и подтверждения.</li>
</ul>
<h1 id="запуск-на-графическом-процессоре"><a id="a-run-computations-on-the-gpu"></a>Запуск на графическом процессоре</h1>
<p>Давайте напишем простой пример отрисовки на графическом процессоре.</p>
<p>Мы начинаем с того же самого кода для получения девайса</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }
</pre>
<p>Далее создаем модуль шейдера</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'doubling compute module',
    code: `
      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        let i = id.x;
        data[i] = data[i] * 2.0;
      }
    `,
  });
</pre>
<p>Сначала, мы создаем переменную с названием <code class="notranslate" translate="no">data</code> типа <code class="notranslate" translate="no">storage</code> из которой мы можем читать и записывать информацию.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;
</pre>
<p>Мы создаем его как тип <code class="notranslate" translate="no">array&lt;f32&gt;</code> который означает массив 32-битных чисел с плавающей запятой. Мы указываем, что массив должен находиться в binding location 0 (the
<code class="notranslate" translate="no">binding(0)</code>) в bindGroup 0 (the <code class="notranslate" translate="no">@group(0)</code>).</p>
<p>Далее мы создаем функцию с названием <code class="notranslate" translate="no">computeSomething</code> с атрибутом <code class="notranslate" translate="no">@compute</code> который делает из этой функции compute shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        ...
</pre>
<p>Compute shader нужен для назначения размера “рабочий группы” ( в оригинале workgroup ) о которой мы поговорим позже. А сейчас, мы просто устанавливаем один атрибут <code class="notranslate" translate="no">@workgroup_size(1)</code>.
Мы добавляем его, чтобы иметь параметр <code class="notranslate" translate="no">id</code>, который использует <code class="notranslate" translate="no">vec3u</code>. <code class="notranslate" translate="no">vec3u</code> - это три 32 битные целые числа без знака. Как наш vertex shader выше - это число итераций. Это работает по другому в compute shader. Число итераций тут - это три числа. Мы создаем <code class="notranslate" translate="no">id</code>, чтобы получить значение из built-in
<code class="notranslate" translate="no">global_invocation_id</code>.</p>
<p>Вы можете сделать <em>что-то вроде</em> этого для расчета шейдеров. Это супер упрощенная версия, но оно работает.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// псевдо-код
function dispatchWorkgroups(width, height, depth) {
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const workgroup_id = {x, y, z};
        dispatchWorkgroup(workgroup_id)
      }
    }
  }
}

function dispatchWorkgroup(workgroup_id) {
  // из @workgroup_size в WGSL
  const workgroup_size = shaderCode.workgroup_size;
  const {x: width, y: height, z: depth} = workgroup_size;
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const local_invocation_id = {x, y, z};
        const global_invocation_id =
            workgroup_id * workgroup_size + local_invocation_id;
        computeShader(global_invocation_id)
      }
    }
  }
}
</pre>
<p>С того момента как мы установили <code class="notranslate" translate="no">@workgroup_size(1)</code>, псевдо-код превратился в</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// псевдо-код
function dispatchWorkgroups(width, height, depth) {
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const workgroup_id = {x, y, z};
        dispatchWorkgroup(workgroup_id)
      }
    }
  }
}

function dispatchWorkgroup(workgroup_id) {
  const global_invocation_id = workgroup_id;
  computeShader(global_invocation_id)
}
</pre>
<p>Наконец-то мы используем <code class="notranslate" translate="no">x</code> как свойство <code class="notranslate" translate="no">id</code> для индекса <code class="notranslate" translate="no">data</code> и умножаем все значения на два.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        let i = id.x;
        data[i] = data[i] * 2.0;
</pre>
<p>Выше, <code class="notranslate" translate="no">i</code> это просто первое из трех чисел.</p>
<p>Теперь мы создали шейдер и нам нужно создать pipeline.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createComputePipeline({
    label: 'doubling compute pipeline',
    layout: 'auto',
    compute: {
      module,
      entryPoint: 'computeSomething',
    },
  });
</pre>
<p>Здесь мы просто указываем что используем <code class="notranslate" translate="no">compute</code> часть из шейдера. Мы создали <code class="notranslate" translate="no">module</code>
и там есть только один <code class="notranslate" translate="no">@compute</code> как точка входа и поэтому WebGPU понимает, что мы хотим вызвать его. <code class="notranslate" translate="no">layout</code> поставлен на режим
<code class="notranslate" translate="no">'auto'</code> снова, чтобы WebGPU возвращал обработанный макет из шейдера. <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>
<p>Далее, нам нужно немного данных.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const input = new Float32Array([1, 3, 5]);
</pre>
<p>Эти данные существуют только в JavaScript. Для WebGPU нам нужен создать буфер, который будет на графическом процессоре и будет копировать данные в этот буфер.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Создает буфер на графическом процессоре, чтобы перенести наши вычисления
  // входные и выходные
  const workBuffer = device.createBuffer({
    label: 'work buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  // Копирует наши данные в буфер
  device.queue.writeBuffer(workBuffer, 0, input);
</pre>
<p>Выше мы вызываем метод <code class="notranslate" translate="no">device.createBuffer</code> чтобы создать буфер. <code class="notranslate" translate="no">size</code> - это размер в байтах.
В нашем случае указано 12, так как мы храним в байтах тип <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> трех float значений а их размер будет равен двенадцати байтам.
Если вы не знакомы с <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> и строго-типизированными массивами, то читайте <a href="webgpu-memory-layout.html">эту статью</a>.</p>
<p>Каждый WebGPU буфер, который мы создаем имеет <code class="notranslate" translate="no">usage</code> или <code class="notranslate" translate="no">для чего используется</code>. Есть довольно большой список типов, которые мы можем указать для использования, но не все из них совместимы для совместного использования. Здесь мы указываем, что этот буфер будет использовать <code class="notranslate" translate="no">storage</code> или <code class="notranslate" translate="no">хранилище</code> с помощью флага
<code class="notranslate" translate="no">GPUBufferUsage.STORAGE</code>. Это добавляет возможность использовать <code class="notranslate" translate="no">var&lt;storage,...&gt;</code> из шейдера.
Дальше, мы хотим копировать данные из буфера, поэтому добавляем флаг <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code>. И последнее, мы хотим добавить возможность копировать данные из буфера, поэтому добавляем флаг <code class="notranslate" translate="no">GPUBufferUsage.COPY_SRC</code>.</p>
<p>Также хочу добавить, что вы не можете напрямую читать информацию из WebGPU буфера в JavaScript.
Вместо этого, у вас есть “карта” ( в оригинале “map” ) с помощью которой вы можете отправлять запросы к доступу к буферу из WebGPU, потому что буфер существует только на графическом процессоре.</p>
<p>Такой доступ к WebGPU буфере есть только в JavaScript. Другими словами, мы не можем сопоставить буфер, который мы только что создали выше, и если мы попытаемся добавить флаг, чтобы сделать его отображаемым, мы получим ошибку, с которой он несовместим использование <code class="notranslate" translate="no">STORAGE</code>.</p>
<p>Таким образом, чтобы получить результат наших вычислений нам нужен другой буфер.
После запуска вычислений мы копируем буфер выше в этот буфер с результатом и указываем флаг и мы можем отправлять запросы к нему.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Создает буфер на графическом процессоре и копирует результат
  const resultBuffer = device.createBuffer({
    label: 'result buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });
</pre>
<p><code class="notranslate" translate="no">MAP_READ</code> значит, что мы хотим иметь доступ к чтению данных.</p>
<p>Чтобы сказать шейдеру о нашем буфере нам нужно создать bindGroup.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Устанавливаем bindGroup, чтобы указать шейдеру
  // буфер, который будем использовать
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: workBuffer } },
    ],
  });
</pre>
<p>Мы получаем макет для bindGroup из pipeline’a. Далее, мы устанавливаем bindGroup.
Ноль в <code class="notranslate" translate="no">pipeline.getBindGroupLayout(0)</code> соотвествует <code class="notranslate" translate="no">@group(0)</code> в шейдере.
<code class="notranslate" translate="no">{binding: 0 ...</code> с <code class="notranslate" translate="no">entries</code> соответствует <code class="notranslate" translate="no">@group(0) @binding(0)</code> в шейдере.</p>
<p>Далее мы можем создавать команды</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Создает команды, чтобы делать расчеты
  const encoder = device.createCommandEncoder({
    label: 'doubling encoder',
  });
  const pass = encoder.beginComputePass({
    label: 'doubling compute pass',
  });
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(input.length);
  pass.end();
</pre>
<p>Мы создаем команду. Начинаем вычисления. Мы создаем pipeline и устанавливаем bindGroup. Здесь, <code class="notranslate" translate="no">0</code> в <code class="notranslate" translate="no">pass.setBindGroup(0, bindGroup)</code>
соответствует <code class="notranslate" translate="no">@group(0)</code> в шейдере. Далее мы вызываем <code class="notranslate" translate="no">dispatchWorkgroups</code>
И в нашем случае мы указываем в <code class="notranslate" translate="no">input.length</code> число <code class="notranslate" translate="no">3</code> говоря WebGPU запустить compute shader три раза и завершить расчет.</p>
<p>Такое произойдет, когда <code class="notranslate" translate="no">dispatchWorkgroups</code> будет вызван.</p>
<div class="webgpu_center"><img src="../resources/webgpu-simple-compute-diagram.svg" style="width: 553px;"></div>
<p>После расчетов мы говорим копировать данные из <code class="notranslate" translate="no">workBuffer</code> ( который занимается расчетом ) в <code class="notranslate" translate="no">resultBuffer</code> ( который копирует результат ).</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Пишем команду, чтобы скопировать результат в буфер
  encoder.copyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.size);
</pre>
<p>Теперь мы можем <code class="notranslate" translate="no">finish</code> ( завершить ) команду, чтобы получить команду буфера и подтвердить ее.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Завершает команду и подтверждает ее
  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);
</pre>
<p>Далее мы получаем результат и копируем данные.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Читаем результат
  await resultBuffer.mapAsync(GPUMapMode.READ);
  const result = new Float32Array(resultBuffer.getMappedRange());

  console.log('input', input);
  console.log('result', result);

  resultBuffer.unmap();
</pre>
<p>Чтобы получить результат буфера мы вызываем <code class="notranslate" translate="no">mapAsync</code> и указываем <code class="notranslate" translate="no">await</code>.
После этого мы вызываем <code class="notranslate" translate="no">resultBuffer.getMappedRange()</code>, который без параметров вернет <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> данных всего буфера.
Мы сохраняем результат в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a>. Строго-типизированный массив и после мы можем прочитать значения.
Важно подметить, что <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> возвращаемый с помощью <code class="notranslate" translate="no">getMappedRange</code> действительный, только до момента вызова <code class="notranslate" translate="no">unmap</code>.
После <code class="notranslate" translate="no">unmap</code> данные исчезнут.</p>
<p>Запускаем и получаем результат. Видим что все числа были умножены на два.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-compute.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-compute.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Мы будем изучать как использовать compute shader в других статьях.
Сейчас вам нужно только понять как работает WebGPU. ВСЕ ОСТАЛЬНОЕ ВЫ УЗНАЕТЕ ДАЛЬШЕ!.
WebGPU похож на другие языки программирования. Он дает возможность делать базовые вещи и дает возможность воссоздать все ваши идеи.</p>
<p>Особенным WebGPU делают эти функции, vertex shader, fragment shader и compute shader запускаемыми на вашей видеокарте.
У видеокарты есть более 10 000 процессоров, которые потенциально могут делать более 10 000 параллельных вычислений, которые невозможно делать на центральном процессоре (CPU).</p>
<h2 id="изменение-размера-canvasa"><a id="a-resizing"></a> Изменение размера Canvas’a</h2>
<p>Чтобы продвинуться дальше, давайте вернемся к отрисовке треугольника и добавим возможность изменения размера окна ( в данном случае canvas’a ).
Изменения размера имеет много мелочей, поэтому более подробно это описано <a href="webgpu-resizing-the-canvas.html">здесь</a>.
Сейчас давайте добавим самую простую поддержку.</p>
<p>Сначала нам нужно добавить CSS, чтобы заполнить страницу.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;style&gt;
html, body {
  margin: 0;       /* убирает смещение ( margin ) по умолчанию */
  height: 100%;    /* позволяет html полностью заполнить страницу */
}
canvas {
  display: block;  /* указывает тип канваса как block */
  width: 100%;     /* позволяет canvas'y заполнять страницу */
  height: 100%;
}
&lt;/style&gt;
</pre>
<p>Этот CSS код позволит canvas’y полностью заполнить страницу, но при этом не менять разрешение. Если вы сделаете окно примера выеш больше, например нажав на кнопку полноэкранного режима, то вы увидете что углы треугольника “блочные” ( я сама не знаю как точно перевести слово blocky. Если вы знаете, то сделайте свой pull request в гите ).</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-with-canvas-css.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-with-canvas-css.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">&lt;canvas&gt;</code> тег по умолчанию имеет разрешение 300 на 150 пикселей. Мы хотим регулировать разрешение canvas’a, чтобы изменять размер отображаемого изображения.
Одно из решений будет узазать <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>. Вы создаете <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> и даете его функции, чтобы вызвать его для любого элемента и изменить их размер. Вы говорите за какими элементами нужно наблюдать.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    ...
-    render();

+    const observer = new ResizeObserver(entries =&gt; {
+      for (const entry of entries) {
+        const canvas = entry.target;
+        const width = entry.contentBoxSize[0].inlineSize;
+        const height = entry.contentBoxSize[0].blockSize;
+        canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
+        canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
+        // заного отрисовать
+        render();
+      }
+    });
+    observer.observe(canvas);
</pre>
<p>В коде выше мы проходимся по всем элементам, но пройдемся только по одному так как у нас есть только canvas. Нам нужно установить размер нашего canvas’a, чтобы получить максимальный размер поддерживаем устройством, чтобы WebGPU не начал генерировать ошибки, потому что мы пытаем создать текстуру, которая слишком большая. Нам также нужно удостовериться, что это значение не будет равно нуль или мы снова будем получать ошибки.
<a href="webgpu-resizing-the-canvas.html">Вот огроменная статья со всеми фишками</a>.</p>
<p>Мы вызываем <code class="notranslate" translate="no">render</code>, чтобы заного отрисовать треугольник в новом разрешении.
Мы удаляем старый вызов <code class="notranslate" translate="no">render</code>, потому что он нам больше не нужен.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> будет вызывается каждый раз, когда размер элементов будет меняться.</p>
<p>Новый размер текстуры будет создаваться, когда мы вызываем <code class="notranslate" translate="no">context.getCurrentTexture()</code>
внутри <code class="notranslate" translate="no">render</code>, поэтому нам не нужно ничего делать более.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-with-canvas-resize.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-with-canvas-resize.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>В этих статьях мы рассмотрим разные варианты как указать данные в шейдер.</p>
<ul>
<li><a href="webgpu-inter-stage-variables.html">inter-stage variables</a></li>
<li><a href="webgpu-uniforms.html">uniforms</a></li>
<li><a href="webgpu-storage-buffers.html">storage buffers</a></li>
<li><a href="webgpu-vertex-buffers.html">vertex buffers</a></li>
<li><a href="webgpu-textures.html">textures</a></li>
<li><a href="webgpu-constants.html">constants</a></li>
</ul>
<p>Далее мы изучим <a href="webgpu-wgsl.html">основы WGSL</a>.</p>
<p>Здесь будут самые основы до самых сложных вещей. Inter-stage varibles не требует дополнительных знаний для понимания.
Мы можем увидеть как мы используем их ничего не используя, но меня WGSL выше. Uniforms - это эффективные глобальные переменные, которые используют все три вида шейдеров (vertex, fragment и compute).
Использовать uniform buffers, чтобы хранить буферы тривиально, как показано выше в статье о хранении буферов.
Vertex buffers используются только для vertex shader’ов.
Они более гибкие, так как требуют только указания данных в макет в WebGPU.
Текстуры являются самыми гибкими и у них есть тонны типов и вариантов.</p>
<p>Я немного обеспокоен, что эта статья будет скучноватой для начала, но изучайте дальше, если вам это нравится. Просто помните, что если вы что-то не понимаете, то вам нужно прочитать эти основы. Когда мы изучим их, то сможем перейти к более актуальным задачам.</p>
<p>Еще хотелось бы сказать, что все показанные примеры могут быть изменены прямо на странице в браузере.
Далее мы можете экспортировать все примеры в <a href="https://jsfiddle.net">jsfiddle</a> и <a href="https://codepen.io">codepen</a>
и еще <a href="https://stackoverflow.com">stackoverflow</a>. Просто нажмите кнопку “Export”.</p>
<div class="webgpu_bottombar">
<p>
Код для получения устройства WebGPU здесь максимально простой. Для более сложного варианта вам нужно делать как-то так
</p>
<pre class="prettyprint showmods">async function start() {
  if (!navigator.gpu) {
    fail('this browser does not support WebGPU');
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    fail('this browser supports webgpu but it appears disabled');
    return;
  }

  const device = await adapter?.requestDevice();
  device.lost.then((info) =&gt; {
    console.error(`WebGPU device was lost: ${info.message}`);

    // Если 'reason' ( причина ) будет 'destroyed' ( уничтожен, отключен ), если мы намеренно отключим устройство.
    if (info.reason !== 'destroyed') {
      // Попробовать снова
      start();
    }
  });
  
  main(device);
}
start();

function main(device) {
  ... do webgpu ...
}
</pre>
<p>
<code class="notranslate" translate="no">device.lost</code> - это promise ( обещание ), которые начинается как невыполненное. Оно выполнится, когда устройство будет потеряно. Устройство может быть потеряно по множеству причин. Может быть пользователь запустил очень требовательное приложение и это убило его видеокарту. Может быть, пользователь обновил драйвера. Может пользователь использует удаленную видеокарту и отключил ее. Может быть другая страница в браузере использует слишком много ресурсов видеокарты и ваша страница находится на зданем плане и теряет устройство из-за нехватки памяти. Это стоит делать, чтобы перехватывать потерю устройства.
</p>
<p>
Хочу подметить, что <code class="notranslate" translate="no">requestDevice</code> всегда возвращает устройство. Может только случится потеря в процессе выполнения.
WebGPU спроектирован так, что в большинстве случаев устройство будет работать в зависимости от версии API. Вызов для создания вещей и использования их может быть успешно выполненно, но никто не обещает. Это поможет вам перехватить потерю девайса с помощью promise.
</p>
</div>
<!-- keep this at the bottom of the article -->
<script type="module" src="../webgpu-fundamentals.js"></script>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Есть пять режимом отрисовки.</p>
<ul>
<li><code class="notranslate" translate="no">'point-list'</code>: для каждой позиции рисует точку</li>
<li><code class="notranslate" translate="no">'line-list'</code>: для каждых двух позиций рисует линию</li>
<li><code class="notranslate" translate="no">'line-strip'</code>: рисует линии, соединяя следующую точку с предыдущей</li>
<li><code class="notranslate" translate="no">'triangle-list'</code>: для каждых трех позиций рисует треугольник (<strong>по умолчанию</strong>)</li>
<li><code class="notranslate" translate="no">'triangle-strip'</code>: для каждой новой позиции рисует треугольник, соединяя последние две позиции</li>
</ul>
 <a href="#fnref1" class="footnote-backref">↩︎</a></li>
<li id="fn2" class="footnote-item"><p>Фрагментные шейдеры неявно записывают данные в текстуры. Эти данные
не обязаны быть цветами. Например, обычное дело - записывать в текстуру нормаль поверхности,
представленной пикселем. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Текстуры также могут быть трехмерными кубическими - cube maps (6 квадратов пикселей, формирущих куб) и другими, но в большинстве случаев текстуры - это двумерные пиксельные прямоугольники. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Мы также можем использовать индексный буфер, чтобы указать <code class="notranslate" translate="no">vertex_index</code>.
Это написано в <a href="../webgpu-vertex-buffers.html#a-index-buffers">статье об индексных буферах</a>. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><code class="notranslate" translate="no">layout: 'auto'</code> - это удобно, но не дает возможности поделиться bind groups с другими pipeline’ами. В большинстве примеров тут мы никогда не будем использовать bind group для множества pipeline’ов. Мы будет использовать явные макеты в <a href="webgpu-bind-group-layouts.html">другой статье</a>. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-fundamentals.html">English
    </option><option value="/webgpu/lessons/es/webgpu-fundamentals.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-fundamentals.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-fundamentals.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-fundamentals.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-fundamentals.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-fundamentals.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-fundamentals.html">Основы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Inter-stage Переменные</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-buffers.html">Storage буферы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ru/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Изучение WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Документация</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Доп.</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Доп.</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Нашли ошибку? <a href="https://github.com/webgpu/webgpufundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Основы`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>