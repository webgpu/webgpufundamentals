<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ru/webgpu-inter-stage-variables.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ru"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Взаимодействие данных из vertex shader'a в fragment shader">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ru.jpg">

<meta property="og:title" content="WebGPU Inter-stage Переменные">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ru.jpg">
<meta property="og:description" content="Взаимодействие данных из vertex shader'a в fragment shader">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Inter-stage Переменные">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html">
<meta name="twitter:description" content="Взаимодействие данных из vertex shader'a в fragment shader">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-inter-stage-variables_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html",
      "inLanguage":"ru",
      "name":"WebGPU Inter-stage Переменные",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-inter-stage-variables.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Inter-stage Переменные</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


    <a href="#toc">оглавление</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ru/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Inter-stage Переменные</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>В <a href="webgpu-fundamentals.html">предыдущей статье</a>, мы изучили немного самых базовых вещей об WebGPU.
В этой статье мы изучим <em>основы</em> inter-stage переменных.
Слово inter-stage правильнее всего перевести как <em>межэтапные</em></p>
<p>Inter-stage переменные работают вместе с vertex shader’ми и fragment shader´ми.</p>
<p>Vertex shader выдает три позиции для растеризации треугольника. Также он может выдавать дополнительные данные для каждой из этих точек. Эти значения будут интерполированны между этими тремя точками. Интерполяция - нахождение средних значений между двумя точками.</p>
<p>Давайте сделаем небольшой пример. Мы начнем с шейдера треугольника из предыдущий статьи. Все что нам нужно сделать - изменить шейдер.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
-    label: 'our hardcoded red triangle shaders',
+    label: 'our hardcoded rgb triangle shaders',
    code: `
+      struct OurVertexShaderOutput {
+        @builtin(position) position: vec4f,
+        @location(0) color: vec4f,
+      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
+        var color = array&lt;vec4f, 3&gt;(
+          vec4f(1, 0, 0, 1), // red
+          vec4f(0, 1, 0, 1), // green
+          vec4f(0, 0, 1, 1), // blue
+        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
      }

-      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+        return fsInput.color;
      }
    `,
  });
</pre>
<p>Сначала мы создаем <code class="notranslate" translate="no">struct</code>. Это простой способ создания inter-stage переменных между vertex shader’ом и fragment shader’ом.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>Далее мы говорим vertex shader’у вернуть эту структуру.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
-      ) -&gt; @builtin(position) vec4f {
+      ) -&gt; OurVertexShaderOutput {
</pre>
<p>Мы создаем массив с тремя цветами.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        var color = array&lt;vec4f, 3&gt;(
          vec4f(1, 0, 0, 1), // red
          vec4f(0, 1, 0, 1), // green
          vec4f(0, 0, 1, 1), // blue
        );
</pre>
<p>И далее вместо того, чтобы вернуть просто <code class="notranslate" translate="no">vec4f</code> для позиции мы возвращаем экземпляр этой структуры с заполненными данными.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        var vsOutput: OurVertexShaderOutput;
+        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
+        vsOutput.color = color[vertexIndex];
+        return vsOutput;
</pre>
<p>В fragment shader’е мы говорим взять одну из этих структур в качестве аргумента для функции.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
        return fsInput.color;
      }
</pre>
<p>И просто возвращаем цвет.</p>
<p>Если мы запустим проект, то увидим, что каждый раз, когда видеокарта вызывает наш fragment shader, то треугольник окрашивается, которые интерполированны между этими тремя точками.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Inter-stage переменные - это самый частый способ интерполировать координаты текстуры через треугольник. Мы изучим это в <a href="webgpu-textures.html">статье о текстурах</a>.
Также интерполяцию используют для создания карты нормалей ( interpolating normals ) через треугольник. Мы изучим это в <a href="webgpu-lighting-directional.html">первой статье об освещении</a>.</p>
<h2 id="inter-stage-переменные-работают-через-location">Inter-stage переменные работают через <code class="notranslate" translate="no">location</code></h2>
<p>Важно понимать, что почти все в WebGPU работает через vertex shader и fragment shader через индексы. Для inter-stage переменный они соединяются по location индексу.</p>
<p>Чтобы обьяснить это давайте поменяем fragment shader и поставим <code class="notranslate" translate="no">vec4f</code> параметр в <code class="notranslate" translate="no">location(0)</code> вместо этой структуры.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs(@location(0) color: vec4f) -&gt; @location(0) vec4f {
        return color;
      }
</pre>
<p>Запускаем и видим, что все работает.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-inter-stage-variables-triangle-by-fn-param.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-inter-stage-variables-triangle-by-fn-param.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<h2 id="builtinposition"><a id="a-builtin-position"></a> <code class="notranslate" translate="no">@builtin(position)</code></h2>
<p>Это отмечает одну особенность. Наш шейдер, который использует те же самые структуры в обоих шейдерах имеет поле, которое называется <code class="notranslate" translate="no">position</code>, но у него нету location, потому что он возвращает его через <code class="notranslate" translate="no">@builtin(position)</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      struct OurVertexShaderOutput {
*        @builtin(position) position: vec4f,
        @location(0) color: vec4f,
      };
</pre>
<p>Это поле <strong>НЕ</strong> является inter-stage переменной. Переменная находится в <code class="notranslate" translate="no">builtin</code>. Это показывает, что <code class="notranslate" translate="no">@builtin(position)</code> имеет другое представление в vertex shader’е и fragment shader’е.</p>
<p>В vertex shader’e <code class="notranslate" translate="no">@builtin(position)</code> это значит, что видеокарте надо нарисовать треугольники/линии/точки.</p>
<p>В fragment shader’e <code class="notranslate" translate="no">@builtin(position)</code> является параметром. Данный параметр - координата пикселя для которой будут происходить расчеты цвета.</p>
<p>Координаты пикселя являются уникальными для каждой точки. Эти значение передаются в fragment shader как координаты центра пикселя.</p>
<p>Если бы текстура, которую мы рисовали имела бы размер 3 на 2 пикселя, то эти точки были бы координатами.</p>
<div class="webgpu_center"><img src="../resources/webgpu-pixels.svg" style="width: 500px;"></div>
<p>Мы можем поменять наш шейдер, чтобы использовать эти позиции. Для примера, давайте нарисуем шахматную доску.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded checkerboard triangle shaders',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
-        @location(0) color: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
-        var color = array&lt;vec4f, 3&gt;(
-          vec4f(1, 0, 0, 1), // red
-          vec4f(0, 1, 0, 1), // green
-          vec4f(0, 0, 1, 1), // blue
-        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
-        vsOutput.color = color[vertexIndex];
        return vsOutput;
      }

      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
-        return fsInput.color;
+        let red = vec4f(1, 0, 0, 1);
+        let cyan = vec4f(0, 1, 1, 1);
+
+        let grid = vec2u(fsInput.position.xy) / 8;
+        let checker = (grid.x + grid.y) % 2 == 1;
+
+        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>Код выше получает <code class="notranslate" translate="no">fsInput.position</code>, которая является <code class="notranslate" translate="no">@builtin(position)</code> и конвертирует <code class="notranslate" translate="no">xy</code> координаты в <code class="notranslate" translate="no">vec2u</code>, которые являются двумя целочисленными числами со знаком. Он может делить их на восемь и отдавать нам увеличенное значение каждых восьми пикселей.
Также это добавляет <code class="notranslate" translate="no">x</code> и <code class="notranslate" translate="no">y</code> сетку координат вместе, которые расчитываются в модуле 2 и сравнивает результаты с единицей.
Это будет нам возвращать булевую переменную, которая будет либо true либо false для каждого числа.
Наконец-то, мы используем WGSL функцию <code class="notranslate" translate="no">select</code>, которая берет два значение и выбирает одно. которое соответствует условию.
В JavaScript’e <code class="notranslate" translate="no">select</code> функцию мы пишем так</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Если условие равно false - вернется `a`, а в ином случае вернется `b`
select = (a, b, condition) =&gt; condition ? b : a;
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Но если вы не используете <code class="notranslate" translate="no">@builtin(position)</code> в fragment shader’e, то есть становится удобнее, так как это значит, что мы можем использовать одну и ту же структуры для обоих шейдеров. Важно подметить, что <code class="notranslate" translate="no">position</code> в структуре в каждом шейдере не связаны. Это абсолютно разные переменные.</p>
<p>Хотя как выше указано - в inter-stage переменных все завязано на <code class="notranslate" translate="no">@location(?)</code>.
Получается, что это довольно непривычно создавать разные структуры для обоих шейдеров.</p>
<p>Для того, чтобы улучшить это нужно понимать, что оба шейдера находиться в одном файле ( если отталкиваться от примера, то правильнее сказать <em>в одной строке</em> ) и это сделанно ради удобства.
В будущем мы разобьем их на разные модули</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
-    label: 'hardcoded checkerboard triangle shaders',
+  const vsModule = device.createShaderModule({
+    label: 'hardcoded triangle',
    code: `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
      };

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
        return vsOutput;
      }
+    `,
+  });
+
+  const fsModule = device.createShaderModule({
+    label: 'checkerboard',
+    code: `
-      @fragment fn fs(fsInput: OurVertexShaderOutput) -&gt; @location(0) vec4f {
+      @fragment fn fs(@builtin(position) pixelPosition: vec4f) -&gt; @location(0) vec4f {
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);

-        let grid = vec2u(fsInput.position.xy) / 8;
+        let grid = vec2u(pixelPosition.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;

        return select(red, cyan, checker);
      }
    `,
  });
</pre>
<p>И нам нужно обновить наше создание pipeline для того, чтобы использовать это</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded checkerboard triangle pipeline',
    layout: 'auto',
    vertex: {
-      module,
+      module: vsModule,
    },
    fragment: {
-      module,
+      module: fsModule,
      targets: [{ format: presentationFormat }],
    },
  });

</pre>
<p>И это будет работать</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-fragment-shader-builtin-position-separate-modules.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-fragment-shader-builtin-position-separate-modules.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Следует подчеркнуть, что оба шейдера находятся в одной строке, но для большинства примеров WebGPU это сделано чисто для удобства.
В реальных проектах WebGPU парсит WGSL, чтобы удоствореться в правильности написания шейдера. Далее, WebGPU ищет <code class="notranslate" translate="no">entryPoint</code>
в шейдере. Здесь, он ищет части где entryPoint ссылается на что-либо и ничего другого. Это удобно, потому-что тебе не нужно указывать типы как структуры или биндинги или группы locations дважды. Если два или более шейдеров деляться своими биндингами или структурами или константами или функциями. Но с точки зрения WebGPU он запомнит их только один раз.</p>
<p>Подмечу: Это не стандартный способ создавать шахматную доску с использованием
<code class="notranslate" translate="no">@builtin(position)</code>. Шахматные доски или другие паттерны чаще всего создаются с помощью <a href="webgpu-textures.html">текстур</a>. Но вы увидете проблему если измените размер окна. Потому-что шахматная доска основана на координатах пикселей нашего canvas’a. Это относится к canvas’y, но не относится к треугольнику.</p>
<h2 id="настройки-интерполяции"><a id="a-interpolate"></a>Настройки интерполяции</h2>
<p>Мы видим выше inter-stage переменные, вывод из vertex shader, который интерполируется в fragment shader’e. Там есть две настройки для интерполяции. Обычно, эти значение не меняются и это используется для очень необычных случаев, которые будут описаны в других статьях.</p>
<p>Типы интерполяции:</p>
<ul>
<li><code class="notranslate" translate="no">perspective</code>: Значение интерполируются в зависимости от перспективы (<strong>по умолчанию</strong>)</li>
<li><code class="notranslate" translate="no">linear</code>: Значение интерполируется линейно, без перспективы</li>
<li><code class="notranslate" translate="no">flat</code>: Значение не интерполируются</li>
</ul>
<p>Виды функции интерполяции:</p>
<ul>
<li><code class="notranslate" translate="no">center</code>: Интерполяция выполняется от центра пикселя (<strong>по умолчанию</strong>)</li>
<li><code class="notranslate" translate="no">centroid</code>: Интерполяция выполняется в точке, лежащей внутри всех выборок, охватываемых фрагментом внутри текущего примитива. Это значение одинаково для всех выборок в примитиве.</li>
<li><code class="notranslate" translate="no">sample</code>:  Интерполяция выполняется для каждой выборки. Fragment shader вызывается один раз для каждой выборки при применении этого атрибута.</li>
<li><code class="notranslate" translate="no">first</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. (default) The value comes from the first vertex of the primitive being drawn</li>
<li><code class="notranslate" translate="no">either</code>: Used only with type = <code class="notranslate" translate="no">flat</code>. The value comes from either the first or the last vertex of the primitive being drawn.</li>
</ul>
<p>Вы указываете эти аттрибуты. Для примера</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">  @location(2) @interpolate(linear, center) myVariableFoo: vec4f;
  @location(3) @interpolate(flat) myVariableBar: vec4f;
</pre>
<p>Подмечу, что если inter-stage переменные являются целым числом - вам нужно установить интерполяцию на режим <code class="notranslate" translate="no">flat</code>.</p>
<p>Если вы устанавливаете интерполяцию на <code class="notranslate" translate="no">flat</code>, то значение, которое будет проходить через фрагментный шейдер является inter-stage переменной для первой вершины этого треугольника.</p>
<p>В <a href="webgpu-uniforms.html">следующей статье мы изучим что такое uniforms</a> как другой путь отсылки данных в шейдер.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-inter-stage-variables.html">English
    </option><option value="/webgpu/lessons/es/webgpu-inter-stage-variables.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-inter-stage-variables.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-inter-stage-variables.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-inter-stage-variables.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-inter-stage-variables.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-inter-stage-variables.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-fundamentals.html">Основы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Inter-stage Переменные</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-buffers.html">Storage буферы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ru/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Изучение WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Документация</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Доп.</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Доп.</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Нашли ошибку? <a href="https://github.com/webgpu/webgpufundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Inter-stage Переменные`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>