<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/ru/webgpu-uniforms.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="ru"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Прокидываем константные данные в шейдер">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ru.jpg">

<meta property="og:title" content="WebGPU Uniforms">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ru.jpg">
<meta property="og:description" content="Прокидываем константные данные в шейдер">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Uniforms">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html">
<meta name="twitter:description" content="Прокидываем константные данные в шейдер">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-uniforms_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html",
      "inLanguage":"ru",
      "name":"WebGPU Uniforms",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/ru/webgpu-uniforms.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Uniforms</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-uniforms.html">English
    </option><option value="/webgpu/lessons/es/webgpu-uniforms.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-uniforms.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-uniforms.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-uniforms.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-uniforms.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-uniforms.html">简体中文
</option></select>


    <a href="#toc">оглавление</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/webgpu/lessons/ru/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Uniforms</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Предыдущая статья была об <a href="webgpu-inter-stage-variables.html">inter-stage переменных</a>.
В этой статье я расскажу об uniforms.</p>
<p>( от переводчика ) Uniforms правильнее всего перевести как <em>универсальный</em>, то есть используется везде.</p>
<p>Uniforms - это что-то вроде глобальных переменных для вашего шейдера. Вы можете установить значение для них до вызова шейдера и они будут знать эти значения каждую итерацию вашего шейдера. Вы можете установить другое значение для них в любое время, когда вы просите видеокарту вызвать шейдер.</p>
<p>Мы снова начнем с треугольника из <a href="webgpu-fundamentals.html">первой статьи</a> и изменим код, добавив uniforms.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'triangle shaders with uniforms',
    code: `
+      struct OurStruct {
+        color: vec4f,
+        scale: vec2f,
+        offset: vec2f,
+      };
+
+      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

-        return vec4f(pos[vertexIndex], 0.0, 1.0);
+        return vec4f(
+          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
-        return vec4f(1, 0, 0, 1);
+        return ourStruct.color;
      }
    `,
  });

  });
</pre>
<p>Сначала мы создаем структуру с тремя переменными.</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">      struct OurStruct {
        color: vec4f,
        scale: vec2f,
        offset: vec2f,
      };
</pre>
<p>Далее, мы создаем uniform переменную с типом этой структуры.
Переменная <code class="notranslate" translate="no">ourStruct</code> с типом <code class="notranslate" translate="no">OurStruct</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wsgl" translate="no">      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
</pre>
<p>Далее, мы изменяем возвращаемое значение из vertex shader’a, чтобы использовать в uniforms.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
         ...
      ) ... {
        ...
        return vec4f(
          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
      }
</pre>
<p>Вы можете увидеть, что мы умножаем позицию вершины с помощью размера и далее добавляем смещение.
Это поможет нам указать размер треугольника и его позицию.</p>
<p>Мы также изменяем fragment shader, чтобы вернуть цвет из нашего uniforms.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs() -&gt; @location(0) vec4f {
        return ourStruct.color;
      }
</pre>
<p>Теперь, чтобы использовать uniforms нам нужно создать буфер на видеокарте и взять значение из шейдеров.</p>
<p>Это место, где если вы никогда не работали с собственными данными и размерами данных, то есть чему поучиться. Это большая тема, поэтому изучить ее вы можете <a href="webgpu-memory-layout.html">здесь</a>. Если вы не знаете как создавать структуры в памяти, пожалуйста, прочитайте <a href="webgpu-memory-layout.html">эту статью</a>. Вернемся назад. Эта статья предполагает, что вы уже прочитали <a href="webgpu-memory-layout.html">это</a>.</p>
<p>Прочитав <a href="webgpu-memory-layout.html">эту статью</a>, мы теперь можем заполнить наши буферы данными, которые совпадают со структурами в нашем шейдере.</p>
<p>Сначала, мы сделаем буфер и назначим ему <em>флаг использования</em> ( в оригинале usage flags ), таким образом мы сможем использовать его с uniforms и также обновлять его копирая новые данные в него.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const uniformBufferSize =
    4 * 4 + // цвет - это четыре 32-битных чисел с плавающей запятой (Каждое число по 4 байта)
    2 * 4 + // Размер - это два 32-битных числа с плавающей запятой (Каждое число по 4 байта)
    2 * 4;  // Смещение - это два 32-битных числа с плавающей запятой (Каждое число по 4 байта)
  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
</pre>
<p>Когда мы делаем <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code class="notranslate" translate="no">TypedArray</code></a>, мы можем устанавливать значения в JavaScript’e.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Создаем typedarray, чтоюы получать значения для uniforms в JavaScript'e
  const uniformValues = new Float32Array(uniformBufferSize / 4);
</pre>
<p>И мы заполняем два значение нашей структуры, которые не будут изменяться позже.
Смещение будет расчитываться способом, которые мы изучили <a href="webgpu-memory-layout.html">тут</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Смещение для различных uniform значение в float32 индексах
  const kColorOffset = 0;
  const kScaleOffset = 4;
  const kOffsetOffset = 6;

  uniformValues.set([0, 1, 0, 1], kColorOffset);        // устанавливаем цвет
  uniformValues.set([-0.5, -0.25], kOffsetOffset);      // устанавливаем смещение
</pre>
<p>Выше мы установили зеленый цвет. Смещение будет двигать треугольник к левой четверти нашего canvas’a и до нижней одной-восьмой (запомните, что clip space распологается в значениях от -1 до 1, где 0.25 будет 1/8 от двух).</p>
<p>Далее, <a href="../webgpu-fundamentals.html#a-draw-diagram">мы делаем как диаграмме показаной в первой статье</a>,
чтобы сказать шейдеру о нашем буфере, нам нужно создать bind group и забиндить (bind) буфер в тот же самый <code class="notranslate" translate="no">@binding(?)</code> куда мы установили наш шейдер.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer }},
    ],
  });
</pre>
<p>Теперь, перед тем как мы подтвердим команды буфера нам нужно установить оставшиеся команды для <code class="notranslate" translate="no">uniformValues</code> и после скопировать эти значение в буфер на нашей видеокарте.
Мы будем делать это в самом верху нашей функции <code class="notranslate" translate="no">render</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // Устанавливаем uniform значение для Float32Array на стороне JavaScript'a
    const aspect = canvas.width / canvas.height;
    uniformValues.set([0.5 / aspect, 0.5], kScaleOffset); // Устанавливаем размер

    // Копируем значения из JavaScript'a в видеокарту
    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
</pre>
<blockquote>
<p>Заметка: <code class="notranslate" translate="no">writeBuffer</code> - это один из способ копирования данных в буфер.
Также имеются несколько другие способы, которые описаны <a href="webgpu-copying-data.html">тут</a>.</p>
</blockquote>
<p>Мы устанавливаем размер в половину размер И берем во внимание аспект canvas’a, поэтому треугольник будет сохранять туже самую ширину и высоту в зависимости от размера canvas’a.</p>
<p>Наконец нам нужно установить bind group перед отрисовкой.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
+    pass.setBindGroup(0, bindGroup);
    pass.draw(3);  // Вызываем наш vertex shader 3 раза
    pass.end();
</pre>
<p>И таким образом мы получаем зеленый треугольник.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Для этого треугольника наш state вызывает команду отрисовки это выглядит примерно так.</p>
<div class="webgpu_center"><img src="../resources/webgpu-draw-diagram-triangle-uniform.svg" style="width: 863px;"></div>
<p>До этого момента, все наши данные использовавшиеся в нашем шейдере были очень не гибкие и назначены <em>грубо</em> ( в оригинале hardcoded ) ( позиции вершин треугольника в vertex shader и цвета во fragment shader’e ).
Теперь мы можем перенести наши значение в шейдер, мы вызываем метод <code class="notranslate" translate="no">draw</code>
несколько раз с разными данными.</p>
<p>Мы вызвали метод отрисовки в разных местах с разным смещением, размером и цветом с помощью обновления нашего буфера. Это важно понимать, хотя наши команды отправляются в командный буфер, они сейчас не вызываются пока мы не подтвердим их. Поэтому, мы <strong>НЕ МОЖЕМ</strong> делать это</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // ПЛОХО!
    for (let x = -1; x &lt; 1; x += 0.1) {
      uniformValues.set([x, x], kOffsetOffset);
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
      pass.draw(3);
    }
    pass.end();

    // Завершаем создание и подтверждение команд
    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
</pre>
<p>Как вы можете увидеть выше <code class="notranslate" translate="no">device.queue.xxx</code> функции вызываются в “очереди”, но <code class="notranslate" translate="no">pass.xxx</code> функции просто создают команду в командном буфере.
Когда мы вызываем <code class="notranslate" translate="no">submit</code> с нашим командным буфером,
В нашем буфере будут храниться только последние записанные значения.</p>
<p>Мы будем изменять их так.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    // ПЛОХО! МЕДЛЕННО!
    for (let x = -1; x &lt; 1; x += 0.1) {
      uniformValues.set([x, 0], kOffsetOffset);
      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();

      // Завершает создание и подтверждает команды
      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    }
</pre>
<p>Код выше обновляет один буфер, создает один командный буфер, добавляет команды для отрисовки одной штуки и завершаем командный буфер и подтверждаем его. Это работает, но медленно по множеству причин. Самая большая проблема - это то, что лучшей практикой является делать больше работы в одном командном буфере.</p>
<p>Поэтому, мы должны создать один uniform буфер для каждой вещи, которую мы хотим отрисовать. И с буферами использовать косвенно через bind groups, нам также нужно один bind group для каждой штуки, которую мы хотим отрисовать. Далее, если мы хотим положить все наши штуки, мы хотим отрисовать в одном командном буфере.</p>
<p>Давайте сделаем это!</p>
<p>Сначала, давайте сделаем функцию, которая будет возвращать случайное число.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Случайное число между [минимальным и максимальным)
// С аргументом один будет [0 до минимального)
// Если аргументы будут отсутствовать, то значение будет [0 до 1)
const rand = (min, max) =&gt; {
  if (min === undefined) {
    min = 0;
    max = 1;
  } else if (max === undefined) {
    max = min;
    min = 0;
  }
  return min + Math.random() * (max - min);
};

</pre>
<p>И теперь, давайте установим буферы со списком цветом и смещений, с помощью которых мы сможем отрисовать несколько уникальных вещей ( треугольников ).</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Смещения в виде уникальных uniform значений в виде float23 индексов
  const kColorOffset = 0;
  const kScaleOffset = 4;
  const kOffsetOffset = 6;

+  const kNumObjects = 100;
+  const objectInfos = [];
+
+  for (let i = 0; i &lt; kNumObjects; ++i) {
+    const uniformBuffer = device.createBuffer({
+      label: `uniforms for obj: ${i}`,
+      size: uniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });
+
+    // Создаем typedarray, чтобы взять значение из uniforms в JavaScript
+    const uniformValues = new Float32Array(uniformBufferSize / 4);
-  uniformValues.set([0, 1, 0, 1], kColorOffset);        // Устанавливаем цвет
-  uniformValues.set([-0.5, -0.25], kOffsetOffset);      // Устанавливаем смещение
+    uniformValues.set([rand(), rand(), rand(), 1], kColorOffset);        // Устанавливаем цвет
+    uniformValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], kOffsetOffset);      // Устанавливаем смещение
+
+    const bindGroup = device.createBindGroup({
+      label: `bind group for obj: ${i}`,
+      layout: pipeline.getBindGroupLayout(0),
+      entries: [
+        { binding: 0, resource: { buffer: uniformBuffer }},
+      ],
+    });
+
+    objectInfos.push({
+      scale: rand(0.2, 0.5),
+      uniformBuffer,
+      uniformValues,
+      bindGroup,
+    });
+  }
</pre>
<p>Мы еще не устанавливаем значения в наш буфер, потому что мы хотим также знать аспект canvas’a и мы не хотим знать аспект canvas’a до времени отрисовки.</p>
<p>Во время рендера мы будем обновлять все буферы с правильным размером, который скорректирован от аспекта.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
-    // Устанавливаем uniform значения в JavaScript как Float32Array
-    const aspect = canvas.width / canvas.height;
-    uniformValues.set([0.5 / aspect, 0.5], kScaleOffset); // Устанавливаем размер
-
-    // Копируем данные из JavaScript'a в видеокарту
-    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);

    // Получаем текущую текстуру из контекста canvas'a и
    // устанавливаем как текстуру для рендеринга.
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);

+    // Устанавливаем uniform значения в JavaScript как Float32Array
+    const aspect = canvas.width / canvas.height;

+    for (const {scale, bindGroup, uniformBuffer, uniformValues} of objectInfos) {
+      uniformValues.set([scale / aspect, scale], kScaleOffset); // Устанавливаем размер
+      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
       pass.setBindGroup(0, bindGroup);
       pass.draw(3);  // Вызываем наш vertex shader 3 раза
+    }
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }
</pre>
<p>Повторюсь, важно понимать, что <code class="notranslate" translate="no">encoder</code> и <code class="notranslate" translate="no">pass</code> обьекты - это просто созданные команды
в командный буфер. Далее, когда <code class="notranslate" translate="no">render</code> функция завершается мы эффективно отдаем эти <em>команды</em> в поток.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.writeBuffer(...) // Обновляем uniform буфер 0 с данными для обьекта 0
device.queue.writeBuffer(...) // Обновляем uniform буфер 1 с данными для обьекта 1
device.queue.writeBuffer(...) // Обновляем uniform буфер 2 с данными для обьекта 2
device.queue.writeBuffer(...) // Обновляем uniform буфер 3 с данными для обьекта 3
...
// Вызывает команды, которые отрисовывают 100 треугольников, каждая из которых имеет собственный uniform буфер.
device.queue.submit([commandBuffer]);
</pre>
<p>Выглядит вот так</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms-multiple.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms-multiple.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Пока мы здесь нужно изучить еще одну тему. Вы свободно можете ссылаться на несколько uniform буферов в твоем шейдере.
В нашем примере выше, каждый кадр при отрисовке мы обновляем размер, когда мы <code class="notranslate" translate="no">writeBuffer</code> для выгрузки <code class="notranslate" translate="no">uniformValues</code> для этого обьекта для соответствующего uniform буфера.
Но, только размер будет обновляться, цвет и смещение не будут, таким образом мы тратим время на выгрузку цвета и смещения.</p>
<p>Нам нужно разделить uniforms в uniforms которым нужно установить один раз для uniforms, которые будут обновляться каждый кадр отрисовки.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    code: `
      struct OurStruct {
        color: vec4f,
-        scale: vec2f,
        offset: vec2f,
      };

+      struct OtherStruct {
+        scale: vec2f,
+      };

      @group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
+      @group(0) @binding(1) var&lt;uniform&gt; otherStruct: OtherStruct;

      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        return vec4f(
-          pos[vertexIndex] * ourStruct.scale + ourStruct.offset, 0.0, 1.0);
+          pos[vertexIndex] * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
        return ourStruct.color;
      }
    `,
  });
</pre>
<p>Тогда нам нужно 2 uniform буфера для каждого треугольника</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  // Создает буфер для uniform значений
-  const uniformBufferSize =
-    4 * 4 + // цвет - это 4 32-битных числа с плавающей запятой (4 бита каждое)
-    2 * 4 + // размер - это 2 32-битных числа с плавающей запятой (4 бита каждое)
-    2 * 4;  // смещение - это 2 32-битных числа с плавающей запятой (4 бита каждое)
-  // Смещение для разных uniform значений в float32 индексах
-  const kColorOffset = 0;
-  const kScaleOffset = 4;
-  const kOffsetOffset = 6;
+  // Создаем 2 буфера для uniform значений
+  const staticUniformBufferSize =
+    4 * 4 + // цвет - это 4 32-битных числа с плавающей запятой (4 бита каждое)
+    2 * 4 + // смещение - это 2 32-битных числа с плавающей запятой (4 бита каждое)
+    2 * 4;  // padding ( не знаю как перевести, сори )
+  const uniformBufferSize =
+    2 * 4;  // размер - это 2 32-битных числа с плавающей запятой (4 бита каждое)
+
+  // Смещения для разных uniform значение в формате float32 индексов
+  const kColorOffset = 0;
+  const kOffsetOffset = 4;
+
+  const kScaleOffset = 0;

  const kNumObjects = 100;
  const objectInfos = [];

  for (let i = 0; i &lt; kNumObjects; ++i) {
+    const staticUniformBuffer = device.createBuffer({
+      label: `static uniforms for obj: ${i}`,
+      size: staticUniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });
+
+    // Здесь устанавливается только однажды, поэтому установим их сейчас
+    {
-      const uniformValues = new Float32Array(uniformBufferSize / 4);
+      const uniformValues = new Float32Array(staticUniformBufferSize / 4);
      uniformValues.set([rand(), rand(), rand(), 1], kColorOffset);        // Устанавливаем цвет
      uniformValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], kOffsetOffset);      // Устанавливаем смещение

      // Копируем эти данные в видеокарту
-      device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
+      device.queue.writeBuffer(staticUniformBuffer, 0, uniformValues);
    }

+    // Создаем typedarray, чтобы взять значение из uniforms в JavaScript
+    const uniformValues = new Float32Array(uniformBufferSize / 4);
+    const uniformBuffer = device.createBuffer({
+      label: `changing uniforms for obj: ${i}`,
+      size: uniformBufferSize,
+      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
+    });

    const bindGroup = device.createBindGroup({
      label: `bind group for obj: ${i}`,
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: staticUniformBuffer }},
+        { binding: 1, resource: { buffer: uniformBuffer }},
      ],
    });

    objectInfos.push({
      scale: rand(0.2, 0.5),
      uniformBuffer,
      uniformValues,
      bindGroup,
    });
  }
</pre>
<p>Ничего не меняется в коде рендеринга. Bind group для каждого обьекта содержит ссылку на оба uniform буфера для каждого обьекта. Просто раньше мы обновляли размер. Но сейчас мы только выгружаем размер, когда мы вызываем <code class="notranslate" translate="no">device.queue.writeBuffer</code>, чтобы обновить uniform буфер, который получает значение размера, где как мы раньше выгружали цвет + смещение + размер для каждого обьекта.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-uniforms-split.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-uniforms-split.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

<p></p>
<p>Пока в этом простом примере разделение на несколько uniform буферов вероятно излишнее много раз очищает память ( в оригинале overkill ). Это обычно для разделения, основанного на изменениях данных. Примеры могут включать один uniform буфер для матриц, которые будут общими. Для примера проекции матриц, view matrix и матрицы камеры. Часто с этими одинаковыми для всего вещами мы хотим отрисовать нам нужно просто сделать один буфер и использовать все обьекты в одном uniform буфере.</p>
<p>По отдельности наши шейдеры могут ссылаться на другой uniform буфер, который содержить еще вещи, которые специфичны для этого обьекта по типу мира/матрицы модели и матрицы нормалей ( в оригинале normal matrix ).</p>
<p>Другой uniform буфер может содержать настройки материала. Эти настройки могут быть общими для нескольких обьектов.</p>
<p>Мы еще изучим много материала по этой теме и тогда перейдем к отрисовке 3д графики.</p>
<p>Далее, <a href="webgpu-storage-buffers.html">хранилище буферов</a></p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-uniforms.html">English
    </option><option value="/webgpu/lessons/es/webgpu-uniforms.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-uniforms.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-uniforms.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-uniforms.html" selected="">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-uniforms.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-uniforms.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-fundamentals.html">Основы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-inter-stage-variables.html">Inter-stage Переменные</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-buffers.html">Storage буферы</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/ru/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgpu/lessons/ru/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/ru/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Изучение WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Документация</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Доп.</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Доп.</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Нашли ошибку? <a href="https://github.com/webgpu/webgpufundamentals/issues">Создайте задачу на github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Uniforms`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>