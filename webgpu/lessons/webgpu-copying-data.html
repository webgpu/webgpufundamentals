<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-copying-data.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Copying Data to/from buffers and textures">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-copying-data_en.jpg">

<meta property="og:title" content="WebGPU Copying Data">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-copying-data_en.jpg">
<meta property="og:description" content="Copying Data to/from buffers and textures">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Copying Data">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html">
<meta name="twitter:description" content="Copying Data to/from buffers and textures">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-copying-data_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-copying-data_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html",
      "inLanguage":"en",
      "name":"WebGPU Copying Data",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Copying Data</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-copying-data.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-copying-data.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-copying-data.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-copying-data.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-copying-data.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-copying-data.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-copying-data.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Copying Data</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>In most of the articles to date, we’ve used the functions
<code class="notranslate" translate="no">writeBuffer</code> to put data in a buffer and <code class="notranslate" translate="no">writeTexture</code>
to put data in a texture. There are several ways to put
data into a buffer or a texture.</p>
<h2 id="writebuffer"><code class="notranslate" translate="no">writeBuffer</code></h2>
<p><code class="notranslate" translate="no">writeBuffer</code> copies data from a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code class="notranslate" translate="no">TypedArray</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> in JavaScript to a buffer.
This is arguably the most straight forward way to get data into a buffer.</p>
<p><code class="notranslate" translate="no">writeBuffer</code> follows this format</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.writeBuffer(
  destBuffer,  // the buffer to write to
  destOffset,  // where in the destination buffer to start writing
  srcData,     // a typedArray or arrayBuffer
  srcOffset?,  // offset in **elements** in srcData to start copying
  size?,       // size in **elements** of srcData to copy
)
</pre>
<p>If <code class="notranslate" translate="no">srcOffset</code> is not passed it’s <code class="notranslate" translate="no">0</code>. If <code class="notranslate" translate="no">size</code> is not passed
it’s the size of <code class="notranslate" translate="no">srcData</code>.</p>
<blockquote>
<p>Important: <code class="notranslate" translate="no">srcOffset</code> and <code class="notranslate" translate="no">size</code> are in elements of <code class="notranslate" translate="no">srcData</code></p>
<p>In other words,</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.writeBuffer(
  someBuffer,
  someOffset,
  someFloat32Array,
  6,
  7,
)
</pre>
<p>the code above will copy from float32 #6, 7 float32s of data.
To put it another way it will copy 28 bytes starting at byte 24
from the portion of the arrayBuffer that <code class="notranslate" translate="no">someFloat32Array</code> is
a view of.</p>
</blockquote>
<h2 id="writetexture"><code class="notranslate" translate="no">writeTexture</code></h2>
<p><code class="notranslate" translate="no">writeTexture</code> copies data from a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code class="notranslate" translate="no">TypedArray</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> in JavaScript to a texture.</p>
<p><code class="notranslate" translate="no">writeTexture</code> has this signature</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.writeTexture(
  // details of the destination
  { texture, mipLevel: 0, origin: [0, 0, 0], aspect: "all" },

  // the source data
  srcData,

  // details of the source data
  { offset: 0, bytesPerRow, rowsPerImage },

  // size:
  [ width, height, depthOrArrayLayers ]
)
</pre>
<p>Things to note:</p>
<ul>
<li>
<p><code class="notranslate" translate="no">texture</code> must have a usage of <code class="notranslate" translate="no">GPUTextureUsage.COPY_DST</code></p>
</li>
<li>
<p><code class="notranslate" translate="no">mipLevel</code>, <code class="notranslate" translate="no">origin</code>, and <code class="notranslate" translate="no">aspect</code> all have defaults so they often do not need to be specified</p>
</li>
<li>
<p><code class="notranslate" translate="no">bytesPerRow</code>: This is how many bytes to advance to get to the next <em>block row</em> of data.</p>
<p>This is required if you are copying more than 1 <em>block row</em>. It is almost
always true that you’re copying more than 1 <em>block row</em> so it is therefore
almost always required.</p>
</li>
<li>
<p><code class="notranslate" translate="no">rowsPerImage</code>: This is the number of <em>block rows</em> to advance to get from the
the start of one image to the next image.</p>
<p>This is required if you are copying more than 1 layer. In other words,
if <code class="notranslate" translate="no">depthOrArrayLayers</code> in the size argument is &gt; 1 then you need to supply
this value.</p>
</li>
</ul>
<p>You can think of the copy as working like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   // pseudo code
   const [x, y, z] = origin ?? [0, 0, 0];
   const [blockWidth, blockHeight, bytesPerBlock] = 
      getBlockInfoForTextureFormat(texture.format);

   const blocksAcross = width / blockWidth;
   const blocksDown = height / blockHeight;
   const bytesPerBlockRow = blocksAcross * bytesPerBlock;

   for (layer = 0; layer &lt; depthOrArrayLayers; layer) {
      for (row = 0; row &lt; blocksDown; ++row) {
        const start = offset + (layer * rowsPerImage + row) * bytesPerRow;
        copyRowToTexture(
            texture,               // texture to copy to
            x, y + row, z + layer, // where in texture to copy to
            srcDataAsBytes + start,
            bytesPerBlockRow);
      }
   }
</pre>
<h3 id="block-row"><a id="a-block-rows"></a><strong>block row</strong></h3>
<p>Textures are organized into blocks. For most <em>regular</em> textures the block width
and block height are both 1. For compressed textures that changes. For example
the format, <code class="notranslate" translate="no">bc1-rgba-unorm</code> has a block width of 4 and a block height of 4.
That means if you set the width to 8, and the height to 12, only 6 blocks will be copied.
2 blocks for the first row, 2 for the 2nd row, 2 for the 3rd.</p>
<p>For compressed textures, size and origin must be aligned to blocks sizes.</p>
<blockquote>
<p>Important: Anywhere in the WebGPU that takes size (defined as a <code class="notranslate" translate="no">GPUExtent3D</code>)
can either be an array of 1 to 3 numbers, or it can be an object with 1 to
3 properties. <code class="notranslate" translate="no">height</code> and <code class="notranslate" translate="no">depthOrArrayLayers</code> default to 1 so</p>
<ul>
<li><code class="notranslate" translate="no">[2]</code> a size where width = 2, height = 1, depthOrArrayLayers = 1</li>
<li><code class="notranslate" translate="no">[2, 3]</code> a size where width = 2, height = 3, depthOrArrayLayers = 1</li>
<li><code class="notranslate" translate="no">[2, 3, 4]</code> a size where width = 2, height = 3, depthOrArrayLayers = 4</li>
<li><code class="notranslate" translate="no">{ width: 2 }</code> a size where width = 2, height = 1, depthOrArrayLayers = 1</li>
<li><code class="notranslate" translate="no">{ width: 2, height: 3 }</code> a size where width = 2, height = 3, depthOrArrayLayers = 1</li>
<li><code class="notranslate" translate="no">{ width: 2, height: 3, depthOrArrayLayers: 4 }</code> a size where width = 2, height = 3, depthOrArrayLayers = 4</li>
</ul>
</blockquote>
<blockquote>
<p>In the same way, Anywhere an origin appears (default aa a <code class="notranslate" translate="no">GPUOrigin3D</code>), you can either have an array
of 3 numbers, or a object with <code class="notranslate" translate="no">x</code>, <code class="notranslate" translate="no">y</code>, <code class="notranslate" translate="no">z</code> properties. All of them default to
0 so</p>
<ul>
<li><code class="notranslate" translate="no">[5]</code> an origin where x = 5, y = 0, z = 0</li>
<li><code class="notranslate" translate="no">[5, 6]</code> an origin where x = 5, y = 6, z = 0</li>
<li><code class="notranslate" translate="no">[5, 6, 7]</code> an origin where x = 5, y = 6, z = 7</li>
<li><code class="notranslate" translate="no">{ x: 5 }</code> an origin where x = 5, y = 0, z = 0</li>
<li><code class="notranslate" translate="no">{ x: 5, y: 6 }</code> an origin where x = 5, y = 6, z = 0</li>
<li><code class="notranslate" translate="no">{ x: 5, y: 6, z: 7 }</code> an origin where x = 5, y = 6, z = 7</li>
</ul>
</blockquote>
<ul>
<li><code class="notranslate" translate="no">aspect</code> really only comes into play when copying data to a depth-stencil format.
You can only copy to one aspect at a time, either the <code class="notranslate" translate="no">depth-only</code> or the <code class="notranslate" translate="no">stencil-only</code>.</li>
</ul>
<blockquote>
<p>Trivia: A texture has <code class="notranslate" translate="no">width</code>, <code class="notranslate" translate="no">height</code>, and <code class="notranslate" translate="no">depthOrArrayLayer</code> properties on it which
means it’s a valid <code class="notranslate" translate="no">GPUExtent3D</code>. In other words, given this texture</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const texture = device.createTexture({
  format: 'r8unorm',
  size: [2, 4],
  usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_ATTACHMENT,
});
</pre>
<p>all of these work</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// copy 2x4 pixels of data to texture
const bytesPerRow = 2;
device.queue.writeTexture({ texture }, data, { bytesPerRow }, [2, 4]);
device.queue.writeTexture({ texture }, data, { bytesPerRow }, [texture.width, texture.height]);
device.queue.writeTexture({ texture }, data, { bytesPerRow }, {width: 2, height: 4});
device.queue.writeTexture({ texture }, data, { bytesPerRow }, {width: texture.width, height: texture.height});
device.queue.writeTexture({ texture }, data, { bytesPerRow }, texture); // !!!
</pre>
<p>That last one works because a texture has a <code class="notranslate" translate="no">width</code>, <code class="notranslate" translate="no">height</code>, and <code class="notranslate" translate="no">depthOrArrayLayers</code>.
We haven’t used that style because it’s no so clear but, it is valid.</p>
</blockquote>
<h2 id="copybuffertobuffer"><code class="notranslate" translate="no">copyBufferToBuffer</code></h2>
<p><code class="notranslate" translate="no">copyBufferToBuffer</code>, like the name suggests, copies data from one buffer to another.</p>
<p>signature:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">encoder.copyBufferToBuffer(
  source,       // buffer to copy from
  sourceOffset, // where to start copying from
  dest,         // buffer to copy to
  destOffset,   // where to start copying to
  size,         // how many bytes to copy
)
</pre>
<ul>
<li><code class="notranslate" translate="no">source</code> must have a usage of <code class="notranslate" translate="no">GPUBufferUsage.COPY_SRC</code></li>
<li><code class="notranslate" translate="no">dest</code> must have a usage of <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code></li>
<li><code class="notranslate" translate="no">size</code> must be a multiple of 4</li>
</ul>
<h2 id="copybuffertotexture"><code class="notranslate" translate="no">copyBufferToTexture</code></h2>
<p><code class="notranslate" translate="no">copyBufferToTexture</code>, like the name suggests, copies data from a buffer to a texture.</p>
<p>signature:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">encoder.copyBufferToTexture(
  // details of the source buffer
  { buffer, offset: 0, bytesPerRow, rowsPerImage },

  // details of the destination texture
  { texture, mipLevel: 0, origin: [0, 0, 0], aspect: "all" },

  // size:
  [ width, height, depthOrArrayLayers ]
)
</pre>
<p>This has almost exactly the same parameters as <code class="notranslate" translate="no">writeTexture</code>.
The biggest difference is that <code class="notranslate" translate="no">bytesPerRow</code> <strong>must be
a multiple of 256!!</strong></p>
<ul>
<li><code class="notranslate" translate="no">texture</code> must have a usage of <code class="notranslate" translate="no">GPUTextureUsage.COPY_DST</code></li>
<li><code class="notranslate" translate="no">buffer</code> must have a usage of <code class="notranslate" translate="no">GPUBufferUsage.COPY_SRC</code></li>
</ul>
<h2 id="copytexturetobuffer"><code class="notranslate" translate="no">copyTextureToBuffer</code></h2>
<p><code class="notranslate" translate="no">copyTextureToBuffer</code> like the name suggests, copies data from a texture to a buffer.</p>
<p>signature:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">encoder.copyTextureToBuffer(
  // details of the source texture
  { texture, mipLevel: 0, origin: [0, 0, 0], aspect: "all" },

  // details of the destination buffer
  { buffer, offset: 0, bytesPerRow, rowsPerImage },

  // size:
  [ width, height, depthOrArrayLayers ]
)
</pre>
<p>This has similar parameters to <code class="notranslate" translate="no">copyBufferToTexture</code>
just the texture (now the source) and the buffer (now the destination)
are swapped. Like <code class="notranslate" translate="no">copyBufferToTexture</code>, <code class="notranslate" translate="no">bytesPerRow</code> <strong>must be
a multiple of 256!!</strong></p>
<ul>
<li><code class="notranslate" translate="no">texture</code> must have a usage of <code class="notranslate" translate="no">GPUTextureUsage.COPY_SRC</code></li>
<li><code class="notranslate" translate="no">buffer</code> must have a usage of <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code></li>
</ul>
<h2 id="copytexturetotexture"><code class="notranslate" translate="no">copyTextureToTexture</code></h2>
<p><code class="notranslate" translate="no">copyTextureToTexture</code> copies a portion of one texture to another.</p>
<p>The two textures must be must either be the same format, or they
must only differ by the suffix <code class="notranslate" translate="no">'-srgb'</code>.</p>
<p>signature:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">encoder.copyTextureToTexture(
  // details of the source texture
  src: { texture, mipLevel: 0, origin: [0, 0, 0], aspect: "all" },

  // details of the destination texture
  dst: { texture, mipLevel: 0, origin: [0, 0, 0], aspect: "all" },

  // size:
  [ width, height, depthOrArrayLayers ]
);
</pre>
<ul>
<li>src.<code class="notranslate" translate="no">texture</code> must have a usage of <code class="notranslate" translate="no">GPUTextureUsage.COPY_SRC</code></li>
<li>dst.<code class="notranslate" translate="no">texture</code> must have a usage of <code class="notranslate" translate="no">GPUTextureUsage.COPY_DST</code></li>
<li><code class="notranslate" translate="no">width</code> must be a multiple of block width</li>
<li><code class="notranslate" translate="no">height</code> must be a multiple of block height</li>
<li>src.<code class="notranslate" translate="no">origin[0]</code> or <code class="notranslate" translate="no">.x</code> must be a multiple of block width</li>
<li>src.<code class="notranslate" translate="no">origin[1]</code> or <code class="notranslate" translate="no">.y</code> must be a multiple of block height</li>
<li>dst.<code class="notranslate" translate="no">origin[0]</code> or <code class="notranslate" translate="no">.x</code> must be a multiple of block width</li>
<li>dst.<code class="notranslate" translate="no">origin[1]</code> or <code class="notranslate" translate="no">.y</code> must be a multiple of block height</li>
</ul>
<h2 id="shaders">Shaders</h2>
<p>Shaders can read and write to storage buffers, storage textures,
and indirectly they can render to textures. Those are all ways
of getting data into buffers and textures. In other words
you can write shaders to generate and/or copy and transfer data.</p>
<h2 id="mapping-buffers">Mapping Buffers</h2>
<p>You can map a buffer. Mapping a buffer means making it
available to read or write from JavaScript.
At least in version 1 of WebGPU,
mappable buffers have severe restrictions, namely, a
mappable buffer can can only be used as a temporary place
to copy from or to. A mappable buffer can not be used as any
other type of buffer (like a uniform buffer, vertex buffer,
index buffer, storage buffer, etc…) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>You can create a mappable buffer with 2 combinations
of usage flags.</p>
<ul>
<li>
<p><code class="notranslate" translate="no">GPUBufferUsage.MAP_READ | GPU_BufferUsage.COPY_DST</code></p>
<p>This is a buffer you can use the copy commands above to copy
data from another buffer or a texture, then map it to
read the values in JavaScript</p>
</li>
<li>
<p><code class="notranslate" translate="no">GPUBufferUsage.MAP_WRITE | GPU_BufferUsage.COPY_SRC</code></p>
<p>This is a buffer you can map in JavaScript, you can then put
data in it from JavaScript, and finally unmap it and use the
and the copy commands above to copy its contents to another
buffer or texture.</p>
</li>
</ul>
<p>The process of mapping a buffer is asynchronous. You call
<code class="notranslate" translate="no">buffer.mapAsync(mode, offset = 0, size?)</code> where <code class="notranslate" translate="no">offset</code>
and <code class="notranslate" translate="no">size</code> are in bytes. If <code class="notranslate" translate="no">size</code> is not specified it’s
the size of the entire buffer. <code class="notranslate" translate="no">mode</code> must be either
<code class="notranslate" translate="no">GPUMapMode.READ</code> or <code class="notranslate" translate="no">GPUMapMode.WRITE</code> and must of course
match the <code class="notranslate" translate="no">MAP_</code> usage flag you passed in when you created
the buffer.</p>
<p><code class="notranslate" translate="no">mapAsync</code> returns a <code class="notranslate" translate="no">Promise</code>.
When the promise resolves the buffer is mappable. You can then
view some or all of the buffer by calling <code class="notranslate" translate="no">buffer.getMappedRange(offset = 0, size?)</code>
where <code class="notranslate" translate="no">offset</code> a byte offset into the portion of the buffer you
mapped. <code class="notranslate" translate="no">getMappedRange</code> returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> so generally, to
be of any use, you’d use that to construct TypedArray.</p>
<p>Here’s one example of mapping a buffer</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer = device.createBuffer({
  size: 1024,
  usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
});

// map the entire buffer
await buffer.mapAsync(GPUMapMode.READ);

// get the entire buffer as an array of 32bit floats.
const f32 = new Float32Array(buffer.getMappedRange())

...

buffer.unmap();
</pre>
<p>Note: Once mapped, the buffer is not usable by WebGPU until you call <code class="notranslate" translate="no">unmap</code>.
The moment <code class="notranslate" translate="no">unmap</code> is called the buffer disappears from JavaScript. In other words,
take the example above</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const f32 = new Float32Array(buffer.getMappedRange())

f32[0] = 123;
console.log(f32[0]); // prints 123

buffer.unmap();

console.log(f32[0]); // prints undefined
</pre>
<p>We’ve already seen examples of mapping a buffer for reading
in <a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">the first article</a> where we doubled some numbers
in a storage buffer and the copied the results to a mappable buffer and mapped it to read out the results</p>
<p>Another example is the article on <a href="webgpu-compute-shaders.md">compute shader basics</a>
where we output the various <code class="notranslate" translate="no">@builtin</code> compute shader values to a storage buffer.
We then copied those results to a mappable buffer and mapped it read out the results.</p>
<h2 id="mappedatcreation"><a id="a-mapped-at-creation"></a>mappedAtCreation</h2>
<p><code class="notranslate" translate="no">mappedAtCreation: true</code> is a flag you can add when you
create a buffer. In this case, the buffer does not need
the usage flags <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code> nor <code class="notranslate" translate="no">GPUBufferUsage.MAP_WRITE</code>.</p>
<p>This is a special flag solely to let you put data in the
buffer on creation. You add the flat <code class="notranslate" translate="no">mappedAtCreation: true</code> when you create the
buffer. The buffer is created, already mapped for writing. Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no"> const buffer = device.createBuffer({
   size: 16,
   usage: GPUBufferUsage.UNIFORM,
   mappedAtCreation: true,
 });
 const arrayBuffer = buffer.getMappedRange(0, buffer.size);
 const f32 = new Float32Array(arrayBuffer);
 f32.set([1, 2, 3, 4]);
 buffer.unmap();
</pre>
<p>Or, more tersely</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no"> const buffer = device.createBuffer({
   size: 16,
   usage: GPUBufferUsage.UNIFORM,
   mappedAtCreation: true,
 });
 new Float32Array(buffer.getMappedRange(0, buffer.size)).set([1, 2, 3, 4]);
 buffer.unmap();
</pre>
<p>Note that a buffer created with <code class="notranslate" translate="no">mappedAtCreation: true</code> does not have
to have <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code> usage. But, if <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code> is
not set, you can not map the buffer again. It is only mapped once, at creation
time.</p>
<h2 id="efficiently-using-mappable-buffers"><a id="a-efficient"></a>Efficiently using mappable buffers</h2>
<p>Above we saw that mapping a buffer is asynchronous. This means there’s
an indeterminate amount of time from the point we ask for the buffer
to be mapped by calling <code class="notranslate" translate="no">mapAsync</code>, until the time it’s mapped and we can call <code class="notranslate" translate="no">getMappedRange</code>.</p>
<p>A common way to workaround this is to keep a set of buffers always mapped.
Since they are already mapped they are ready to use immediately. As soon
as you use one and unmap it, and as soon as you’ve submitted whatever
commands use the buffer, you ask for to to be mapped again. When its promise
resolves, you put it back in a pool of already mapped buffers. If you ever
need a mapped buffer and none are available you create a new one and add
it to the pool.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>The exception is if you set <code class="notranslate" translate="no">mappedAtCreation: true</code>
See <a href="#a-mapped-at-creation">mappedAtCreation</a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-copying-data.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-copying-data.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-copying-data.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-copying-data.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-copying-data.html">Русский
    </option><option value="/webgpu/lessons/uk/webgpu-copying-data.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-copying-data.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Copying Data`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>