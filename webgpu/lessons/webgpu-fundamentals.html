<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-fundamentals.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="The fundamentals of WebGPU">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_en.jpg">

<meta property="og:title" content="WebGPU Fundamentals">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_en.jpg">
<meta property="og:description" content="The fundamentals of WebGPU">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Fundamentals">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html">
<meta name="twitter:description" content="The fundamentals of WebGPU">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-fundamentals_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html",
      "inLanguage":"en",
      "name":"WebGPU Fundamentals",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Fundamentals</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-fundamentals.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-fundamentals.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-fundamentals.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-fundamentals.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-fundamentals.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-fundamentals.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-fundamentals.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-fundamentals.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Fundamentals</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article will try to teach you the very fundamentals of WebGPU.</p>
<div class="warn">
It is expected you already know JavaScript before
you read this article. Concepts like
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">mapping arrays</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring assignment</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">spreading values</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">es6 modules</a>,
and more will be used extensively. If you don't already know JavaScript and would like to learn it see
<a href="https://javascript.info/">JavaScript.info</a>, <a href="https://eloquentjavascript.net/">Eloquent JavaScript</a>,
and/or <a href="https://www.codecademy.com/learn/introduction-to-javascript">CodeCademy</a>.
</div>
<div class="warn">If you already know WebGL, <a href="webgpu-from-webgl.html">read this</a>.</div>
<p>WebGPU is an API that lets you do 2 basic things.</p>
<ol>
<li>
<p><a href="#a-drawing-triangles-to-textures">Draw triangles/points/lines to textures</a></p>
</li>
<li>
<p><a href="#a-run-computations-on-the-gpu">Run computations on the GPU</a></p>
</li>
</ol>
<p>That is it!</p>
<p>Everything about WebGPU after that is up to you. It’s like learning a computer
language like JavaScript, or Rust, or C++. First you learn the basics, then it’s up to
you to creatively use those basics to solve your problem.</p>
<p>WebGPU is an extremely low-level API. While you can make some small examples,
for many apps it will likely require a large amount of code and some serious
organization of data. As an example, <a href="https://threejs.org">three.js</a> which
supports WebGPU consists of ~600k minified JavaScript, and that’s just its
base library. That does not include loaders, controls, post-processing, and
many other features. Similarly, <a href="https://github.com/tensorflow/tfjs/tree/master/tfjs-backend-webgpu">TensorFlow with WebGPU backend</a>
is ~500k of minified JavaScript.</p>
<p>The point being, if you just want to get something on the screen you’re far
better off choosing a library that provides the large amount of code you’re
going to have to write when doing it yourself.</p>
<p>On the other hand, maybe you have a custom use case or maybe you want to modify
an existing library or maybe you’re just curious how it all works. In those
cases, read on!</p>
<h1 id="getting-started">Getting Started</h1>
<p>It’s hard to decide where to start. At a certain level, WebGPU is a very simple
system. All it does is run 3 types of functions on the GPU: Vertex Shaders,
Fragment Shaders, and Compute Shaders.</p>
<p>A Vertex Shader computes vertices. The shader returns vertex positions. For every group of 3 vertices the vertex shader function returns, a triangle is drawn between those 3 positions.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>A Fragment Shader computes colors.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> When a triangle is drawn, for each pixel
to be drawn the GPU calls your fragment shader. The fragment shader then returns a
color.</p>
<p>A Compute Shader is more generic. It’s effectively just a function you call and
say “execute this function N times”. The GPU passes the iteration number each
time it calls your function so you can use that number to do something unique on
each iteration.</p>
<p>If you squint hard, you can think of these functions as similar to the functions to
pass to
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code class="notranslate" translate="no">array.forEach</code></a>
or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code class="notranslate" translate="no">array.map</code></a>.
The functions you run on the GPU are just functions, just like JavaScript
functions. The part that differs is they run on the GPU, and so to run them you
need to copy all the data you want them to access to the GPU in the form of
buffers and textures and they only output to those buffers and textures.
You need to specify in the functions which bindings or locations the function
will look for the data. And, back in JavaScript, you need to bind the buffers and
textures holding your data to the bindings or locations. Once you’ve done that you tell the GPU to execute the
function.</p>
<p><a id="a-draw-diagram"></a>Maybe a picture will help. Here is a <em>simplified</em> diagram of WebGPU setup to draw triangles
by using a vertex shader and a fragment shader:</p>
<div class="webgpu_center"><img src="resources/webgpu-draw-diagram.svg" style="width: 960px;"></div>
<p>What to notice about this diagram:</p>
<ul>
<li>
<p>There is a <strong>Pipeline</strong>. It contains the vertex shader and fragment shader the
GPU will run. You could also have a pipeline with a compute shader.</p>
</li>
<li>
<p>The shaders reference resources (buffers, textures, samplers) indirectly
through <strong>Bind Groups</strong></p>
</li>
<li>
<p>The pipeline defines attributes that reference buffers indirectly through the
internal state</p>
</li>
<li>
<p>Attributes pull data out of buffers and feed the data into the vertex shader</p>
</li>
<li>
<p>The vertex shader may feed data into the fragment shader</p>
</li>
<li>
<p>The fragment shader writes to textures indirectly through the render pass
description</p>
</li>
</ul>
<p>To execute shaders on the GPU, you need to create all of these resources and
set up this state. Creation of resources is relatively straightforward. One
interesting thing is that most WebGPU resources can not be changed after creation. You
can change their contents but not their size, usage, format, etc… If you want
to change any of that stuff you create a new resource and destroy the old one.</p>
<p>Some of the state is set up by creating and then executing command buffers.
Command buffers are literally what their name suggests. They are a buffer of
commands. You create command encoders. The encoders encode commands into the command
buffer. You then <em>finish</em> the encoder and it gives you the command buffer it
created. You can then <em>submit</em> that command buffer to have WebGPU execute the
commands.</p>
<p>Here is some pseudo-code for encoding a command buffer followed by a representation of
the command buffer that was created.</p>
<div class="webgpu_center side-by-side"><div style="min-width: 300px; max-width: 400px; flex: 1 1;"><pre class="prettyprint showlinemods notranslate notranslate" translate="no">encoder = device.createCommandEncoder()
// draw something
{
  pass = encoder.beginRenderPass(...)
  pass.setPipeline(...)
  pass.setVertexBuffer(0, …)
  pass.setVertexBuffer(1, …)
  pass.setIndexBuffer(...)
  pass.setBindGroup(0, …)
  pass.setBindGroup(1, …)
  pass.draw(...)
  pass.end()
}
// draw something else
{
  pass = encoder.beginRenderPass(...)
  pass.setPipeline(...)
  pass.setVertexBuffer(0, …)
  pass.setBindGroup(0, …)
  pass.draw(...)
  pass.end()
}
// compute something
{
  pass = encoder.beginComputePass(...)
  pass.beginComputePass(...)
  pass.setBindGroup(0, …)
  pass.setPipeline(...)
  pass.dispatchWorkgroups(...)
  pass.end();
}
commandBuffer = encoder.finish();
</pre></div>
<div><img src="resources/webgpu-command-buffer.svg" style="width: 300px;"></div>
</div>
<p>Once you create a command buffer, you can <em>submit</em> it to be executed:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">device.queue.submit([commandBuffer]);
</pre>
<p>The ‘simplified diagram of WebGPU setup’ shown previously represents the state at a <em>single</em> <code class="notranslate" translate="no">draw</code> command in the command
buffer. Executing the commands will set up the <em>internal state</em> and then the
<code class="notranslate" translate="no">draw</code> command will tell the GPU to execute a vertex shader (and indirectly a
fragment shader). The <code class="notranslate" translate="no">dispatchWorkgroup</code> command will tell the GPU to execute a
compute shader.</p>
<p>I hope that gave you some mental image of the state you need to set up. Like
mentioned above, WebGPU has 2 basic things it can do:</p>
<ol>
<li>
<p><a href="#a-drawing-triangles-to-textures">Draw triangles/points/lines to textures</a></p>
</li>
<li>
<p><a href="#a-run-computations-on-the-gpu">Run computations on the GPU</a></p>
</li>
</ol>
<p>We’ll go over a small example of doing each of those things. Other
articles will show the various ways of providing data to these things. Note that
this will be very basic. We need to build up a foundation of these basics. Later
we’ll show how to use them to do things people typically do with GPUs like 2D
graphics, 3D graphics, etc…</p>
<h1 id="drawing-triangles-to-textures"><a id="a-drawing-triangles-to-textures"></a>Drawing triangles to textures</h1>
<p>WebGPU can draw triangles to <a href="webgpu-textures.html">textures</a>. For the purpose
of this article, a texture is a 2D rectangle of pixels.<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> The <code class="notranslate" translate="no">&lt;canvas&gt;</code> element
represents a texture on a webpage. In WebGPU we can ask the canvas for a texture
and then render to that texture.</p>
<p>To draw triangles with WebGPU we have to supply 2 “shaders”. Again, Shaders
are functions that run on the GPU. These 2 shaders are:</p>
<ol>
<li>
<p>Vertex Shaders</p>
<p>Vertex shaders are functions that compute vertex positions for drawing
triangles/lines/points</p>
</li>
<li>
<p>Fragment Shaders</p>
<p>Fragment shaders are functions that compute the color (or other data)
for each pixel to be drawn/rasterized when drawing triangles/lines/points</p>
</li>
</ol>
<p>Let’s start with a very small WebGPU program to draw a triangle.</p>
<p>We need a canvas to display our triangle:</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas&gt;&lt;/canvas&gt;
</pre>
<p>then we need a <code class="notranslate" translate="no">&lt;script&gt;</code> tag to hold our JavaScript:</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;canvas&gt;&lt;/canvas&gt;
+&lt;script type="module"&gt;

... javascript goes here ...

+&lt;/script&gt;
</pre>
<p>All of the JavaScript below will go inside this script tag.</p>
<p>WebGPU is an asynchronous API so it’s easiest to use in an async function. We
start off by requesting an adapter, and then requesting a device from the adapter.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }
}
main();
</pre>
<p>The code above is fairly self-explanatory. First, we request an adapter by using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"><code class="notranslate" translate="no">?.</code> optional chaining operator</a>.
so that if <code class="notranslate" translate="no">navigator.gpu</code> does not exist then <code class="notranslate" translate="no">adapter</code> will be undefined.
If it does exist then we’ll call <code class="notranslate" translate="no">requestAdapter</code>. It returns its results asynchronously
so we need <code class="notranslate" translate="no">await</code>. The adapter represents a specific GPU. Some devices
have multiple GPUs.</p>
<p>From the adapter, we request the device but again use <code class="notranslate" translate="no">?.</code> so that if adapter happens
to be undefined then device will also be undefined.</p>
<p>If the <code class="notranslate" translate="no">device</code> is not set, it’s likely the user has an old browser.</p>
<p>Next, we look up the canvas and create a <code class="notranslate" translate="no">webgpu</code> context for it. This will
let us get a texture to render to. That texture will be used to display the canvas in the
webpage.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Get a WebGPU context from the canvas and configure it
  const canvas = document.querySelector('canvas');
  const context = canvas.getContext('webgpu');
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device,
    format: presentationFormat,
  });
</pre>
<p>Again, the code above is pretty self-explanatory. We get a <code class="notranslate" translate="no">"webgpu"</code> context
from the canvas. We ask the system what the preferred canvas format is. This
will be either <code class="notranslate" translate="no">"rgba8unorm"</code> or <code class="notranslate" translate="no">"bgra8unorm"</code>. It’s not really that important
what it is but querying it will make things faster for the user’s system.</p>
<p>We pass that as <code class="notranslate" translate="no">format</code> into the webgpu canvas context by calling <code class="notranslate" translate="no">configure</code>.
We also pass in the <code class="notranslate" translate="no">device</code> which associates this canvas with the device we just
created.</p>
<p>Next, we create a shader module. A shader module contains one or more shader
functions. In our case, we’ll make 1 vertex shader function and 1 fragment shader
function.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'our hardcoded red triangle shaders',
    code: `
      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );

        return vec4f(pos[vertexIndex], 0.0, 1.0);
      }

      @fragment fn fs() -&gt; @location(0) vec4f {
        return vec4f(1.0, 0.0, 0.0, 1.0);
      }
    `,
  });
</pre>
<p>Shaders are written in a language called
<a href="https://gpuweb.github.io/gpuweb/wgsl/">WebGPU Shading Language (WGSL)</a> which is
often pronounced wig-sil. WGSL is a strongly typed language
which we’ll try to go over in more detail in <a href="webgpu-wgsl.html">another article</a>.
For now, I’m hoping with a little explanation you can infer some basics.</p>
<p>Above we see a function called <code class="notranslate" translate="no">vs</code> is declared with the <code class="notranslate" translate="no">@vertex</code> attribute.
This designates it as a vertex shader function.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -&gt; @builtin(position) vec4f {
         ...
</pre>
<p>It accepts one parameter we named <code class="notranslate" translate="no">vertexIndex</code>. <code class="notranslate" translate="no">vertexIndex</code> is a <code class="notranslate" translate="no">u32</code> which
means a <em>32-bit unsigned integer</em>. It gets its value from the builtin called
<code class="notranslate" translate="no">vertex_index</code>. <code class="notranslate" translate="no">vertex_index</code> is like an iteration number, similar to <code class="notranslate" translate="no">index</code> in
JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array.map(function(value, index) { ... })"><code class="notranslate" translate="no">Array.map(function(value, index) { ... })</code></a>. If we tell the GPU to
execute this function 10 times by calling <code class="notranslate" translate="no">draw</code>, the first time <code class="notranslate" translate="no">vertex_index</code> would be <code class="notranslate" translate="no">0</code>, the
2nd time it would be <code class="notranslate" translate="no">1</code>, the 3rd time it would be <code class="notranslate" translate="no">2</code>, etc…<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>Our <code class="notranslate" translate="no">vs</code> function is declared as returning a <code class="notranslate" translate="no">vec4f</code> which is a vector of four
32-bit floating point values. Think of it as an array of 4 values or an object
with 4 properties like <code class="notranslate" translate="no">{x: 0, y: 0, z: 0, w: 0}</code>. This returned value will be
assigned to the <code class="notranslate" translate="no">position</code> builtin. In “triangle-list” mode, every 3 times the
vertex shader is executed a triangle will be drawn connecting the 3 <code class="notranslate" translate="no">position</code>
values we return.</p>
<p>Positions in WebGPU need to be returned in <em>clip space</em> where X goes from -1.0
on the left to +1.0 on the right, and Y goes from -1.0 at the bottom to +1.0 at the
top. This is true regardless of the size of the texture we are drawing to.</p>
<div class="webgpu_center"><img src="resources/clipspace.svg" style="width: 500px"></div>
<p>The <code class="notranslate" translate="no">vs</code> function declares an array of 3 <code class="notranslate" translate="no">vec2f</code>s. Each <code class="notranslate" translate="no">vec2f</code> consists of two
32-bit floating point values.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
</pre>
<p>Finally it uses <code class="notranslate" translate="no">vertexIndex</code> to return one of the 3 values from the array.
Since the function requires 4 floating point values for its return type, and
since <code class="notranslate" translate="no">pos</code> is an array of <code class="notranslate" translate="no">vec2f</code>, the code supplies <code class="notranslate" translate="no">0.0</code> and <code class="notranslate" translate="no">1.0</code> for
the remaining 2 values.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        return vec4f(pos[vertexIndex], 0.0, 1.0);
</pre>
<p>Note that for drawing something in 2D we usually only need the x and y values
for position. The z value is used for depth testing and will come up in
<a href="webgpu-orthographic-projection.html">the article on orthographic projection</a>.
The z value is used for perspective divide and will come up in
<a href="webgpu-perspective-projection.html">the article on perspective projection</a>.
For now, setting them to z to 0.0 and w to 1.0 is what we need to draw
the triangle.</p>
<p>The shader module also declares a function called <code class="notranslate" translate="no">fs</code> that is declared with
<code class="notranslate" translate="no">@fragment</code> attribute making it a fragment shader function.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @fragment fn fs() -&gt; @location(0) vec4f {
</pre>
<p>This function takes no parameters and returns a <code class="notranslate" translate="no">vec4f</code> at <code class="notranslate" translate="no">location(0)</code>.
This means it will write to the first render target. We’ll make the first
render target our canvas texture later.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        return vec4f(1, 0, 0, 1);
</pre>
<p>The code returns <code class="notranslate" translate="no">1, 0, 0, 1</code> which is red. Colors in WebGPU are usually
specified as floating point values from <code class="notranslate" translate="no">0.0</code> to <code class="notranslate" translate="no">1.0</code> where the 4 values above
correspond to red, green, blue, and alpha respectively.</p>
<p>When the GPU rasterizes the triangle (draws it with pixels), it will call
the fragment shader to find out what color to make each pixel. In our case,
we’re just returning red.</p>
<p>One more thing to note is the <code class="notranslate" translate="no">label</code>. Nearly every object you can create with
WebGPU can take a <code class="notranslate" translate="no">label</code>. Labels are entirely optional but it’s considered
<em>best practice</em> to label everything you make. The reason is that when you get an
error, most WebGPU implementations will print an error message that includes the
labels of the things related to the error.</p>
<p>In a normal app, you’d have 100s or 1000s of buffers, textures, shader modules,
pipelines, etc… If you get an error like <code class="notranslate" translate="no">"WGSL syntax error in shaderModule at line 10"</code>, if you have 100 shader modules, which one got the error? If you
label the module then you’ll get an error more like <code class="notranslate" translate="no">"WGSL syntax error in shaderModule('our hardcoded red triangle shaders') at line 10</code> which is a way
more useful error message and will save you a ton of time tracking down the
issue.</p>
<p>Now that we’ve created a shader module, we next need to make a render pipeline:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'our hardcoded red triangle pipeline',
    layout: 'auto',
    vertex: {
      entryPoint: 'vs',
      module,
    },
    fragment: {
      entryPoint: 'fs',
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>In this case, there isn’t much to see. We set <code class="notranslate" translate="no">layout</code> to <code class="notranslate" translate="no">'auto'</code> which means
to ask WebGPU to derive the layout of data from the shaders. We’re not using
any data though.</p>
<p>We then tell the render pipeline to use the <code class="notranslate" translate="no">vs</code> function from our shader module
for a vertex shader and the <code class="notranslate" translate="no">fs</code> function for our fragment shader. Otherwise, we
tell it the format of the first render target. “render target” means the texture
we will render to. When we create a pipeline
we have to specify the format for the texture(s) we’ll use this pipeline to
eventually render to.</p>
<p>Element 0 for the <code class="notranslate" translate="no">targets</code> array corresponds to location 0 as we specified for
the fragment shader’s return value. Later, we’ll set that target to be a texture
for the canvas.</p>
<p>One shortcut, for each shader stage, <code class="notranslate" translate="no">vertex</code> and <code class="notranslate" translate="no">fragment</code>, if there is only one
function of the corresponding type then we don’t need to specify the <code class="notranslate" translate="no">entryPoint</code>.
WebGPU will use the sole function that matches the shader stage. So we can shorten
the code above to:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'our hardcoded red triangle pipeline',
    layout: 'auto',
    vertex: {
-      entryPoint: 'vs',
      module,
    },
    fragment: {
-      entryPoint: 'fs',
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>Next up we prepare a <a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor"><code class="notranslate" translate="no">GPURenderPassDescriptor</code></a> which describes which textures
we want to draw to and how to use them.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const renderPassDescriptor = {
    label: 'our basic canvas renderPass',
    colorAttachments: [
      {
        // view: &lt;- to be filled out when we render
        clearValue: [0.3, 0.3, 0.3, 1],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
  };  
</pre>
<p>A <a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor"><code class="notranslate" translate="no">GPURenderPassDescriptor</code></a> has an array for <code class="notranslate" translate="no">colorAttachments</code> which lists
the textures we will render to and how to treat them.
We’ll wait to fill in which texture we actually want to render to. For now,
we set up a clear value of semi-dark gray, and a <code class="notranslate" translate="no">loadOp</code> and <code class="notranslate" translate="no">storeOp</code>.
<code class="notranslate" translate="no">loadOp: 'clear'</code> specifies to clear the texture to the clear value before
drawing. The other option is <code class="notranslate" translate="no">'load'</code> which means load the existing contents of
the texture into the GPU so we can draw over what’s already there.
<code class="notranslate" translate="no">storeOp: 'store'</code> means store the result of what we draw. We could also pass <code class="notranslate" translate="no">'discard'</code>
which would throw away what we draw. We’ll cover why we might want to do that in
<a href="webgpu-multisampling.html">another article</a>.</p>
<p>Now it’s time to render.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {
    // Get the current texture from the canvas context and
    // set it as the texture to render to.
    renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

    // make a command encoder to start encoding commands
    const encoder = device.createCommandEncoder({ label: 'our encoder' });

    // make a render pass encoder to encode render specific commands
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.draw(3);  // call our vertex shader 3 times
    pass.end();

    const commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);
  }

  render();
</pre>
<p>First, we call <code class="notranslate" translate="no">context.getCurrentTexture()</code> to get a texture that will appear in the
canvas. Calling <code class="notranslate" translate="no">createView</code> gets a view into a specific part of a texture but
with no parameters, it will return the default part which is what we want in this
case. For now, our only <code class="notranslate" translate="no">colorAttachment</code> is a texture view from our
canvas which we get via the context we created at the start. Again, element 0 of
the <code class="notranslate" translate="no">colorAttachments</code> array corresponds to <code class="notranslate" translate="no">@location(0)</code> as we specified for
the return value of the fragment shader.</p>
<p>Next, we create a command encoder. A command encoder is used to create a command
buffer. We use it to encode commands and then “submit” the command buffer it
created to have the commands executed.</p>
<p>We then use the command encoder to create a render pass encoder by calling <code class="notranslate" translate="no">beginRenderPass</code>. A render
pass encoder is a specific encoder for creating commands related to rendering.
We pass it our <code class="notranslate" translate="no">renderPassDescriptor</code> to tell it which texture we want to
render to.</p>
<p>We encode the command, <code class="notranslate" translate="no">setPipeline</code>, to set our pipeline and then tell it to
execute our vertex shader 3 times by calling <code class="notranslate" translate="no">draw</code> with 3. By default, every 3
times our vertex shader is executed a triangle will be drawn by connecting the 3
values just returned from the vertex shader.</p>
<p>We end the render pass, and then finish the encoder. This gives us a
command buffer that represents the steps we just specified. Finally, we submit
the command buffer to be executed.</p>
<p>When the <code class="notranslate" translate="no">draw</code> command is executed, this will be our state.</p>
<div class="webgpu_center"><img src="resources/webgpu-simple-triangle-diagram.svg" style="width: 723px;"></div>
<p>We’ve got no textures, no buffers, no bindGroups but we do have a pipeline, a
vertex and fragment shader, and a render pass descriptor that tells our shader
to render to the canvas texture.</p>
<p>The result.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>It’s important to emphasize that all of these functions we called
like <code class="notranslate" translate="no">setPipeline</code>, and <code class="notranslate" translate="no">draw</code> only add commands to a command buffer.
They don’t actually execute the commands. The commands are executed
when we submit the command buffer to the device queue.</p>
<p><a id="a-rasterization"></a>WebGPU takes every 3 vertices we return from our vertex shader and uses
them to rasterize a triangle. It does this by determining which pixels’
centers are inside the triangle. It then calls our fragment shader for
each pixel to ask what color to make it.</p>
<p>Imagine the texture we are rendering
to was 15x11 pixels. These are the pixels that would be drawn to</p>
<div class="webgpu_center">
  <div data-diagram="clip-space-to-texels" style="display: inline-block; max-width: 500px; width: 100%"></div>
  <div>drag the vertices</div>
</div>
<p>So, now we’ve seen a very small working WebGPU example. It should be pretty
obvious that hard coding a triangle inside a shader is not very flexible. We
need ways to provide data and we’ll cover those in the following articles. The
points to take away from the code above,</p>
<ul>
<li>WebGPU just runs shaders. It’s up to you to fill them with code to do useful things</li>
<li>Shaders are specified in a shader module and then turned into a pipeline</li>
<li>WebGPU can draw triangles</li>
<li>WebGPU draws to textures (we happened to get a texture from the canvas)</li>
<li>WebGPU works by encoding commands and then submitting them.</li>
</ul>
<h1 id="run-computations-on-the-gpu"><a id="a-run-computations-on-the-gpu"></a>Run computations on the GPU</h1>
<p>Let’s write a basic example for doing some computation on the GPU.</p>
<p>We start off with the same code to get a WebGPU device.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }
</pre>
<p>Then we create a shader module.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const module = device.createShaderModule({
    label: 'doubling compute module',
    code: `
      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        let i = id.x;
        data[i] = data[i] * 2.0;
      }
    `,
  });
</pre>
<p>First, we declare a variable called <code class="notranslate" translate="no">data</code> of type <code class="notranslate" translate="no">storage</code> that we want to be
able to both read from and write to.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;
</pre>
<p>We declare its type as <code class="notranslate" translate="no">array&lt;f32&gt;</code> which means an array of 32-bit floating point
values. We tell it we’re going to specify this array on binding location 0 (the
<code class="notranslate" translate="no">binding(0)</code>) in bindGroup 0 (the <code class="notranslate" translate="no">@group(0)</code>).</p>
<p>Then we declare a function called <code class="notranslate" translate="no">computeSomething</code> with the <code class="notranslate" translate="no">@compute</code>
attribute which makes it a compute shader.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        ...
</pre>
<p>Compute shaders are required to declare a workgroup size which we will cover
later. For now, we’ll just set it to 1 with the attribute <code class="notranslate" translate="no">@workgroup_size(1)</code>.
We declare it to have one parameter <code class="notranslate" translate="no">id</code> which uses a <code class="notranslate" translate="no">vec3u</code>. A <code class="notranslate" translate="no">vec3u</code> is
three unsigned 32-bit integer values. Like our vertex shader above, this is the
iteration number. It’s different in that compute shader iteration numbers are 3
dimensional (have 3 values). We declare <code class="notranslate" translate="no">id</code> to get its value from the built-in
<code class="notranslate" translate="no">global_invocation_id</code>.</p>
<p>You can <em>kind of</em> think of compute shaders as running like this. This is an over
simplification but it will do for now.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// pseudo code
function dispatchWorkgroups(width, height, depth) {
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const workgroup_id = {x, y, z};
        dispatchWorkgroup(workgroup_id)
      }
    }
  }
}

function dispatchWorkgroup(workgroup_id) {
  // from @workgroup_size in WGSL
  const workgroup_size = shaderCode.workgroup_size;
  const {x: width, y: height, z: depth} = workgroup_size;
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const local_invocation_id = {x, y, z};
        const global_invocation_id =
            workgroup_id * workgroup_size + local_invocation_id;
        computeShader(global_invocation_id)
      }
    }
  }
}
</pre>
<p>Since we set <code class="notranslate" translate="no">@workgroup_size(1)</code>, effectively the pseudo-code above becomes:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// pseudo code
function dispatchWorkgroups(width, height, depth) {
  for (z = 0; z &lt; depth; ++z) {
    for (y = 0; y &lt; height; ++y) {
      for (x = 0; x &lt; width; ++x) {
        const workgroup_id = {x, y, z};
        dispatchWorkgroup(workgroup_id)
      }
    }
  }
}

function dispatchWorkgroup(workgroup_id) {
  const global_invocation_id = workgroup_id;
  computeShader(global_invocation_id)
}
</pre>
<p>Finally, we use the <code class="notranslate" translate="no">x</code> property of <code class="notranslate" translate="no">id</code> to index <code class="notranslate" translate="no">data</code> and multiply each value
by 2.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">        let i = id.x;
        data[i] = data[i] * 2.0;
</pre>
<p>Above, <code class="notranslate" translate="no">i</code> is just the first of the 3 iteration numbers.</p>
<p>Now that we’ve created the shader, we need to create a pipeline.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createComputePipeline({
    label: 'doubling compute pipeline',
    layout: 'auto',
    compute: {
      module,
    },
  });
</pre>
<p>Here we just tell it we’re using a <code class="notranslate" translate="no">compute</code> stage from the shader <code class="notranslate" translate="no">module</code> we
created and since there is only one <code class="notranslate" translate="no">@compute</code> entry point WebGPU knows we want to call it. <code class="notranslate" translate="no">layout</code> is
<code class="notranslate" translate="no">'auto'</code> again, telling WebGPU to figure out the layout from the shaders. <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>
<p>Next, we need some data.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const input = new Float32Array([1, 3, 5]);
</pre>
<p>That data only exists in JavaScript. For WebGPU to use it, we need to make a
buffer that exists on the GPU and copy the data to the buffer.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // create a buffer on the GPU to hold our computation
  // input and output
  const workBuffer = device.createBuffer({
    label: 'work buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  // Copy our input data to that buffer
  device.queue.writeBuffer(workBuffer, 0, input);
</pre>
<p>Above, we call <code class="notranslate" translate="no">device.createBuffer</code> to create a buffer. <code class="notranslate" translate="no">size</code> is the size in
bytes. In this case, it will be 12 because the size in bytes of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> of 3
values is 12. If you’re not familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> and typed arrays then
see <a href="webgpu-memory-layout.html">this article</a>.</p>
<p>Every WebGPU buffer we create has to specify a <code class="notranslate" translate="no">usage</code>. There are a bunch of
flags we can pass for usage but not all of them can be used together. Here we
say we want this buffer to be usable as <code class="notranslate" translate="no">storage</code> by passing
<code class="notranslate" translate="no">GPUBufferUsage.STORAGE</code>. This makes it compatible with <code class="notranslate" translate="no">var&lt;storage,...&gt;</code> from
the shader. Further, we want to be able to copy data to this buffer so we include
the <code class="notranslate" translate="no">GPUBufferUsage.COPY_DST</code> flag. And finally, we want to be able to copy data
from the buffer so we include <code class="notranslate" translate="no">GPUBufferUsage.COPY_SRC</code>.</p>
<p>Note that you can not directly read the contents of a WebGPU buffer from
JavaScript. Instead, you have to “map” it which is another way of requesting
access to the buffer from WebGPU because the buffer might be in use and because
it might only exist on the GPU.</p>
<p>WebGPU buffers that can be mapped in JavaScript can’t be used for much else. In
other words, we can not map the buffer we just created above and if we try to add
the flag to make it mappable, we’ll get an error that it is not compatible with
usage <code class="notranslate" translate="no">STORAGE</code>.</p>
<p>So, in order to see the result of our computation, we’ll need another buffer.
After running the computation, we’ll copy the buffer above to this result buffer
and set its flags so we can map it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // create a buffer on the GPU to get a copy of the results
  const resultBuffer = device.createBuffer({
    label: 'result buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });
</pre>
<p><code class="notranslate" translate="no">MAP_READ</code> means we want to be able to map this buffer for reading data.</p>
<p>In order to tell our shader about the buffer we want it to work on, we need to
create a bindGroup.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Setup a bindGroup to tell the shader which
  // buffer to use for the computation
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: workBuffer } },
    ],
  });
</pre>
<p>We get the layout for the bindGroup from the pipeline. Then we set up bindGroup
entries. The 0 in <code class="notranslate" translate="no">pipeline.getBindGroupLayout(0)</code> corresponds to the
<code class="notranslate" translate="no">@group(0)</code> in the shader. The <code class="notranslate" translate="no">{binding: 0 ...</code> of the <code class="notranslate" translate="no">entries</code> corresponds to
the <code class="notranslate" translate="no">@group(0) @binding(0)</code> in the shader.</p>
<p>Now we can start encoding commands.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Encode commands to do the computation
  const encoder = device.createCommandEncoder({
    label: 'doubling encoder',
  });
  const pass = encoder.beginComputePass({
    label: 'doubling compute pass',
  });
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(input.length);
  pass.end();
</pre>
<p>We create a command encoder. We start a compute pass. We set the pipeline, then
we set the bindGroup. Here, the <code class="notranslate" translate="no">0</code> in <code class="notranslate" translate="no">pass.setBindGroup(0, bindGroup)</code>
corresponds to <code class="notranslate" translate="no">@group(0)</code> in the shader. We then call <code class="notranslate" translate="no">dispatchWorkgroups</code> and in
this case, we pass it <code class="notranslate" translate="no">input.length</code> which is <code class="notranslate" translate="no">3</code> telling WebGPU to run the
compute shader 3 times. We then end the pass.</p>
<p>Here’s what the situation will be when <code class="notranslate" translate="no">dispatchWorkgroups</code> is executed.</p>
<div class="webgpu_center"><img src="resources/webgpu-simple-compute-diagram.svg" style="width: 553px;"></div>
<p>After the computation is finished we ask WebGPU to copy from <code class="notranslate" translate="no">workBuffer</code> to
<code class="notranslate" translate="no">resultBuffer</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Encode a command to copy the results to a mappable buffer.
  encoder.copyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.size);
</pre>
<p>Now we can <code class="notranslate" translate="no">finish</code> the encoder to get a command buffer and then submit that
command buffer.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Finish encoding and submit the commands
  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);
</pre>
<p>We then map the results buffer and get a copy of the data.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Read the results
  await resultBuffer.mapAsync(GPUMapMode.READ);
  const result = new Float32Array(resultBuffer.getMappedRange());

  console.log('input', input);
  console.log('result', result);

  resultBuffer.unmap();
</pre>
<p>To map the results buffer, we call <code class="notranslate" translate="no">mapAsync</code> and have to <code class="notranslate" translate="no">await</code> for it to
finish. Once mapped, we can call <code class="notranslate" translate="no">resultBuffer.getMappedRange()</code> which with no
parameters will return an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> of the entire buffer. We put that in a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array"><code class="notranslate" translate="no">Float32Array</code></a> typed array view and then we can look at the values. One
important detail, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code class="notranslate" translate="no">ArrayBuffer</code></a> returned by <code class="notranslate" translate="no">getMappedRange</code> is only valid
until we call <code class="notranslate" translate="no">unmap</code>. After <code class="notranslate" translate="no">unmap</code>, its length will be set to 0 and its data
no longer accessible.</p>
<p>Running that we can see we got the result back, all the numbers have been
doubled.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-compute.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-compute.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>We’ll cover how to really use compute shaders in other articles. For now, you
hopefully have gleaned some understanding of what WebGPU does. EVERYTHING ELSE
IS UP TO YOU! Think of WebGPU as similar to other programming languages. It
provides a few basic features and leaves the rest to your creativity.</p>
<p>What makes WebGPU programming special is these functions, vertex shaders,
fragment shaders, and compute shaders, run on your GPU. A GPU could have over
10000 processors which means they can potentially do more than 10000
calculations in parallel which is likely 3 or more orders of magnitude than your
CPU can do in parallel.</p>
<h2 id="simple-canvas-resizing"><a id="a-resizing"></a> Simple Canvas Resizing</h2>
<p>Before we move on, let’s go back to our triangle drawing example and add some
basic support for resizing a canvas. Sizing a canvas is actually a topic that
can have many subtleties so <a href="webgpu-resizing-the-canvas.html">there is an entire article on it</a>.
For now though let’s just add some basic support.</p>
<p>First, we’ll add some CSS to make our canvas fill the page.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;style&gt;
html, body {
  margin: 0;       /* remove the default margin          */
  height: 100%;    /* make the html,body fill the page   */
}
canvas {
  display: block;  /* make the canvas act like a block   */
  width: 100%;     /* make the canvas fill its container */
  height: 100%;
}
&lt;/style&gt;
</pre>
<p>That CSS alone will make the canvas get displayed to cover the page but it won’t change
the resolution of the canvas itself so you might notice, if you make the example below
large, like if you click the full-screen button, you’ll see the edges of the triangle
are blocky.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-with-canvas-css.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-with-canvas-css.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p><code class="notranslate" translate="no">&lt;canvas&gt;</code> tags, by default, have a resolution of 300x150 pixels. We’d like to
adjust the resolution of the canvas to match the size it is displayed.
One good way to do this is with a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a>. You create a
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> and give it a function to call whenever the elements you’ve
asked it to observe change their size. You then tell it which elements to
observe.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    ...
-    render();

+    const observer = new ResizeObserver(entries =&gt; {
+      for (const entry of entries) {
+        const canvas = entry.target;
+        const width = entry.contentBoxSize[0].inlineSize;
+        const height = entry.contentBoxSize[0].blockSize;
+        canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
+        canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
+      }
+      // re-render
+      render();
+    });
+    observer.observe(canvas);
</pre>
<p>In the code above, we go over all the entries but there should only ever be one
because we’re only observing our canvas. We need to limit the size of the canvas
to the largest size our device supports otherwise WebGPU will start generating
errors that we tried to make a texture that is too large. We also need to make
sure it doesn’t go to zero or again we’ll get errors.
<a href="webgpu-resizing-the-canvas.html">See the longer article for details</a>.</p>
<p>We call <code class="notranslate" translate="no">render</code> to re-render the
triangle at the new resolution. We removed the old call to <code class="notranslate" translate="no">render</code> because
it’s not needed. A <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code class="notranslate" translate="no">ResizeObserver</code></a> will always call its callback at least once
to report the size of the elements when they started being observed.</p>
<p>The new size texture is created when we call <code class="notranslate" translate="no">context.getCurrentTexture()</code>
inside <code class="notranslate" translate="no">render</code> so there’s nothing left to do.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-simple-triangle-with-canvas-resize.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-simple-triangle-with-canvas-resize.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<blockquote>
<p>Note: The code above does not handle responding to zoom which may change
the resolution of the canvas. It also doesn’t deal with higher resolutions
for high-res displays. For those issues, see
<a href="webgpu-reszing-the-canvas.html">the article on resizing the canvas</a>.</p>
</blockquote>
<p>In the following articles, we’ll cover various ways to pass data into shaders.</p>
<ul>
<li><a href="webgpu-inter-stage-variables.html">inter-stage variables</a></li>
<li><a href="webgpu-uniforms.html">uniforms</a></li>
<li><a href="webgpu-storage-buffers.html">storage buffers</a></li>
<li><a href="webgpu-vertex-buffers.html">vertex buffers</a></li>
<li><a href="webgpu-textures.html">textures</a></li>
<li><a href="webgpu-constants.html">constants</a></li>
</ul>
<p>Then we’ll cover <a href="webgpu-wgsl.html">the basics of WGSL</a>.</p>
<p>This order is from the simplest to the most complex. Inter-stage variables
require no external setup to explain. We can see how to use them using nothing
but changes to the WGSL we used above. Uniforms are effectively global variables
and as such are used in all 3 kinds of shaders (vertex, fragment, and compute).
Going from uniform buffers to storage buffers is trivial as shown at the top of
the article on storage buffers. Vertex buffers are only used in vertex shaders.
They are more complex because they require describing the data layout to WebGPU.
Textures are the most complex as they have tons of types and options.</p>
<p>I’m a little bit worried these articles will be boring at first. Feel free to
jump around if you’d like. Just remember if you don’t understand something you
probably need to read or review these basics. Once we get the basics down, we’ll
start going over actual techniques.</p>
<p>One other thing. All of the example programs can be edited live in the webpage.
Further, they can all easily be exported to <a href="https://jsfiddle.net">jsfiddle</a> and <a href="https://codepen.io">codepen</a>
and even <a href="https://stackoverflow.com">stackoverflow</a>. Just click “Export”.</p>
<div class="webgpu_bottombar">
<p>
The code above gets a WebGPU device in a very terse way. A more verbose
way would be something like
</p>
<pre class="prettyprint showmods">async function start() {
  if (!navigator.gpu) {
    fail('this browser does not support WebGPU');
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    fail('this browser supports webgpu but it appears disabled');
    return;
  }

  const device = await adapter.requestDevice();
  device.lost.then((info) =&gt; {
    console.error(`WebGPU device was lost: ${info.message}`);

    // 'reason' will be 'destroyed' if we intentionally destroy the device.
    if (info.reason !== 'destroyed') {
      // try again
      start();
    }
  });
  
  main(device);
}
start();

function main(device) {
  ... do webgpu ...
}
</pre>
<p>
<code class="notranslate" translate="no">device.lost</code> is a promise that starts off unresolved. It will resolve if and when the
device is lost. A device can be lost for many reasons. Maybe the user ran a really intensive
app and it crashed their GPU. Maybe the user updated their drivers. Maybe the user has
an external GPU and unplugged it. Maybe another page used a lot of GPU, your
tab was in the background and the browser decided to free up some memory by
losing the device for background tabs. The point to take away is that for any serious
apps you probably want to handle losing the device.
</p>
<p>
Note that <code class="notranslate" translate="no">requestDevice</code> always returns a device. It just might start lost.
WebGPU is designed so that, for the most part, the device will appear to work,
at least from an API level. Calls to create things and use them will appear
to succeed but they won't actually function. It's up to you to take action
when the <code class="notranslate" translate="no">lost</code> promise resolves.
</p>
</div>
<!-- keep this at the bottom of the article -->
<script type="module" src="webgpu-fundamentals.js"></script>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>There are actually 5 modes.</p>
<ul>
<li><code class="notranslate" translate="no">'point-list'</code>: for each position, draw a point</li>
<li><code class="notranslate" translate="no">'line-list'</code>: for each 2 positions, draw a line</li>
<li><code class="notranslate" translate="no">'line-strip'</code>: draw lines connecting the newest point to the previous point</li>
<li><code class="notranslate" translate="no">'triangle-list'</code>: for each 3 positions, draw a triangle (<strong>default</strong>)</li>
<li><code class="notranslate" translate="no">'triangle-strip'</code>: for each new position, draw a triangle from it and the last 2 positions</li>
</ul>
 <a href="#fnref1" class="footnote-backref">↩︎</a></li>
<li id="fn2" class="footnote-item"><p>Fragment shaders indirectly write data to textures. That data does not
have to be colors. For example, it’s common to output the direction of the surface that
pixel represents. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Textures can also be 3D rectangles of pixels, cube maps (6 squares of pixels
that form a cube), and a few other things but the most common textures are 2D rectangles of pixels. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>We can also use an index buffer to specify <code class="notranslate" translate="no">vertex_index</code>.
This is covered in <a href="webgpu-vertex-buffers.html#a-index-buffers">the article on vertex-buffers</a>. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><code class="notranslate" translate="no">layout: 'auto'</code> is convenient but it’s impossible to share bind groups
across pipelines using <code class="notranslate" translate="no">layout: 'auto'</code>. Most of the examples on this site
never use a bind group with multiple pipelines. We’ll cover explicit layouts in <a href="webgpu-bind-group-layouts.html">another article</a>. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-fundamentals.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-fundamentals.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-fundamentals.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-fundamentals.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-fundamentals.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-fundamentals.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-fundamentals.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-fundamentals.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Fundamentals`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>