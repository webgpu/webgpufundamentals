<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-bind-group-layouts.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Explicit Bind Group Layouts">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_en.jpg">

<meta property="og:title" content="WebGPU Bind Group Layouts">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_en.jpg">
<meta property="og:description" content="Explicit Bind Group Layouts">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Bind Group Layouts">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html">
<meta name="twitter:description" content="Explicit Bind Group Layouts">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-bind-group-layouts_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html",
      "inLanguage":"en",
      "name":"WebGPU Bind Group Layouts",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Bind Group Layouts</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-bind-group-layouts.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-bind-group-layouts.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-bind-group-layouts.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-bind-group-layouts.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-bind-group-layouts.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Bind Group Layouts</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Bind Group Layouts are used to make it easy and efficient
for WebGPU to match Bind Groups to Compute and Render Pipelines.</p>
<h2 id="how-it-works">How it works:</h2>
<p>A Pipeline, like a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUComputePipeline"><code class="notranslate" translate="no">GPUComputePipeline</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPURenderPipeline"><code class="notranslate" translate="no">GPURenderPipeline</code></a>
uses a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a> which defines 0 or more
<a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>s. Each <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a> is assigned
to a specific group index.</p>
<div class="webgpu_center"><img src="resources/webgpu-bind-group-layouts.svg" style="width: 900px;"></div>
<p>Bind Groups are each created with a specific <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>
as well.</p>
<p>When you go to <code class="notranslate" translate="no">draw</code> or to <code class="notranslate" translate="no">dispatchWorkgroups</code>, WebGPU only
needs to check, does the <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a> for each group index
on the current pipeline’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a> match the
currently bound bind groups, the ones set with <code class="notranslate" translate="no">setBindGroup</code>.
This check is trivially simple. Most of the detailed checking
happens when you create the bind group. That way, when you’re
actually drawing or computing, there’s almost nothing left to
check.</p>
<p>Pipelines will generate their own <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a> and
populate it with <code class="notranslate" translate="no">GPUBindGroupLayouts</code> automatically if you
create the pipeline with <code class="notranslate" translate="no">layout: 'auto'</code> which is what
most of the samples on this website do.</p>
<p>There are 2 main reasons to <strong>NOT</strong> use <code class="notranslate" translate="no">layout: 'auto'</code>.</p>
<ol>
<li>
<p><strong>You want a layout that’s different than the default <code class="notranslate" translate="no">'auto'</code> layout</strong></p>
<p>For example you want to use a <code class="notranslate" translate="no">rgba32float</code> as a texture
but you get an error when you try. (see below)</p>
</li>
<li>
<p><strong>You want to use a bind group with more than 1 pipeline</strong></p>
<p>You can not use a bind group made from a bindGroupLayout
that was made from a pipeline with <code class="notranslate" translate="no">layout: 'auto'</code> with a
different pipeline.</p>
</li>
</ol>
<h2 id="using-a-bind-group-layout-different-than-layout-auto---rgba32float"><a id="a-rgba32float"></a> Using a bind group layout different than <code class="notranslate" translate="no">layout: 'auto'</code> - <code class="notranslate" translate="no">'rgba32float'</code></h2>
<p>The rules for how a bind group layout is automatically created are
<a href="https://www.w3.org/TR/webgpu/#abstract-opdef-default-pipeline-layout">detailed in the spec</a>, but, as one example…</p>
<p>Let’s say we want to use an <code class="notranslate" translate="no">rgba32float</code> texture. Let’s take
<a href="http://localhost:8080/webgpu/lessons/webgpu-textures.html">our first example of using a texture from the article on textures</a> which drew an upside down 5x7 texel ‘F’.  Let’s update it to use an <code class="notranslate" translate="no">rgba32float</code> texture.</p>
<p>Here are the changes.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const kTextureWidth = 5;
  const kTextureHeight = 7;
-  const _ = [255,   0,   0, 255];  // red
-  const y = [255, 255,   0, 255];  // yellow
-  const b = [  0,   0, 255, 255];  // blue
-  const textureData = new Uint8Array([
+  const _ = [1, 0, 0, 1];  // red
+  const y = [1, 1, 0, 1];  // yellow
+  const b = [0, 0, 1, 1];  // blue
+  const textureData = new Float32Array([
    b, _, _, _, _,
    _, y, y, y, _,
    _, y, _, _, _,
    _, y, y, _, _,
    _, y, _, _, _,
    _, y, _, _, _,
    _, _, _, _, _,
  ].flat());

  const texture = device.createTexture({
    label: 'yellow F on red',
    size: [kTextureWidth, kTextureHeight],
-    format: 'rgba8unorm',
+    format: 'rgba32float',
    usage:
      GPUTextureUsage.TEXTURE_BINDING |
      GPUTextureUsage.COPY_DST,
  });
  device.queue.writeTexture(
      { texture },
      textureData,
-      { bytesPerRow: kTextureWidth * 4 },
+      { bytesPerRow: kTextureWidth * 4 * 4 },
      { width: kTextureWidth, height: kTextureHeight },
  );

</pre>
<p>When we run it we’ll get an error.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-rgba32float-broken.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-rgba32float-broken.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>The error I got in the browser I tested in was:</p>
<blockquote>
<ul>
<li>WebGPU GPUValidationError: None of the supported sample types (UnfilterableFloat) of [Texture “yellow F on red”] match the expected sample types (Float).`<br></li>
<li>While validating entries[1] as a Sampled Texture. Expected entry layout: {sampleType: TextureSampleType::Float, viewDimension: 2, multisampled: 0}`<br></li>
<li>While validating [BindGroupDescriptor] against [BindGroupLayout (unlabeled)]`<br></li>
<li>While calling [Device].CreateBindGroup([BindGroupDescriptor])`</li>
</ul>
</blockquote>
<p>What’s up with that? It turns out that <code class="notranslate" translate="no">rgba32float</code> (and all <code class="notranslate" translate="no">xxx32float</code>)
textures are not filterable by default. There is an <a href="webgpu-limits-and-features.html">optional feature</a> to make them filterable but, that
feature might not be available everywhere. This is especially likely on
mobile devices, at least in 2024.</p>
<p>By default, when you declare a binding with a <code class="notranslate" translate="no">texture_2d&lt;f32&gt;</code> like
this:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">      @group(0) @binding(1) var ourTexture: texture_2d&lt;f32&gt;;
</pre>
<p>And you use <code class="notranslate" translate="no">layout: 'auto'</code> when creating your pipeline, WebGPU creates
a bind group layout that specifically requires filterable textures. If
you try to bind an unfilterable one you get an error.</p>
<p>If you want to use a texture that can not be filtered then you’ll need
to manually create a bind group layout.</p>
<p>There’s a tool, <a href="resources/wgsl-offset-computer.html">here</a>, that if you
paste your shaders, it will generate the auto layout for you. Pasting
in the shader from the example above it gives me</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayoutDescriptors = [
  {
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
          type: "filtering",
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false,
        },
      },
    ],
  },
];
</pre>
<p>This is an array of <a href="https://www.w3.org/TR/webgpu/#dictdef-gpubindgrouplayoutdescriptor"><code class="notranslate" translate="no">GPUBindGroupLayoutDescriptor</code></a>s. Above you can
see the bind group uses <code class="notranslate" translate="no">sampleType: "float"</code>. That’s the type for
<code class="notranslate" translate="no">'rgba8unorm'</code> but it’s not the type for <code class="notranslate" translate="no">'rgba32float'</code>. You can read
the sample types a particular texture format works with in
<a href="https://www.w3.org/TR/webgpu/#texture-format-caps">this table in the spec</a>.</p>
<p>To fix the example we need to adjust both the texture binding and the
sampler binding. The sampler binding needs to be changed into a
<code class="notranslate" translate="no">'non-filtering'</code> sampler. The texture binding needs to be changed to
an <code class="notranslate" translate="no">'unfilterable-float'</code>.</p>
<p>So, first, we need to create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
*          type: 'non-filtering',
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
*          sampleType: 'unfilterable-float',
          viewDimension: '2d',
          multisampled: false,
        },
      },
    ],
  });
</pre>
<p>The two changes are marked above.</p>
<p>Then we need to create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a> which is an array
of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>s used by a pipeline.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });
</pre>
<p><code class="notranslate" translate="no">createPipelineLayout</code> takes an object with an array of <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a>s.
They are ordered by group index so the first entry becomes <code class="notranslate" translate="no">@group(0)</code>,
the 2nd entry becomes <code class="notranslate" translate="no">@group(1)</code>, etc… If you need
to skip one you’ll need to add an empty bind group layout.</p>
<p>Finally, when we create the pipeline, we pass in the pipeline layout</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'hardcoded textured quad pipeline',
-    layout: 'auto',
+    layout: pipelineLayout,
    vertex: {
      module,
    },
    fragment: {
      module,
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>With that, our example works again but now it’s using an <code class="notranslate" translate="no">rgba32float</code>
texture.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-rgba32float-fixed.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-rgba32float-fixed.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Note: the example works both because we did the work above to make
a bind group layout that accepted unfilterable-float but it also happens
to work because the example uses a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUSampler"><code class="notranslate" translate="no">GPUSampler</code></a> using only <code class="notranslate" translate="no">'nearest'</code>
filtering. If we set any of the filters, <code class="notranslate" translate="no">magFilter</code>, <code class="notranslate" translate="no">minFilter</code> or
<code class="notranslate" translate="no">mipmapFilter</code> to <code class="notranslate" translate="no">'linear'</code> we’d get an error saying that we tried
to use a <code class="notranslate" translate="no">'filtering'</code> sampler on a <code class="notranslate" translate="no">'non-filtering'</code> sampler binding.</p>
<h2 id="using-a-bind-group-layout-different-than-layout-auto---dynamic-offsets">Using a bind group layout different than <code class="notranslate" translate="no">layout: 'auto'</code> - dynamic offsets</h2>
<p>By default, when you make a bind group and you bind a uniform or storage buffer, the entire buffer is bound. You can also pass in an offset and length when creating your bind group. In both cases, once set, they can not
be changed.</p>
<p>WebGPU has an option to let you change the offset when you call
<code class="notranslate" translate="no">setBindGroup</code>. To use this feature, you have to manually create bind group
layouts and set <code class="notranslate" translate="no">hasDynamicOffsets: true</code> for each binding you want to be
able to set later.</p>
<p>To keep this simple, let’s use the simple compute example
from <a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">the article on fundamentals</a>. We’ll modify it to add
2 sets of values from the same buffer and we’ll choose which
set using dynamic offsets.</p>
<p>First lets change the shader to this</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@group(0) @binding(0) var&lt;storage, read_write&gt; a: array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; b: array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; dst: array&lt;f32&gt;;

@compute @workgroup_size(1) fn computeSomething(
  @builtin(global_invocation_id) id: vec3u
) {
  let i = id.x;
  dst[i] = a[i] + b[i];
}
</pre>
<p>you can see it just adds <code class="notranslate" translate="no">a</code> to <code class="notranslate" translate="no">b</code> and writes into <code class="notranslate" translate="no">dst</code>.</p>
<p>Next let’s make the bind group layout</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
      {
        binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
      {
        binding: 2,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          hasDynamicOffset: true,
        },
      },
    ],
  });
</pre>
<p>All of them are marked as <code class="notranslate" translate="no">hasDynamicStorage: true</code></p>
<p>now let’s use it to create our pipeline</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });

  const pipeline = device.createComputePipeline({
-    label: 'double compute pipeline',
-    layout: 'auto',
+    label: 'add elements compute pipeline',
+    layout: pipelineLayout,
    compute: {
      module,
    },
  });
</pre>
<p>Let’s setup the buffer. Offset must be a multiple of 256 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> so, let’s create a buffer
256 * 3 bytes large so we have at least 3 valid offsets, 0, 256, and 512.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const input = new Float32Array([1, 3, 5]);
+  const input = new Float32Array(64 * 3);
+  input.set([1, 3, 5]);
+  input.set([11, 12, 13], 64);

  // create a buffer on the GPU to hold our computation
  // input and output
  const workBuffer = device.createBuffer({
    label: 'work buffer',
    size: input.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  // Copy our input data to that buffer
  device.queue.writeBuffer(workBuffer, 0, input);
</pre>
<p>The code above makes an array of <code class="notranslate" translate="no">64 * 3</code> 32bit floats. That’s 768 bytes.</p>
<p>Since our original example read and wrote to the same buffer
we’ll just bind the same buffer 3 times.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Setup a bindGroup to tell the shader which
  // buffers to use for the computation
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
-      { binding: 0, resource: { buffer: workBuffer } },
+      { binding: 0, resource: { buffer: workBuffer, size: 256 } },
+      { binding: 1, resource: { buffer: workBuffer, size: 256 } },
+      { binding: 2, resource: { buffer: workBuffer, size: 256 } },
    ],
  });
</pre>
<p>Note, we must specify the size, otherwise it will default to the size
of the entire buffer. If we were to then set an offset &gt; 0 we’d get an
error since we’d be specifying a portion of the buffer that’s out of range.</p>
<p>In <code class="notranslate" translate="no">setBindGroup</code> we now pass in 1 offset for each buffer that has dynamic offsets. Since we marked all 3 entries in the bind group layout as
<code class="notranslate" translate="no">hasDynamicOffset: true</code> we need 3 offsets in the order of their binding slot.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  ...
  pass.setPipeline(pipeline);
-  pass.setBindGroup(0, bindGroup);
+  pass.setBindGroup(0, bindGroup, [0, 256, 512]);
  pass.dispatchWorkgroups(3);
  pass.end();
</pre>
<p>Finally, we need to change the code to show the result</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  console.log(input);
-  console.log(result);
+  console.log('a', input.slice(0, 3));
+  console.log('b', input.slice(64, 64 + 3));
+  console.log('dst', result.slice(128, 128 + 3));
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-dynamic-offsets.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-dynamic-offsets.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Note that, using dynamic offsets is slightly slower than non-dynamic offsets. The reason is, with non-dynamic offsets, whether the offset and size are in range of the buffer is checked when you create the bind group. With dynamic offsets, that check can not be made until you call <code class="notranslate" translate="no">setBindGroup</code>. If you’re only calling <code class="notranslate" translate="no">setBindGroup</code> a few hundred times
that difference probably won’t matter. If you’re calling <code class="notranslate" translate="no">setBindGroup</code>
1000s of times it might be more noticeable.</p>
<h2 id="using-a-bind-group-with-more-than-1-pipeline"><a id="a-sharing-bind-groups"></a> Using a bind group with more than 1 pipeline</h2>
<p>Another reason to create bind group layouts manually is so we
can use the same bind group with more than one pipeline.</p>
<p>A common places you might want to be able to reuse a bind group is in a basic 3d scene renderer with shadows.</p>
<p>In a basic 3d scene renderer it’s common to separate bindings
into</p>
<ul>
<li>globals (like the perspective and view matrices)</li>
<li>materials (the textures, colors)</li>
<li>locals (like the model matrix)</li>
</ul>
<p>You then render like this</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">setBindGroup(0, globalsBG)
for each material
  setBindGroup(1, materialBG)
  for each object that uses material
    setBindGroup(2, localBG)
    draw(...)
</pre>
<p>When you add <a href="webgpu-shadows.html">shadows</a>, you need to first
draw the shadow maps with a shadow map pipeline. Rather than
having separate bind groups of all of those things, ones to work
with the pipeline that draws and different bind groups to work
with the pipeline that renders the shadow map, it would be much
easier to just make one set of bind groups and use the same ones
for both cases.</p>
<p>That’s a rather large sample to write, just to show off sharing
bind groups. Although, <a href="webgpu-shadows.html">the article on shadows</a>
uses shared bind groups we’ll take the simple compute example from <a href="webgpu-fundamentals.html#a-run-computations-on-the-gpu">the article on fundamentals</a> again and make it use 2 compute pipelines with one bind group.</p>
<p>First let’s add another shader module that adds 3</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const module = device.createShaderModule({
+  const moduleTimes2 = device.createShaderModule({
    label: 'doubling compute module',
    code: `
      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;

      @compute @workgroup_size(1) fn computeSomething(
        @builtin(global_invocation_id) id: vec3u
      ) {
        let i = id.x;
        data[i] = data[i] * 2.0;
      }
    `,
  });

+  const modulePlus3 = device.createShaderModule({
+    label: 'adding 3 compute module',
+    code: `
+      @group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;
+
+      @compute @workgroup_size(1) fn computeSomething(
+        @builtin(global_invocation_id) id: vec3u
+      ) {
+        let i = id.x;
+        data[i] = data[i] + 3.0;
+      }
+    `,
+  });
</pre>
<p>Then let’s create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout"><code class="notranslate" translate="no">GPUPipelineLayout</code></a>
we can use to make the 2 pipelines share the same <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroup"><code class="notranslate" translate="no">GPUBindGroup</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: 'storage',
          minBindingSize: 0,
        },
      },
    ],
  });

  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [ bindGroupLayout ],
  });
</pre>
<p>Now let’s use them when creating the pipelines.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const pipeline = device.createComputePipeline({
+  const pipelineTimes2 = device.createComputePipeline({
    label: 'doubling compute pipeline',
-    layout: 'auto',
+    layout: pipelineLayout,
    compute: {
      module: moduleTimes2,
    },
  });

+  const pipelinePlus3 = device.createComputePipeline({
+    label: 'plus 3 compute pipeline',
+    layout: pipelineLayout,
+    compute: {
+      module: modulePlus3,
+    },
+  });
</pre>
<p>When we setup the bind group, let’s use the <code class="notranslate" translate="no">bindGroupLayout</code>
directly</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Setup a bindGroup to tell the shader which
  // buffer to use for the computation
  const bindGroup = device.createBindGroup({
    label: 'bindGroup for work buffer',
-    layout: pipeline.getBindGroupLayout(0),
+    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: workBuffer } },
    ],
  });
</pre>
<p>Finally let’s use both pipelines</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  // Encode commands to do the computation
  const encoder = device.createCommandEncoder();
  const pass = encoder.beginComputePass();
-  pass.setPipeline(pipeline);
+  pass.setPipeline(pipelineTimes2);
  pass.setBindGroup(0, bindGroup);
  pass.dispatchWorkgroups(input.length);
+  pass.setPipeline(pipelinePlus3);
+  pass.dispatchWorkgroups(input.length);
  pass.end();
</pre>
<p>The result is we multiply by 2 and add 3 with one bind group.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-bind-group-layouts-multiple-pipelines.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-bind-group-layouts-multiple-pipelines.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Not very exciting but at least it’s a working and simple example.</p>
<p>When to manually make bind group layouts and when to not is really up
to you. In the example above it would arguably have been easier to
just make 2 bind groups, 1 for each pipeline.</p>
<p>For simple situations it’s often not necessary to manually make bind group layouts but, as your
WebGPU programs get more complex, it’s likely making bind group layouts
will be a technique you reach for.</p>
<h2 id="bind-group-layout-notes"><a id="a-bind-group-layout-notes"></a> Bind Group Layout notes:</h2>
<p>Some things to note about creating a <a href="https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout"><code class="notranslate" translate="no">GPUBindGroupLayout</code></a></p>
<ul>
<li>
<h2 id="each-entry-must-declare-which-binding-it-is-for">Each entry must declare which <code class="notranslate" translate="no">binding</code> it is for</h2>
</li>
<li>
<h2 id="each-entry-must-declare-which-stages-it-will-be-visible-in">Each entry must declare which stages it will be visible in.</h2>
<p>In our examples above we declared just one visibility.
If, for example, we wanted to reference the bind group both
the vertex and the fragment shader we’d use:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX
</pre>
<p>or all 3 stages:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">   visibility: GPUShaderStage.COMPUTE |
               GPUShaderStage.FRAGMENT | 
               GPUShaderStage.VERTEX
</pre>
</li>
<li>
<h2 id="there-are-several-defaults">There are several defaults:</h2>
<p>For <code class="notranslate" translate="no">texture:</code> bindings the defaults are:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  sampleType: 'float',
  viewDimension: '2d',
  multisampled: false,
}
</pre>
<p>For a <code class="notranslate" translate="no">sampler:</code> bindings the defaults are:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  type: 'filtering',
}
</pre>
<p>That means, in the most common sampler and texture usages, you could declare
the sampler and texture entries like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayout = device.createBindGroupLayout({
  entries: [
    {
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {},  // use the defaults
    },
    {
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {},  // use the defaults
    },
  ],
});
</pre>
</li>
<li>
<h2 id="buffer-entries-should-declare-a-minbindingsize-when-possible">buffer entries should declare a <code class="notranslate" translate="no">minBindingSize</code> when possible.</h2>
<p>When you declare a buffer binding you can specify a <code class="notranslate" translate="no">minBindingSize</code>.</p>
<p>A good example might be you make a struct for uniforms. For example
in <a href="webgpu-uniforms.html">the article on uniforms</a> we had this struct:</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  scale: vec2f,
  offset: vec2f,
};

@group(0) @binding(0) var&lt;uniform&gt; ourStruct: OurStruct;
</pre>
<p>It requires 32 bytes so, we should declare it’s <code class="notranslate" translate="no">minBindingSize</code> like
this:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const bindGroupLayout = device.createBindGroupLayout({
  entries: [
    {
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: 'uniform',
        minBindingSize: 32,
      },
    },
  ],
});
</pre>
<p>The reason to declare a <code class="notranslate" translate="no">minBindingSize</code> is it lets WebGPU check
if your buffer size/offset is the correct size when you call
<code class="notranslate" translate="no">createBindGroup</code>.  If you don’t set a <code class="notranslate" translate="no">minBindingSize</code>, then
WebGPU will have to check at draw/dispatchWorkgroups time that
the buffer is the correct size of the pipeline. Checking every
draw calls is slower than checking once when you create a bind
group.</p>
<p>On the the other hand, in our example above that used a storage
buffer to double numbers etc, we didn’t declare a <code class="notranslate" translate="no">minBindingSize</code>.
That’s because, since the storage buffer is declared as an <code class="notranslate" translate="no">array</code>,
are able to bind different size buffers depending on how
many values you pass in.</p>
</li>
</ul>
<p><a href="https://www.w3.org/TR/webgpu/#dictdef-gpubindgrouplayoutentry">This part of the spec</a> details all the options for making
bind group layouts.</p>
<p><a href="https://toji.dev/webgpu-best-practices/bind-groups">This article</a> also
has some advice on bind groups and bind group layouts.</p>
<p><a href="https://greggman.github.io/webgpu-utils">This Library</a> will compute
struct sizes and default bind group layouts for you.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>It’s possible your device
supports smaller offsets. See the <code class="notranslate" translate="no">minStorageBufferOffsetAlignment</code>
or <code class="notranslate" translate="no">minUniformBufferOffsetAlignment</code> in <a href="webgpu-limits-and-features.html">limits and features</a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-bind-group-layouts.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-bind-group-layouts.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-bind-group-layouts.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-bind-group-layouts.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-bind-group-layouts.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-bind-group-layouts.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-bind-group-layouts.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-bind-group-layouts.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Bind Group Layouts`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>