<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-camera-controls.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Controlling the Camera">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-camera-controls_en.jpg">

<meta property="og:title" content="WebGPU Camera Controls">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-camera-controls_en.jpg">
<meta property="og:description" content="Controlling the Camera">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Camera Controls">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html">
<meta name="twitter:description" content="Controlling the Camera">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-camera-controls_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-camera-controls_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html",
      "inLanguage":"en",
      "name":"WebGPU Camera Controls",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-camera-controls.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Camera Controls</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-camera-controls.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-camera-controls.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-camera-controls.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-camera-controls.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-camera-controls.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-camera-controls.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-camera-controls.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-camera-controls.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Camera Controls</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is the 2nd in a short series about making parts for a 3D editor.
Each one builds on the previous lesson so you may find them easiest to
understand by reading them in order.</p>
<ol>
<li><a href="webgpu-highlighting.html">Highlighting</a></li>
<li><a href="webgpu-camera-controls.html">Camera Controls</a> ⬅ you are here</li>
<li><a href="webgpu-picking.html">Picking</a></li>
</ol>
<h1 id="orbit-camera">Orbit Camera</h1>
<p>An orbit camera is the camera that most 3D modeling packages like Blender,
Unity, Maya, 3DSMax, Unreal use in the editor. You can press some icon or hold
some key and then dragging the pointer orbits some point in the world.</p>
<p>There are some words that AFAIK, come from film and others from aviation</p>
<ul>
<li>
<p>“Pan” is turning the camera left and right at it’s current location.</p>
<p>When you take a panorama picture on your phone you “pan” the camera.</p>
</li>
<li>
<p>“Tilt” is turning the camera up and down</p>
<p>If you’re standing you might tilt a camera down to take a picture
of a flower or tilt it up to take a picture of an airplane.</p>
</li>
<li>
<p>“Roll” is like tilting your head left or right.</p>
<p>The horizon is no longer flat.</p>
</li>
<li>
<p>“Dolly” is moving the camera closer or further</p>
<p>This is often considered “zooming” but zoom with a camera lens is instead
changing the field of view where as “dollying” is moving the camera closer
or further from the target.</p>
</li>
<li>
<p>“Track” is moving the camera perpendicular to the way it’s facing.</p>
<p>I’m only guessing this comes from
<a href="https://en.wikipedia.org/wiki/Tracking_shot">actually having a “track” to roll a movie camera on</a>.</p>
</li>
</ul>
<p>In any case, one way to solve many issues like this is to build a “rig”.
A “rig” in 3D terms generally refers to some hierarchy of scene graph nodes,
potentially with some constraints added.</p>
<p>We could build a hierarchy like this</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">+-camTarget (anchors the center of rotation)
  +-camPitch (lets us "pan" around the target)
    +-camTilt (lets us "tilt" above or below the target)
      +-camExtend (lets us "dolly" the camera closer or further from the target)
        +-cam (gives us a camera matrix)
</pre>
<p>You can almost picture this as a actual mechanical rig made of physical parts.
I don’t know if this is a good analogy but if you had a military tank, the tank itself would be the <code class="notranslate" translate="no">camTarget</code>. The head that rotates on top of the
tank would be the <code class="notranslate" translate="no">camPitch</code>. The part that lets the barrel rotate up and down
is the <code class="notranslate" translate="no">camTilt</code>. The barrel itself is the <code class="notranslate" translate="no">camExtend</code>. Ideally imagine a telescoping
barrel that can change length. You then attach the camera to the end of the barrel
<strong>aimed back toward the tank</strong>.</p>
<div class="webgpu_center">
  <div data-diagram="camera-rig" style="width: 600px;"></div>
</div>
<p>In the diagram above:</p>
<ul>
<li>the blue base is the <code class="notranslate" translate="no">camTarget</code></li>
<li>the green head is the <code class="notranslate" translate="no">camPitch</code></li>
<li>the red hinge is the <code class="notranslate" translate="no">camTilt</code></li>
<li>the pink/purple barrel is the <code class="notranslate" translate="no">camExtend</code></li>
<li>the white frame frustum represents a camera at <code class="notranslate" translate="no">cam</code> looking back toward the <code class="notranslate" translate="no">camTarget</code></li>
</ul>
<p>By default the pieces in the diagram are stacked up to make them easy to see but in our
actual rig they’d all sit on top of each other. Check “collapse” to put them where they should be.</p>
<p>In any case, let’s make that camera rig.</p>
<p>First some minor UI tweaks. Since eventually
we want the user to be able to drag on the
scene to update the camera, lets make the controls
more like a 3D editor where instead of hovering
over the the scene, they fit some space on the right. We’ll also make it so if the user closes
the controls the scene expands to fill the space.</p>
<p>First some HTML changes</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">+&lt;div id="split"&gt;
*  &lt;canvas&gt;&lt;/canvas&gt;
+  &lt;div id="ui"&gt;&lt;/div&gt;
+&lt;/div&gt;
</pre>
<p>and the corresponding CSS</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">#split {
  display: flex;
  height: 100%;
}
#ui {
  border-left: 1px solid #888;
}
#ui.hide-ui {
  right: 0;
  position: absolute;
}
#split &gt; :nth-child(1) {
  flex: 1 1 auto;
  min-width: 0;
}
</pre>
<p>Then finally we’ll move the UI inside this <code class="notranslate" translate="no">#ui</code> div and update
the div’s css classes based on the UI state.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const gui = new GUI();
-  gui.onChange(render);
+  const uiElem = document.querySelector('#ui');
+  const gui = new GUI({
+    parent: uiElem,
+  });
+  gui.onChange(() =&gt; {
+    uiElem.classList.toggle('hide-ui', !gui.isOpen());
+    render();
+  });
</pre>
<p>Now let’s start making an orbit camera based on scene graph nodes.</p>
<p>Here’s the our orbit camera rig:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {
    #camTarget;
    #camPan;
    #camTilt;
    #camExtend;
    #cam;

    constructor() {
      // Create Camera Rig
      this.#camTarget = addTRSSceneGraphNode('cam-target');
      this.#camPan = addTRSSceneGraphNode('cam-pan', this.#camTarget);
      this.#camTilt = addTRSSceneGraphNode('cam-tilt', this.#camPan);
      this.#camExtend = addTRSSceneGraphNode('cam-extend', this.#camTilt);
      this.#cam = addTRSSceneGraphNode('cam', this.#camExtend);
    }

    setParent(parent) {
      this.#camTarget.setParent(parent);
    }

    getCameraMatrix() {
      return this.#cam.worldMatrix;
    }

    get pan() { return this.#camPan.source.rotation[1]; }
    set pan(v) { this.#camPan.source.rotation[1] = v; }
    get tilt() { return this.#camTilt.source.rotation[0]; }
    set tilt(v) { this.#camTilt.source.rotation[0] = v; }
    get radius() { return this.#camExtend.source.translation[2]; }
    set radius(v) { this.#camExtend.source.translation[2] = v; }
    get target() { return vec3.copy(this.#camTarget.source.translation); }
    set target(v) { vec3.copy(v, this.#camTarget.source.translation); }
  }
</pre>
<p>We need to add <code class="notranslate" translate="no">vec3.copy</code> which we haven’t needed until this point</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
+  copy(src, dst) {
+    dst = dst || new Float32Array(3);
+    dst.set(src);
+    return dst;
+  },

   ...
</pre>
<p>then we need to use the <code class="notranslate" translate="no">OrbitCamera</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const orbitCamera = new OrbitCamera();
+  orbitCamera.setParent(root);
+  orbitCamera.target = [120, 80, 0];
+  orbitCamera.tilt = Math.PI * -0.2;
+  orbitCamera.radius = 300;

  ...

  const settings = {
-    cameraRotation: degToRad(-45),
    showMeshNodes: false,
    showAllTRS: false,
  };

-  const cameraRadToDegOptions = { min: -180, max: 180, step: 1, converters: GUI.converters.radToDeg };

  const uiElem = document.querySelector('#ui');
  const gui = new GUI({
    parent: uiElem,
  });
  gui.onChange(() =&gt; {
    uiElem.classList.toggle('hide-ui', !gui.isOpen());
  });
-  gui.add(settings, 'cameraRotation', cameraRadToDegOptions);
  gui.add(settings, 'showMeshNodes').onChange(showMeshNodes);
  gui.add(settings, 'showAllTRS').onChange(showTRS);

  ...

  function render() {

   ...

-    // Get the camera's position from the matrix we computed
-    const cameraMatrix = mat4.identity();
-    mat4.translate(cameraMatrix, [120, 100, 0], cameraMatrix);
-    mat4.rotateY(cameraMatrix, settings.cameraRotation, cameraMatrix);
-    mat4.translate(cameraMatrix, [60, 0, 300], cameraMatrix);
-
-    // Compute a view matrix
-    const viewMatrix = mat4.inverse(cameraMatrix);

+    root.updateWorldMatrix();
+
+    // make a view matrix from the camera's
+    const viewMatrix = mat4.inverse(orbitCamera.getCameraMatrix());

    // combine the view and projection matrixes
    const viewProjectionMatrix = mat4.multiply(projection, viewMatrix);

    const encoder = device.createCommandEncoder();
    {
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);

      const ctx = { pass, viewProjectionMatrix };
-      root.updateWorldMatrix();
      for (const mesh of meshes) {
        drawMesh(ctx, mesh);
      }

      pass.end();
    }

</pre>
<p>Notice that a whole bunch of math disappeared. There is no math
in the <code class="notranslate" translate="no">OrbitCamera</code> code, just rig nodes. This is because
all the math has been buried in the rig itself.</p>
<p>We could run it as is but it would be difficult to change any
camera settings since our UI, by default, displays translation x,y,z
only OR all 9 translation, rotation, and scale settings per node.</p>
<p>Let’s hack the UI so we can make the camera nodes show only relevant
settings. We’ll do this by adding a map of scene graph nodes to
settings just to keep it simple and terse we’ll provide an array
of controls by index we want to appear where 0, 1, 2 are translation
x, y, z. 3, 4, 5 are rotation x, y, z, and 6, 7, 8 are scale.
If no settings for the node exist then they’ll follow the existing
rules.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const nodeToUISettings = new Map();

  class OrbitCamera {
    #camTarget;
    #camPan;
    #camTilt;
    #camExtend;
    #cam;

    constructor() {
      // Create Camera Rig
      this.#camTarget = addTRSSceneGraphNode('cam-target');
      this.#camPan = addTRSSceneGraphNode('cam-pan', this.#camTarget);
      this.#camTilt = addTRSSceneGraphNode('cam-tilt', this.#camPan);
      this.#camExtend = addTRSSceneGraphNode('cam-extend', this.#camTilt);
      this.#cam = addTRSSceneGraphNode('cam', this.#camExtend);

+      nodeToUISettings.set(this.#camTarget, { trs: [0, 1, 2] });
+      nodeToUISettings.set(this.#camPan, { trs: [4] });
+      nodeToUISettings.set(this.#camTilt, { trs: [3] });
+      nodeToUISettings.set(this.#camExtend, { trs: [2] });
+      nodeToUISettings.set(this.#cam, { trs: [] });
    }

    ...
  }

  ...

+  let currentNode;
  function setCurrentSceneGraphNode(node) {
+    currentNode = node;
    trsUIHelper.setTRS(node.source);
    trsFolder.name(`orientation: ${node.name}`);
    trsFolder.updateDisplay();

 +   showTRS();

    // Mark which node is selected.
    for (const b of nodeButtons) {
      const name = b.button.getName().replace(prefixRE, '');
      b.button.name(`${b.node === node ? kSelected : kUnelected}${name}`);
    }

    selectedMeshes = meshes.filter(mesh =&gt; meshUsesNode(mesh, node));

    render();
  }

  ...

  const alwaysShow = new Set([0, 1, 2]);
-  function showTRS(show) {
+  function showTRS() {
+    const ui = nodeToUISettings.get(currentNode);
    trsControls.forEach((trs, i) =&gt; {
-      trs.show(show || alwaysShow.has(i));
+      const showThis = ui
+        ? ui.trs?.indexOf(i) &gt;= 0
+        : (settings.showAllTRS || alwaysShow.has(i));
+      trs.show(showThis);
    });
  }
=  showTRS(false);

</pre>
<p>With those changes we’ve replaced the old camera code with
our new <code class="notranslate" translate="no">OrbitCamera</code>, removed a bunch of math, and made the
camera’s rig nodes show up in the UI with their settings
visible and editable.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-01.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-01.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Now that we have the basics in place, lets add some pointer controls.</p>
<h2 id="pan-and-tilt"><a id="a-pan-and-tilt"></a> Pan and Tilt</h2>
<p>Lets adjust pan and tilt when you drag the pointer.</p>
<p>First, we need to make minor CSS tweak so that dragging doesn’t
select the canvas among other things.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">canvas {
  display: block;  /* make the canvas act like a block   */
  width: 100%;     /* make the canvas fill its container */
  height: 100%;
+  touch-action: none;
}
</pre>
<p>Then, let’s add some code to the camera to encapsulate these
changes a little. We’ll make a function <code class="notranslate" translate="no">getUpdateHelper</code> that
records some relevant but kind of private camera state, and the
helper will provide functions to modify the camera state by
deltas the UI code will pass in.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {

   ...

+    getUpdateHelper() {
+      const startTilt = this.tilt;
+      const startPan = this.pan;
+
+      return {
+        panAndTilt: (deltaPan, deltaTilt) =&gt; {
+          this.tilt = startTilt - deltaTilt;
+          this.pan = startPan - deltaPan;
+        },
+      };
+    }

   ...

  }
</pre>
<p>Then, we can add a function to connect pointer input to create
the helper and pass in deltas.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {
    let startX;
    let startY;
    let camHelper;

    const updateStartPosition = (e) =&gt; {
      startX = e.clientX;
      startY = e.clientY;
      camHelper = cam.getUpdateHelper();
    };

    const onMove = (e) =&gt; {
      if (!canvas.hasPointerCapture(e.pointerId)) {
        return;
      }

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      camHelper.panAndTilt(deltaX * 0.01, deltaY * 0.01);
      render();
    };

    const onUp = (e) =&gt; {
      canvas.releasePointerCapture(e.pointerId);
    };

    const onDown = (e) =&gt; {
      canvas.setPointerCapture(e.pointerId);
      updateStartPosition(e);
    };

    elem.addEventListener('pointerup', onUp);
    elem.addEventListener('pointercancel', onUp);
    elem.addEventListener('lostpointercapture', onUp);
    elem.addEventListener('pointerdown', onDown);
    elem.addEventListener('pointermove', onMove);

    return () =&gt; {
      elem.removeEventListener('pointerup', onUp);
      elem.removeEventListener('pointercancel', onUp);
      elem.removeEventListener('lostpointercapture', onUp);
      elem.removeEventListener('pointerdown', onDown);
      elem.removeEventListener('pointermove', onMove);
    };
  }

  addOrbitCameraEventListeners(orbitCamera, canvas);
</pre>
<p>The code is pretty straight forward. On <code class="notranslate" translate="no">pointerdown</code> we call
<code class="notranslate" translate="no">cam.getUpdateHelper</code> which records the current <code class="notranslate" translate="no">pan</code> and <code class="notranslate" translate="no">tilt</code>. We also record
and the current pointer position. On <code class="notranslate" translate="no">pointermove</code> we compute the delta from
where the pointer started and pass it into the helper to  adjust <code class="notranslate" translate="no">pan</code> and
<code class="notranslate" translate="no">tilt</code>. That’s basically it. <code class="notranslate" translate="no">addOrbitCameraEventListeners</code> also returns a
function to remove the listeners if that’s important.</p>
<p>One more small change, let’s make the GUI check for updates to the values.
This way when we just <code class="notranslate" translate="no">pan</code> and <code class="notranslate" translate="no">tilt</code> by dragging the pointer the values
in the UI will update automatically.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const trsFolder = gui.addFolder('orientation');
+  const trsFolder = gui.addFolder('orientation').listen();
</pre>
<p>Give it try, drag your finger on the canvas. You can select the
<code class="notranslate" translate="no">cam-tilt</code> or <code class="notranslate" translate="no">cam-pan</code> nodes and you’ll see the values change
as you drag.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-02.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-02.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="tracking"><a id="a-track"></a> Tracking</h2>
<p>It’s common that if you hold some modifying key, like shift, while dragging,
instead of adjusting the pan or tilt, you instead “track” the camera (translate it).</p>
<p>Let’s add that. First off we need a few new math functions.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
+  create() {
+    return new Float32Array(3);
+  },

  ...

+  add(a, b, dst) {
+      dst = dst || new Float32Array(3);
+
+      dst[0] = a[0] + b[0];
+      dst[1] = a[1] + b[1];
+      dst[2] = a[2] + b[2];
+
+      return dst;
+  },
+
+  transformMat3(v, m, dst) {
+    dst = dst ?? new Float32Array(3);
+
+    const x = v[0];
+    const y = v[1];
+    const z = v[2];
+
+    dst[0] = x * m[0] + y * m[4] + z * m[8];
+    dst[1] = x * m[1] + y * m[5] + z * m[9];
+    dst[2] = x * m[2] + y * m[6] + z * m[10];
+
+    return dst;
+  },
}
</pre>
<p><code class="notranslate" translate="no">create</code> just creates a vec3 with 3 zeros. <code class="notranslate" translate="no">add</code> adds two vec3s.
Finally, <code class="notranslate" translate="no">transformMat3</code> multiplies a vector by a 3x3 matrix. This was
mentioned <a href="webgpu-lighting-directional.html#a-normals">when we covered normals for lighting</a>. There, we multiplied a normal (vec3f) by a normal matrix (mat3x3f) in WGSL. Here, we’re essentially doing the same thing but in JavaScript but instead of re-orienting a normal we’re reorienting the pointer
movement.</p>
<p>We can now update the helper</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {

    ...

    getUpdateHelper() {
      const startTilt = this.tilt;
      const startPan = this.pan;
+      const startCameraMatrix = mat4.copy(this.getCameraMatrix());
+      const startTarget = vec3.copy(this.target);

      return {
        panAndTilt: (deltaPan, deltaTilt) =&gt; {
          this.tilt = startTilt - deltaTilt;
          this.pan = startPan - deltaPan;
        },
+        track: (deltaX, deltaY) =&gt; {
+          const direction = vec3.transformMat3([deltaX, deltaY, 0], startCameraMatrix);
+          this.target = vec3.add(startTarget, direction);
+        },
      };
    }
</pre>
<p><code class="notranslate" translate="no">track'</code> takes an xy delta  multiplies it by the upper left 3x3 matrix of our
camera matrix. This has the effect of orienting the direction perpendicular to
the way the camera is facing. We can then just add that to our target</p>
<p>We then <code class="notranslate" translate="no">track</code> from the pointer event code.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {
    let startX;
    let startY;
+    let lastMode;
    let camHelper;

    const updateStartPosition = (e) =&gt; {
      startX = e.clientX;
      startY = e.clientY;
      camHelper = cam.getUpdateHelper();
    };

    const onMove = (e) =&gt; {
      if (!canvas.hasPointerCapture(e.pointerId)) {
        return;
      }

+      const mode = e.shiftKey
+        ? 'track'
+        : 'panAndTilt';
+
+      if (mode !== lastMode) {
+        lastMode = mode;
+        updateStartPosition(e);
+      }

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

+      switch (mode) {
+        case 'track': {
+          const s = cam.radius * 0.001;
+          camHelper.track(-deltaX * s, deltaY * s);
+          break;
+        }
+        case 'panAndTilt':
*          camHelper.panAndTilt(deltaX * 0.01, deltaY * 0.01);
+          break;
+      }

      render();
    };

    const onUp = (e) =&gt; {
      canvas.releasePointerCapture(e.pointerId);
    };

    const onDown = (e) =&gt; {
      canvas.setPointerCapture(e.pointerId);
      updateStartPosition(e);
    };

    elem.addEventListener('pointerup', onUp);
    elem.addEventListener('pointercancel', onUp);
    elem.addEventListener('lostpointercapture', onUp);
    elem.addEventListener('pointerdown', onDown);
    elem.addEventListener('pointermove', onMove);

    return () =&gt; {
      elem.removeEventListener('pointerup', onUp);
      elem.removeEventListener('pointercancel', onUp);
      elem.removeEventListener('lostpointercapture', onUp);
      elem.removeEventListener('pointerdown', onDown);
      elem.removeEventListener('pointermove', onMove);
    };
  }
</pre>
<p>Our event code above, computes a mode based on whether or not the user is
holding the shift key. If the mode switches then we need to record starting
values. It then switches on the mode.</p>
<p>Our <code class="notranslate" translate="no">'track'</code> mode passes the pointer delta to the helper’s <code class="notranslate" translate="no">track</code>
function. We scale the delta by the radius (our distance from the
target), that way we’ll move in smaller steps if we’re really close up.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-03.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-03.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="dolly-by-wheel"><a id="a-dolly-by-wheel"></a> Dolly by Wheel</h2>
<p>Next let’s add zooming or “dolly” with the scroll wheel which is pretty common.</p>
<p>First let’s update our helper.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {
    ...

    getUpdateHelper() {
      const startTilt = this.tilt;
      const startPan = this.pan;
+      const startRadius = this.radius;
      const startCameraMatrix = mat4.copy(this.getCameraMatrix());
      const startTarget = vec3.copy(this.target);

      return {
        panAndTilt: (deltaPan, deltaTilt) =&gt; {
          this.tilt = startTilt - deltaTilt;
          this.pan = startPan - deltaPan;
        },
        track: (deltaX, deltaY) =&gt; {
          const direction = vec3.transformMat3([deltaX, deltaY, 0], startCameraMatrix);
          this.target = vec3.add(startTarget, direction);
        },
+        dolly: (delta) =&gt; {
+          this.radius = startRadius + delta;
+        },
      };
    }

    ...
  }
</pre>
<p>And then let’s use it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {

  ...


+    // Dolly when the user uses the wheel
+    const onWheel = (e) =&gt; {
+      e.preventDefault();
+      const helper = cam.getUpdateHelper();
+      helper.dolly(cam.radius * 0.001 * e.deltaY);
+      render();
+    };

    elem.addEventListener('pointerup', onUp);
    elem.addEventListener('pointercancel', onUp);
    elem.addEventListener('lostpointercapture', onUp);
    elem.addEventListener('pointerdown', onDown);
    elem.addEventListener('pointermove', onMove);
+    elem.addEventListener('wheel', onWheel);

    return () =&gt; {
      elem.removeEventListener('pointerup', onUp);
      elem.removeEventListener('pointercancel', onUp);
      elem.removeEventListener('lostpointercapture', onUp);
      elem.removeEventListener('pointerdown', onDown);
      elem.removeEventListener('pointermove', onMove);
+      elem.removeEventListener('wheel', onWheel);
    };
  }
</pre>
<p>With that small change you should be able to zoom in/out (dolly) with
the mouse wheel (or with 2 fingers on a laptop).</p>
<p>The code is adjusting by 1000th of the radius. This has not been tested
with lots of scenes but it seems reasonable that we don’t want to
move the same speed if we’re too close.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-04.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-04.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="dolly-by-pinch"><a id="a-dolly-by-pinch"></a> Dolly by Pinch</h2>
<p>On mobile it’s common to pinch to zoom. Let’s add that.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {
    let startX;
    let startY;
    let lastMode;
    let camHelper;
+    let startPinchDistance;
+    const pointerToLastPosition = new Map();

+    const computePinchDistance = () =&gt; {
+      const pos = [...pointerToLastPosition.values()];
+      const dx = pos[0].x - pos[1].x;
+      const dy = pos[0].y - pos[1].y;
+      return Math.hypot(dx, dy);
+    };

    const updateStartPosition = (e) =&gt; {
      startX = e.clientX;
      startY = e.clientY;
+      if (pointerToLastPosition.size === 2) {
+        startPinchDistance = computePinchDistance();
+      }
      camHelper = cam.getUpdateHelper();
    };

    const onMove = (e) =&gt; {
-      if (!canvas.hasPointerCapture(e.pointerId)) {
+      if (!pointerToLastPosition.has(e.pointerId) ||
+          !canvas.hasPointerCapture(e.pointerId)) {
        return;
      }
+      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });

-      const mode = e.shiftKey
+      const mode = pointerToLastPosition.size === 2
+        ? 'pinch'
+        : pointerToLastPosition.size &gt; 2
+        ? 'undefined'
+        : e.shiftKey
        ? 'track'
        : 'panAndTilt';

      if (mode !== lastMode) {
        lastMode = mode;
        updateStartPosition(e);
      }

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      switch (mode) {
+        case 'pinch': {
+          const pinchDistance = computePinchDistance();
+          const delta = pinchDistance - startPinchDistance;
+          camHelper.dolly(cam.radius * 0.002 * -delta);
+          break;
+        }
        case 'track': {
          const s = cam.radius * 0.001;
          camHelper.track(-deltaX * s, deltaY * s);
          break;
        }
        case 'panAndTilt':
          camHelper.panAndTilt(deltaX * 0.01, deltaY * 0.01);
          break;
      }

      render();
    };

    const onUp = (e) =&gt; {
+     pointerToLastPosition.delete(e.pointerId);
     canvas.releasePointerCapture(e.pointerId);
    };

    const onDown = (e) =&gt; {
      canvas.setPointerCapture(e.pointerId);
+      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });
      updateStartPosition(e);
    };

    ...
  }
</pre>
<p>Now we tracking the starting position of all pointers. We check if there are 2.
If so we’re pinching, if there are more than 2 then we give up. If there is only
1 then we’re back where we were.</p>
<p>In <code class="notranslate" translate="no">computePinchDistance</code> we get the 2 positions and compute the distance between
them. We can use that to record how far apart they were when the user started pinching
and how far apart they are later and apply that to zooming.</p>
<p>If you have a touch screen laptop, or you’re on a tablet or phone,
maybe you can give it a try.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-05.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-05.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="dolly-by-double-tap-drag"><a id="a-dolly-by-double-tab-drag"></a> Dolly by Double Tap Drag</h2>
<p>Let’s do one more. It’s common on some apps that if you double tap the screen
and then drag your finger it zooms. Google Maps does this for example. Let’s add
that.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function addOrbitCameraEventListeners(cam, elem) {
    let startX;
    let startY;
    let lastMode;
    let camHelper;
+    let doubleTapMode;
+    let lastSingleTapTime;
    let startPinchDistance;
    const pointerToLastPosition = new Map();

    ...

    const onMove = (e) =&gt; {
      if (!pointerToLastPosition.has(e.pointerId) ||
          !canvas.hasPointerCapture(e.pointerId)) {
        return;
      }
      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });

      const mode = pointerToLastPosition.size === 2
        ? 'pinch'
        : pointerToLastPosition.size &gt; 2
        ? 'undefined'
+        : doubleTapMode
+        ? 'doubleTapZoom'
        : e.shiftKey
        ? 'track'
        : 'panAndTilt';

      if (mode !== lastMode) {
        lastMode = mode;
        updateStartPosition(e);
      }

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      switch (mode) {
        case 'pinch': {
          const pinchDistance = computePinchDistance();
          const delta = pinchDistance - startPinchDistance;
          camHelper.dolly(cam.radius * 0.002 * -delta);
          break;
        }
        case 'track': {
          const s = cam.radius * 0.001;
          camHelper.track(-deltaX * s, deltaY * s);
          break;
        }
        case 'panAndTilt':
          camHelper.panAndTilt(deltaX * 0.01, deltaY * 0.01);
          break;
+        case 'doubleTapZoom':
+          camHelper.dolly(cam.radius * 0.002 * deltaY);
+          break;
      }

      render();
    };

    const onUp = (e) =&gt; {
      pointerToLastPosition.delete(e.pointerId);
      canvas.releasePointerCapture(e.pointerId);
+      if (pointerToLastPosition.size === 0) {
+        doubleTapMode = false;
+      }
    };

+    const kDoubleClickTimeMS = 300;
    const onDown = (e) =&gt; {
      canvas.setPointerCapture(e.pointerId);
      pointerToLastPosition.set(e.pointerId, { x: e.clientX, y: e.clientY });
+      if (pointerToLastPosition.size === 1) {
+        if (!doubleTapMode) {
+          const now = performance.now();
+          const deltaTime = now - lastSingleTapTime;
+          if (deltaTime &lt; kDoubleClickTimeMS) {
+            doubleTapMode = true;
+          }
+          lastSingleTapTime = now;
+        }
+      } else {
+        doubleTapMode = false;
+      }
      updateStartPosition(e);
    };

    ...
  }
</pre>
<p>The code checks if there is a single <code class="notranslate" translate="no">pointerdown</code> and checks the time between that and
the last single <code class="notranslate" translate="no">pointerdown</code>. If it’s below <code class="notranslate" translate="no">kDoubleClickTime</code> then we’re in <code class="notranslate" translate="no">doubleTapMode</code>
and we can adjust the zoom based on the distance from where the 2nd tap started.</p>
<p>ATM, this will work with the mouse or a touch screen. Is it appropriate for a mouse?
Give it a try.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-06.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-06.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="camera-not-at-root"><a id="a-camera-not-at-root"></a> Camera not at root</h2>
<p>An issue we have not covered is what if our OrbitCamera, which exists
in the scene graph, is not based at the root of the graph.</p>
<p>For example, lets say it was a camera in the scene on a fallen tower.
Since the tower is fallen the camera is not level with ground.</p>
<p>For tilt, pan, and dolly, nothing needs to change as all of these are
relative to the camera itself but for track, we need to do some extra
work since the target of the camera is relative to its parent node.</p>
<p>To fix this, first, we should probably remove the <code class="notranslate" translate="no">target</code> setter
as it’s mis-leading. We’ll make a <code class="notranslate" translate="no">setTarget</code> function that takes
the camera’s parent into account.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {

   ...

    get target() { return vec3.copy(this.#camTarget.source.translation); }
-    set target(v) { vec3.copy(v, this.#camTarget.source.translation); }
_    setTarget(worldPosition) {
_      const inv = mat4.inverse(this.#camTarget.parent?.worldMatrix ?? mat4.identity());
_      vec3.transformMat4(worldPosition, inv, this.#camTarget.source.translation);
_    }
  }
</pre>
<p>We also need to add <code class="notranslate" translate="no">vec3.transformMat4</code> which is the same math
we use in our vertex shader for <code class="notranslate" translate="no">uni.matrix * vert.position</code> just
translated to JavaScript.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
  transformMat3(v, m, dst) {
    dst = dst ?? new Float32Array(3);

    const x = v[0];
    const y = v[1];
    const z = v[2];

    dst[0] = x * m[0] + y * m[4] + z * m[8];
    dst[1] = x * m[1] + y * m[5] + z * m[9];
    dst[2] = x * m[2] + y * m[6] + z * m[10];

    return dst;
  },

+  transformMat4(v, m, dst) {
+    dst = dst ?? new Float32Array(3);
+
+    const x = v[0];
+    const y = v[1];
+    const z = v[2];
+    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;
+
+    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
+    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
+    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
+
+    return dst;
+  },
};
</pre>
<p>With the setter removed we need to fix the code what was using it.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const orbitCamera = new OrbitCamera();
  orbitCamera.setParent(root);
-  orbitCamera.target = [120, 80, 0];
+  orbitCamera.setTarget([120, 80, 0]);
  orbitCamera.tilt = Math.PI * -0.2;
  orbitCamera.radius = 300;
</pre>
<p>We also need to refactor the helper’s <code class="notranslate" translate="no">track</code> function to
take into account it might not be at the root and adjust the delta
to be relative to the camera’s parent.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  class OrbitCamera {

    ...

    getUpdateHelper() {

      ...

        track: (deltaX, deltaY) =&gt; {
-          const direction = vec3.transformMat3([deltaX, deltaY, 0], startCameraMatrix);
-          this.target = vec3.add(startTarget, direction);
+          const worldDirection = vec3.transformMat3([deltaX, deltaY, 0], startCameraMatrix);
+          const inv = mat4.inverse(this.#camTarget.parent?.worldMatrix ?? mat4.identity());
+          const cameraDirection = vec3.transformMat3(worldDirection, inv);
-          this.target = vec3.add(startTarget, cameraDirection);
+          vec3.add(startTarget, cameraDirection, this.#camTarget.source.translation);
        },

      ...
    }
  }
</pre>
<p>The direction we were computing before was a direction in world space.
That worked when the camera was at the root. Now though, we multiply
by the inverse of the camera’s parent worldMatrix. This effectively
changes the delta to be relative to the that parent which is what
we need.</p>
<p>Let’s put the camera on some extra scene graph nodes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const orbitCamera = new OrbitCamera();
-  orbitCamera.setParent(root);
+  const extraRot = addTRSSceneGraphNode('extra-rot', root, { rotation: [0, 0, Math.PI * 0.35] });
+  const extraMov = addTRSSceneGraphNode('extra-mov', extraRot, { translation: [-30, -90, 40] });
+  orbitCamera.setParent(extraMov);
</pre>
<p>You should set tracking still works.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-07.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-07.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<h2 id="frame-selected"><a id="a-frame-selected"></a> Frame Selected</h2>
<p>One more important feature is being able to select an object and then pick “Frame Selected”
to move the camera to show that object. To do that requires knowing how large each
object is. For this specific case, we happen to know everything on the screen is a unit cube.
We can store some extents on our data but for now just set them all to cover our cube.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCubeVertices() {
  const positions = [
    // left
    0, 0,  0,
    0, 0, -1,
    0, 1,  0,
    0, 1, -1,

    // right
    1, 0,  0,
    1, 0, -1,
    1, 1,  0,
    1, 1, -1,
  ];

  ...

  return {
    vertexData,
    numVertices,
+    aabb: {
+      min: [ 0,  0, -1],
+      max: [ 1,  1,  0],
+    },
  };
</pre>
<p><code class="notranslate" translate="no">aabb</code> stands for Axis Aligned Bounding Box. We can easily see
this matches our cube. If we had different data we’d have to scan it
for the min and max values.</p>
<p>We need to bubble this data up to our mesh vertices</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  function createVertices({vertexData, numVertices}, name) {
  function createVertices({vertexData, numVertices, aabb}, name) {
    const vertexBuffer = device.createBuffer({
      label: `${name}: vertex buffer vertices`,
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(vertexBuffer, 0, vertexData);
    return {
      vertexBuffer,
      numVertices,
+      aabb,
    };
</pre>
<p>We need a function that given a mesh, computes the AABB for that
mesh in world space since it will have been oriented by our scene graph.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function computeAABBForMesh(mesh) {
    const mat = mesh.node.worldMatrix;
    const p0 = mesh.vertices.aabb.min;
    const p1 = mesh.vertices.aabb.max;
    let min;
    let max;
    for (let i = 0; i &lt; 8; ++i) {
      const p = [
        (i &amp; 1) ? p0[0] : p1[0],
        (i &amp; 2) ? p0[1] : p1[1],
        (i &amp; 4) ? p0[2] : p1[2],
      ];
      vec3.transformMat4(p, mat, p);
      if (i === 0) {
        min = p.slice();
        max = p.slice();
      } else {
        vec3.min(min, p, min);
        vec3.max(max, p, max);
      }
    }
    return { min, max };
  }
</pre>
<p>This used 2 more <code class="notranslate" translate="no">vec3</code> functions we need to add. <code class="notranslate" translate="no">min</code>, and <code class="notranslate" translate="no">max</code>
that return the a <code class="notranslate" translate="no">vec3</code> that contains the min or max of each component
of 2 vec3s.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...

+  min(a, b, dst) {
+    dst = dst ?? new Float32Array(3);
+
+    dst[0] = Math.min(a[0], b[0]);
+    dst[1] = Math.min(a[1], b[1]);
+    dst[2] = Math.min(a[2], b[2]);
+
+    return dst;
+  },
+
+  max(a, b, dst) {
+    dst = dst ?? new Float32Array(3);
+
+    dst[0] = Math.max(a[0], b[0]);
+    dst[1] = Math.max(a[1], b[1]);
+    dst[2] = Math.max(a[2], b[2]);
+
+    return dst;
+  },

  ...
};
</pre>
<p>Then, we need a function to go through the selected meshes and gives
us their combined AABB.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function expandAABBInPlace(aabb, otherAABB) {
    vec3.min(aabb.min, otherAABB.min, aabb.min);
    vec3.max(aabb.max, otherAABB.max, aabb.max);
  }

  function getAABBForSelectedMeshes() {
    if (selectedMeshes.length === 0) {
      return undefined;
    }
    const aabb = computeAABBForMesh(selectedMeshes[0]);
    for (let i = 1; i &lt; selectedMeshes.length; ++i) {
      expandAABBInPlace(aabb, computeAABBForMesh(selectedMeshes[i]));
    }
    return aabb;
  }
</pre>
<p>With that we can make a function that frames the selected meshes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function frameSelected() {
    if (selectedMeshes.length === 0) {
      return;
    }

    // get aabb bounds for the selected objects.
    const aabb = getAABBForSelectedMeshes();

    const extent = vec3.subtract(aabb.max, aabb.min);
    const diameter = vec3.distance(aabb.min, aabb.max);

    // compute how far we need to set the radius for the selected
    // objects to be framed.
    const aspect = canvas.clientWidth / canvas.clientHeight;
    const fieldOfViewH = 2 * Math.atan(Math.tan(settings.fieldOfView) * aspect);
    const fov = Math.min(fieldOfViewH, settings.fieldOfView);
    const zoomScale = 1.5; // make it 1.5 times as large for some padding.
    const halfSize = diameter * zoomScale * 0.5;
    const distance = halfSize / Math.tan(fov * 0.5);

    orbitCamera.radius = distance;

    // point the camera at the center
    const center = vec3.addScaled(aabb.min, extent, 0.5);
    orbitCamera.setTarget(center);

    render();
  }
</pre>
<p>The code above gets the AABB for the selected meshes. The diameter
of a sphere that would contain this AABB is just the distance between
2 opposite corners. Once we have that diameter we compute how far away
a camera needs to be give its current <code class="notranslate" translate="no">fieldOfView</code>. The field of view
setting of our <code class="notranslate" translate="no">mat4.perspective</code> function is the vertical field of view.
so based on that and the aspect we horizontal field of view and use
whichever is smaller and then use that to compute how far away we need
to be so our sphere would fit. We use <code class="notranslate" translate="no">zoomScale</code> to make our sphere 1.5x
as large as the sphere that contains our AABB so we’ll get some padding.
We then just the radius of the camera to that distance.</p>
<p>Finally we point the camera’s target at the AABB’s center point.</p>
<p>We need to supply a few more <code class="notranslate" translate="no">vec3</code> functions, <code class="notranslate" translate="no">distance</code> and <code class="notranslate" translate="no">addScaled</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vec3 = {
  ...
+  distance(a, b) {
+    const dx = a[0] - b[0];
+    const dy = a[1] - b[1];
+    const dz = a[2] - b[2];
+    return Math.sqrt(dx * dx + dy * dy + dz * dz);
+  },

...

+  addScaled(a, b, scale, dst) {
+      dst = dst || new Float32Array(3);
+
+      dst[0] = a[0] + b[0] * scale;
+      dst[1] = a[1] + b[1] * scale;
+      dst[2] = a[2] + b[2] * scale;
+
+      return dst;
+  },


  ...
};
</pre>
<p><code class="notranslate" translate="no">distance</code> computes the distance between 2 <code class="notranslate" translate="no">vec3</code>s. <code class="notranslate" translate="no">addScaled</code> effectively
does <code class="notranslate" translate="no">a + b * scale</code>. It makes it easy to add some portion of <code class="notranslate" translate="no">b</code> to <code class="notranslate" translate="no">a</code>.</p>
<p>We need to add a <code class="notranslate" translate="no">fieldOfView</code> to settings</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
+    fieldOfView: degToRad(60),
    showMeshNodes: false,
    showAllTRS: false,
  };

  function render() {
    ...

    const aspect = canvas.clientWidth / canvas.clientHeight;
    const projection = mat4.perspective(
-        degToRad(60), // fieldOfView,
+        settings.fieldOfView,
        aspect,
        1,      // zNear
        2000,   // zFar
    );
</pre>
<p>We also need to add a “frame selected” button</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const uiElem = document.querySelector('#ui');
  const gui = new GUI({
    parent: uiElem,
  });
  gui.onChange(() =&gt; {
    uiElem.classList.toggle('hide-ui', !gui.isOpen());
    render();
  });
  gui.add(settings, 'showMeshNodes').onChange(showMeshNodes);
  gui.add(settings, 'showAllTRS').onChange(showTRS);
+  gui.addButton('frame selected', frameSelected);
  const trsFolder = gui.addFolder('orientation').listen();
</pre>
<p>Let’s also add a parent node that contains
all 4 cabinets. That way we’ll have something to
select that we can frame the entire thing.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+  const cabinets = addTRSSceneGraphNode('cabinets', root);
  // Add cabinets
  for (let cabinetNdx = 0; cabinetNdx &lt; kNumCabinets; ++cabinetNdx) {
-    addCabinet(root, cabinetNdx);
+    addCabinet(cabinets, cabinetNdx);
  }
</pre>
<p>And while we’re at it lets remove the extra rotation and translation</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const extraRot = addTRSSceneGraphNode('extra-rot', root, { rotation: [0, 0, Math.PI * 0.35] });
-  const extraMov = addTRSSceneGraphNode('extra-mov', extraRot, { translation: [-30, -90, 40] });
+  const extraRot = addTRSSceneGraphNode('extra-rot', root);
+  const extraMov = addTRSSceneGraphNode('extra-mov', extraRot);


Try selecting an object and the picking "Frame selected".

<div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-scene-graph-step-08.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-scene-graph-step-08.html" target="_blank">click here to open in a separate window</a>
</div>



## &lt;a id="a-ux"&gt;&lt;/a&gt; UX decisions

There are TONs of UX decisions related to an orbit camera that you'll need to make.
Some off of them include:

* Should it allow roll?

  Roll is like when you tilt your head left / right.

  Adding roll would just be a matter of adding one more node at the end
  with a z rotation of our current rig between `#camExtend` and `#cam`.

* Should it be like we have it, just letting you drag, or should you it require some other way to adjust
  the camera.

  In Unity, you have to hold a key or switch to camera controlling mode by
  clicking an icon. In Blender you click and drag on certain icons or using the
  middle mouse button and modifier keys. Dragging on the "track camera" icon
  tracks the camera. Dragging the "orbit camera" icon orbits the camera.
  Dragging on the zoom icon zooms (dollies) the camera.

  For a viewer it's nice to be able to just drag with no keys or icons. For an
  editor where most activity is editing 3d content it's probably better to use
  an icon, add a mode, or have the user hold a key.

* What should happen on mobile?

  We didn't provide a solution for tracking the camera on mobile. Our only current method requires holding shift. Using an icon to drag on would
  work. I think some viewers use 2 fingers to track.

* Should it allow tilting past 90 degrees?

  We allowed going past 90 degrees which means the camera can go upside down.
  Some apps prevent that.

* Should "frame" keep the same orientation?

  Most 3D editors let you select an object and pick "Frame" which centers that object
  in the camera AND makes the camera orbit that object. The question is, does
  the orientation of the camera reset, like say, view from the front of the object. Or maybe it always switches to looking along positive Z.
  Or, does it keep whatever orientation it was before picking "frame". For example, if
  you were looking down on object A and the selected B, should it still be looking down?

* Which way does the camera move relative to the pointer?

  In other words, if you drag the pointer from left to right should the camera
  rotate clockwise or counterclockwise. counterclockwise makes it seem like
  your orbiting the camera. clockwise makes it seem like your turing the world
  under the camera. This is similar to dragging two fingers on a trackpad to
  scroll. If you drag down, should the content go up, because you're dragging
  the view over the content. Or should the content down, as though you're dragging
  the content itself.

  With touch screens you generally want it to look like your dragging the content
  but scrollbars existed before touch screens. Dragging the handle on the scroll bar
  drags the view, not the content. Scroll wheels moved that handle. Two fingers
  on a trackpad was a shortcut for that scroll wheel.

## &lt;a id="a-no-scene-graph"&gt;&lt;/a&gt; Implementing an OrbitCamera without a scene graph.

If you understood how a scene graph works from [the article on scene graphs](webgpu-scene-graphs.html)
then it should be pretty clear. We just need code like

```js
   class OrbitCamera {
    #target = vec3.create();
    #pan = 0;
    #tilt = 0;
    #radius = 0;

    constructor() {}

    getCameraMatrix(parentMatrix) {
      const mat = mat4.copy(parentMatrix ?? mat4.identity());
      mat4.translate(mat, this.#target, mat);
      mat4.rotateY(mat, this.#pan, mat);
      mat4.rotateX(mat, this.#tilt, mat);
      mat4.translate(mat, [0, 0, this.#radius], mat);
      return mat;
    }

    getUpdateHelper(parentMatrix) {
      const startTilt = this.tilt;
      const startPan = this.pan;
      const startRadius = this.radius;
      const startCameraMatrix = mat4.copy(this.getCameraMatrix());
      const startTarget = vec3.copy(this.target);

      return {
        panAndTilt: (deltaPan, deltaTilt) =&gt; {
          this.tilt = startTilt - deltaTilt;
          this.pan = startPan - deltaPan;
        },
        track: (deltaX, deltaY) =&gt; {
          const worldDirection = vec3.transformMat3([deltaX, deltaY, 0], startCameraMatrix);
          const inv = mat4.inverse(parentMatrix ?? mat4.identity());
          const cameraDirection = vec3.transformMat3(worldDirection, inv);
          this.target = vec3.add(startTarget, cameraDirection);
        },
        dolly: (delta) =&gt; {
          this.radius = startRadius + delta;
        },
      };
    }

    get pan() { return this.#pan; }
    set pan(v) { this.#pan = v; }
    get tilt() { return this.#tilt; }
    set tilt(v) { this.#tilt = v; }
    get radius() { return this.#radius; }
    set radius(v) { this.#radius = v; }
    get target() { return vec3.copy(this.#target); }
    set target(v) { vec3.copy(v, this.#target); }
  }
</pre>
<p>Popping that in our example we need one more minor change. Since it’s not in the scene graph
we need to not add it to the scene graph.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const orbitCamera = new OrbitCamera();
-  orbitCamera.setParent(root);
  orbitCamera.target = [120, 80, 0];
  orbitCamera.tilt = Math.PI * -0.2;
  orbitCamera.radius = 300;
</pre>
<p>And it works</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-camera-controls-raw.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-camera-controls-raw.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Now that we have a camera, let’s make it so you can
<a href="webgpu-picking.html">click on objects directly to select them</a>.</p>
<!-- keep this at the bottom of the article -->
<link href="webgpu-camera-controls.css" rel="stylesheet">
<script type="module" src="webgpu-camera-controls.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-camera-controls.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-camera-controls.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-camera-controls.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-camera-controls.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-camera-controls.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-camera-controls.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-camera-controls.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-camera-controls.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Basic CRT Effect</a></li>
<li><a href="/webgpu/lessons/webgpu-image-adjustments.html">Image Adjustments</a></li>
<li><a href="/webgpu/lessons/webgpu-1dlut.html">1D Lookup Table (LUT)</a></li>
<li><a href="/webgpu/lessons/webgpu-3dlut.html">3D Lookup Table (LUT)</a></li>
        </ul>
  <li>Editor</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-highlighting.html">Highlighting</a></li>
<li><a href="/webgpu/lessons/webgpu-camera-controls.html">Camera Controls</a></li>
<li><a href="/webgpu/lessons/webgpu-picking.html">Picking</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Camera Controls`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/js/prettify.js"></script>
<script src="/webgpu/lessons/resources/js/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>