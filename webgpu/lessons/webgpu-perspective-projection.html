<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-perspective-projection.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Perspective Projection - smaller in the distance">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-perspective-projection_en.jpg">

<meta property="og:title" content="WebGPU Perspective Projection">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-perspective-projection_en.jpg">
<meta property="og:description" content="Perspective Projection - smaller in the distance">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Perspective Projection">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html">
<meta name="twitter:description" content="Perspective Projection - smaller in the distance">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-perspective-projection_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-perspective-projection_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html",
      "inLanguage":"en",
      "name":"WebGPU Perspective Projection",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Perspective Projection</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-perspective-projection.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-perspective-projection.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-perspective-projection.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-perspective-projection.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-perspective-projection.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-perspective-projection.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-perspective-projection.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-perspective-projection.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Perspective Projection</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is the 6th in a series of articles that will hopefully teach
you about 3D math. Each one builds on the previous lesson so you may find
them easiest to understand by reading them in order.</p>
<ol>
<li><a href="webgpu-translation.html">Translation</a></li>
<li><a href="webgpu-rotation.html">Rotation</a></li>
<li><a href="webgpu-scale.html">Scaling</a></li>
<li><a href="webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="webgpu-perspective-projection.html">Perspective Projection</a> ⬅ you are here</li>
<li><a href="webgpu-cameras.html">Cameras</a></li>
<li><a href="webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="webgpu-scene-graphs.html">Scene Graphs</a></li>
</ol>
<p>In the last post we went over how to do 3D but that 3D didn’t have any
perspective.  It was using what’s called an “orthographic” view which has
its uses but it’s generally not what people want when they say “3D”.</p>
<p>Instead we need to add perspective. Just what is perspective?
It’s basically the feature that things that are further away appear
smaller.</p>
<img class="webgpu_center noinvertdark" style="width: 800px" src="resources/perspective-example.svg">
<p>Looking at the example above we see that things further away
are drawn smaller. Given our current sample one easy way to
make it so that things that are further away appear smaller
would be to divide the clip space X and Y by Z.</p>
<p>Think of it this way: If you have a line from (10, 15) to (20,15)
it’s 10 units long. In our current sample it would be drawn 10 pixels
long. But if we divide by Z then for example if Z is 1</p>
<div class="webgpu_center">
<pre class="webgpu_math">10 / 1 = 10
20 / 1 = 20
abs(10-20) = 10
</pre>
</div>
<p>it would be 10 pixels long, If Z is 2 it would be</p>
<div class="webgpu_center">
<pre class="webgpu_math">10 / 2 = 5
20 / 2 = 10
abs(5 - 10) = 5
</pre>
</div>
<p>5 pixels long.  At Z = 3 it would be</p>
<div class="webgpu_center">
<pre class="webgpu_math">10 / 3 = 3.333
20 / 3 = 6.666
abs(3.333 - 6.666) = 3.333
</pre>
</div>
<p>You can see that as Z increases, as it gets smaller, we’ll end up
drawing it smaller, and therefore it will appear further way.
If we divide in clip space we might get better
results because Z will be a smaller number (0 to +1).  If we add a
fudgeFactor to multiply Z before we divide we can adjust how much smaller
things get for a given distance.</p>
<p>Let’s try it.  First let’s change the vertex shader to divide by Z after
we’ve multiplied it by our “fudgeFactor”.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  matrix: mat4x4f,
+  fudgeFactor: f32,
};

struct Vertex {
  @location(0) position: vec4f,
  @location(1) color: vec4f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(vert: Vertex) -&gt; VSOutput {
  var vsOut: VSOutput;
-  vsOut.position = uni.matrix * vert.position;
+  let position = uni.matrix * vert.position;
+
+  let zToDivideBy = 1.0 + position.z * uni.fudgeFactor;
+
+  vsOut.position = vec4f(
+      position.xy / zToDivideBy,
+      position.zw);

  vsOut.color = vert.color;
  return vsOut;
}
</pre>
<p>Note: By adding 1 we can set <code class="notranslate" translate="no">fudgeFactor</code> to 0 and get a <code class="notranslate" translate="no">zToDivideBy</code>
that is equal to 1. This will let is compare when not dividing by Z
because dividing by 1 does nothing.</p>
<p>We also need to update the code to let us set the fudgeFactor.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  // matrix
-  const uniformBufferSize = (16) * 4;
+  // matrix, fudgeFactor, padding
+  const uniformBufferSize = (16 + 1 + 3) * 4;
  const uniformBuffer = device.createBuffer({
    label: 'uniforms',
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const uniformValues = new Float32Array(uniformBufferSize / 4);

  // offsets to the various uniform values in float32 indices
  const kMatrixOffset = 0;
+  const kFudgeFactorOffset = 16;

  const matrixValue = uniformValues.subarray(kMatrixOffset, kMatrixOffset + 16);
+  const fudgeFactorValue = uniformValues.subarray(kFudgeFactorOffset, kFudgeFactorOffset + 1);

...

  const settings = {
    translation: [canvas.clientWidth / 2 - 200, canvas.clientHeight / 2 - 75, -1000],
    rotation: [degToRad(40), degToRad(25), degToRad(325)],
    scale: [3, 3, 3],
+    fudgeFactor: 0.5,
  };

...

  const gui = new GUI();
  gui.onChange(render);
  gui.add(settings.translation, '0', 0, 1000).name('translation.x');
  gui.add(settings.translation, '1', 0, 1000).name('translation.y');
  gui.add(settings.translation, '2', -1000, 1000).name('translation.z');
  gui.add(settings.rotation, '0', radToDegOptions).name('rotation.x');
  gui.add(settings.rotation, '1', radToDegOptions).name('rotation.y');
  gui.add(settings.rotation, '2', radToDegOptions).name('rotation.z');
  gui.add(settings.scale, '0', -5, 5).name('scale.x');
  gui.add(settings.scale, '1', -5, 5).name('scale.y');
  gui.add(settings.scale, '2', -5, 5).name('scale.z');
+  gui.add(settings, 'fudgeFactor', 0, 50);

...

  function render() {

    ...

    mat4.ortho(
        0,                   // left
        canvas.clientWidth,  // right
        canvas.clientHeight, // bottom
        0,                   // top
        1200,                // near
        -1000,               // far
        matrixValue,         // dst
    );
    mat4.translate(matrixValue, settings.translation, matrixValue);
    mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
    mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
    mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
    mat4.scale(matrixValue, settings.scale, matrixValue);

+    fudgeFactorValue[0] = settings.fudgeFactor;
</pre>
<p>I also adjusted the <code class="notranslate" translate="no">settings</code> to hopefully make it easy to see the results.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
-    translation: [45, 100, 0],
+    translation: [canvas.clientWidth / 2 - 200, canvas.clientHeight / 2 - 75, -1000],
    rotation: [degToRad(40), degToRad(25), degToRad(325)],
-    scale: [1, 1, 1],
+    scale: [3, 3, 3],
    fudgeFactor: 10,
  };
</pre>
<p>And here’s the result.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-perspective-projection-step-1-fudge-factor.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-perspective-projection-step-1-fudge-factor.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>If it’s not clear drag the “fudgeFactor” slider from 10.0 to 0.0 to see
what things used to look like before we added our divide by Z code.</p>
<img class="webgpu_center" src="resources/orthographic-vs-perspective.png">
<div class="webgpu_center">orthographic vs perspective</div>
<p>It turns out WebGPU takes the x,y,z,w value we assign to <code class="notranslate" translate="no">@builtin(position)</code>
our vertex shader and divides it by w automatically.</p>
<p>We can prove this very easily by changing the shader and instead of doing
the division ourselves, put <code class="notranslate" translate="no">zToDivideBy</code> in <code class="notranslate" translate="no">vsOut.position.w</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">@vertex fn vs(vert: Vertex) -&gt; VSOutput {
  var vsOut: VSOutput;
  let position = uni.matrix * vert.position;

  let zToDivideBy = 1.0 + position.z * uni.fudgeFactor;

-  vsOut.position = vec4f(
-      position.xy / zToDivideBy,
-      position.zw);
+  vsOut.position = vec4f(position.xyz, zToDivideBy);

  vsOut.color = vert.color;
  return vsOut;
}
</pre>
<p>and see how it’s exactly the same.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-perspective-projection-step-2-gpu-divide-by-w.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-perspective-projection-step-2-gpu-divide-by-w.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Why is the fact that WebGPU automatically divides by W useful?  Because
now, using more matrix magic, we can just use yet another matrix to copy z
to w.</p>
<p>A Matrix like this</p>
<div class="webgpu_math_center"><pre class="webgpu_math">1  0  0  0
0  1  0  0
0  0  1  0
0  0  1  0
</pre></div>
<p>will copy z to w. You can look at each of those rows as</p>
<div class="webgpu_math_center"><pre class="webgpu_math">x_out = x_in * 1 +
        y_in * 0 +
        z_in * 0 +
        w_in * 0 ;
 
y_out = x_in * 0 +
        y_in * 1 +
        z_in * 0 +
        w_in * 0 ;
 
z_out = x_in * 0 +
        y_in * 0 +
        z_in * 1 +
        w_in * 0 ;
 
w_out = x_in * 0 +
        y_in * 0 +
        z_in * 1 +
        w_in * 0 ;
</pre></div>
<p>which when simplified is</p>
<div class="webgpu_math_center"><pre class="webgpu_math">x_out = x_in;
y_out = y_in;
z_out = z_in;
w_out = z_in;
</pre></div>
<p>We can add the plus 1 we had before with this matrix since we know <code class="notranslate" translate="no">w_in</code> is always 1.0.</p>
<div class="webgpu_math_center"><pre class="webgpu_math">1  0  0  0
0  1  0  0
0  0  1  0
0  0  1  1
</pre></div>
<p>that will change the W calculation to</p>
<div class="webgpu_math_center"><pre class="webgpu_math">w_out = x_in * 0 +
        y_in * 0 +
        z_in * 1 +
        w_in * 1 ;
</pre></div>
<p>and since we know <code class="notranslate" translate="no">w_in</code> = 1.0 then that’s really</p>
<div class="webgpu_math_center"><pre class="webgpu_math">w_out = z_in + 1;
</pre></div>
<p>Finally we can work our fudgeFactor back in if the matrix is this</p>
<div class="webgpu_math_center"><pre class="webgpu_math">1  0  0            0
0  1  0            0
0  0  1            0
0  0  fudgeFactor  1
</pre></div>
<p>which means</p>
<div class="webgpu_math_center"><pre class="webgpu_math">w_out = x_in * 0 +
        y_in * 0 +
        z_in * fudgeFactor +
        w_in * 1 ;
</pre></div>
<p>and simplified that’s</p>
<div class="webgpu_math_center"><pre class="webgpu_math">w_out = z_in * fudgeFactor + 1;
</pre></div>
<p>So, let’s modify the program again to just use matrices.</p>
<p>First let’s put the vertex shader back so it’s simple again</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct Uniforms {
  matrix: mat4x4f,
-  fudgeFactor: f32,
};

struct Vertex {
  @location(0) position: vec4f,
  @location(1) color: vec4f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;uniform&gt; uni: Uniforms;

@vertex fn vs(vert: Vertex) -&gt; VSOutput {
  var vsOut: VSOutput;
-  let position = uni.matrix * vert.position;
-
-  let zToDivideBy = 1.0 + position.z * uni.fudgeFactor;
-
-  vsOut.position = vec4f(
-      position.xy / zToDivideBy,
-      position.zw);
  vsOut position = uni.matrix * vert.position;
  vsOut.color = vert.color;
  return vsOut;
}

@fragment fn fs(vsOut: VSOutput) -&gt; @location(0) vec4f {
  return vsOut.color;
}
</pre>
<p>Next let’s make a function to make a Z → W matrix.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function makeZToWMatrix(fudgeFactor) {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, fudgeFactor,
    0, 0, 0, 1,
  ];
}
</pre>
<p>and we’ll change the code to use it.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">-    mat4.ortho(
+    const projection = mat4.ortho(
        0,                   // left
        canvas.clientWidth,  // right
        canvas.clientHeight, // bottom
        0,                   // top
        1200,                // near
        -1000,               // far
-        matrixValue,         // dst
    );
+    mat4.multiply(makeZToWMatrix(settings.fudgeFactor), projection, matrixValue);
    mat4.translate(matrixValue, settings.translation, matrixValue);
    mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
    mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
    mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
    mat4.scale(matrixValue, settings.scale, matrixValue);
</pre>
<p>and note, again, it’s exactly the same.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-perspective-projection-step-3-perspective-z-to-w.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-perspective-projection-step-3-perspective-z-to-w.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>All that was basically just to show you that dividing by Z gives us
perspective and that WebGPU conveniently does this divide by Z for us.</p>
<p>But there are still some problems.  For example if you set Z to around
-1100 you’ll see something like the animation below</p>
<div class="webgpu_center"><div data-diagram="z-clipping" style="height: 400px;"></div></div>
<p>What’s going on?  Why is the F disappearing early?  Just like WebGPU clips
X and Y or +1 to -1 it also clips Z. Unlike X and Y, Z clips 0 to +1.
What we’re seeing here is Z &lt; 0 in clip space.</p>
<div class="webgpu_center" style="width: 500px; height: 400px;"><div data-diagram="f-frustum-diagram"></div></div>
<p>With with divide by W in place, our matrix math + the divide by W defines
a <em>frustum</em>. The front of the frustum is Z = 0, the back is Z = 1. Anything
outside of that is clipped.</p>
<blockquote>
<h2>frustum</h2>
<p><i>noun</i>:</p>
<ol><li>a cone or pyramid with the upper part cut off by a plane parallel to its base</li></ol>
</blockquote>
<p>I could go into detail about the math to fix it but <a href="https://stackoverflow.com/a/28301213/128511">you can derive
it</a> the same way we did 2D
projection.  We need to take Z, add some amount (translation) and scale some amount and
we can make any range we want get remapped to the -1 to +1.</p>
<p>The cool thing is all of these steps can be done in 1 matrix.  Even
better, rather than a <code class="notranslate" translate="no">fudgeFactor</code> we’ll decide on a <code class="notranslate" translate="no">fieldOfView</code> and
compute the right values to make that happen.</p>
<p>Here’s a function to build the matrix.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mat4 = {
  ...
  perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
    dst = dst || new Float32Array(16);

    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
    const rangeInv = 1 / (zNear - zFar);

    dst[0] = f / aspect;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;

    dst[4] = 0;
    dst[5] = f;
    dst[6] = 0;
    dst[7] = 0;

    dst[8] = 0;
    dst[9] = 0;
    dst[10] = zFar * rangeInv;
    dst[11] = -1;

    dst[12] = 0;
    dst[13] = 0;
    dst[14] = zNear * zFar * rangeInv;
    dst[15] = 0;

    return dst;
  }
</pre>
<p>This matrix will do all our conversions for us.  It will adjust the units
so they are in clip space, it will do the math so that we can choose a
field of view by angle and it will let us choose our Z-clipping space.  It
assumes there’s an <em>eye</em> or <em>camera</em> at the origin (0, 0, 0) and given a
<code class="notranslate" translate="no">zNear</code> and a <code class="notranslate" translate="no">fieldOfView</code> it computes what it would take so that stuff
at <code class="notranslate" translate="no">zNear</code> ends up at <code class="notranslate" translate="no">Z = 0</code> and stuff at <code class="notranslate" translate="no">zNear</code> that is half of
<code class="notranslate" translate="no">fieldOfView</code> above or below the center ends up with <code class="notranslate" translate="no">Y = -1</code> and <code class="notranslate" translate="no">Y = 1</code>
respectively.  It computes what to use for X by just multiplying by the
<code class="notranslate" translate="no">aspect</code> passed in.  We’d normally set this to the <code class="notranslate" translate="no">width / height</code> of the
display area.  Finally, it figures out how much to scale things in Z so
that stuff at zFar ends up at <code class="notranslate" translate="no">Z = 1</code>.</p>
<p>Here’s a diagram of the matrix in action.</p>
<div class="webgpu_center" style="width: 500px; height: 800px;"><div data-diagram="frustum-diagram"></div></div>
<p>The matrix takes the space inside the frustum and
converts that to clip space.  <code class="notranslate" translate="no">zNear</code> defines where things will get
clipped in the front and <code class="notranslate" translate="no">zFar</code> defines where things get clipped in the
back.  Set <code class="notranslate" translate="no">zNear</code> to 23 and you’ll see the front of the spinning cubes
get clipped.  Set <code class="notranslate" translate="no">zFar</code> to 24 and you’ll see the back of the cubes get
clipped.</p>
<p>Let’s use this function in our example.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    fieldOfView: degToRad(100),
    translation: [canvas.clientWidth / 2 - 200, canvas.clientHeight / 2 - 75, -1000],
    rotation: [degToRad(40), degToRad(25), degToRad(325)],
    scale: [3, 3, 3],
-    fudgeFactor: 10,
  };

  const radToDegOptions = { min: -360, max: 360, step: 1, converters: GUI.converters.radToDeg };

  const gui = new GUI();
  gui.onChange(render);
  gui.add(settings, 'fieldOfView', {min: 1, max: 179, converters: GUI.converters.radToDeg});
  gui.add(settings.translation, '0', 0, 1000).name('translation.x');
  gui.add(settings.translation, '1', 0, 1000).name('translation.y');
  gui.add(settings.translation, '2', -1400, 1000).name('translation.z');
  gui.add(settings.rotation, '0', radToDegOptions).name('rotation.x');
  gui.add(settings.rotation, '1', radToDegOptions).name('rotation.y');
  gui.add(settings.rotation, '2', radToDegOptions).name('rotation.z');
  gui.add(settings.scale, '0', -5, 5).name('scale.x');
  gui.add(settings.scale, '1', -5, 5).name('scale.y');
  gui.add(settings.scale, '2', -5, 5).name('scale.z');
-  gui.add(settings, 'fudgeFactor', 0, 50);

  ...

  function render() {
    ....

-    const projection = mat4.ortho(
-        0,                   // left
-        canvas.clientWidth,  // right
-        canvas.clientHeight, // bottom
-        0,                   // top
-        1200,                // near
-        -1000,               // far
-    );
-    mat4.multiply(makeZToWMatrix(settings.fudgeFactor), projection, matrixValue);
+    const aspect = canvas.clientWidth / canvas.clientHeight;
+    mat4.perspective(
+        settings.fieldOfView,
+        aspect,
+        1,      // zNear
+        2000,   // zFar
+        matrixValue,
+    );
    mat4.translate(matrixValue, settings.translation, matrixValue);
    mat4.rotateX(matrixValue, settings.rotation[0], matrixValue);
    mat4.rotateY(matrixValue, settings.rotation[1], matrixValue);
    mat4.rotateZ(matrixValue, settings.rotation[2], matrixValue);
    mat4.scale(matrixValue, settings.scale, matrixValue);
</pre>
<p>There’s just one problem left.  This projection matrix assumes there’s a viewer at 0,0,0
and it assumes it’s looking in the negative Z direction and that positive Y is
up.  Our matrices up to this point have done things in a different way.
We need to put the F, which is 150 units tall, 100 units wide, and 30 units thick,
in some -Z position and it needs to be far enough away that it fits inside the frustum.
The frustum we’ve defined above, with <code class="notranslate" translate="no">zNear</code> = 1 will only show about 2.4 units from
top to bottom when an object is 1 unit away so our F will be %98 off the screen.</p>
<p>Playing around with some numbers I came up with these settings.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const settings = {
    fieldOfView: degToRad(100),
-    translation: [canvas.clientWidth / 2 - 200, canvas.clientHeight / 2 - 75, -1000],
-    rotation: [degToRad(40), degToRad(25), degToRad(325)],
-    scale: [3, 3, 3],
+    translation: [-65, 0, -120],
+    rotation: [degToRad(220), degToRad(25), degToRad(325)],
+    scale: [1, 1, 1],
  };
</pre>
<p>And, while we’re at it let’s adjust the UI settings to be more appropriate.
Let’s also remove the scale to unclutter to UI a little.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const gui = new GUI();
  gui.onChange(render);
  gui.add(settings, 'fieldOfView', {min: 1, max: 179, converters: GUI.converters.radToDeg});
-  gui.add(settings.translation, '0', 0, 1000).name('translation.x');
-  gui.add(settings.translation, '1', 0, 1000).name('translation.y');
-  gui.add(settings.translation, '2', -1400, 1000).name('translation.z');
+  gui.add(settings.translation, '0', -1000, 1000).name('translation.x');
+  gui.add(settings.translation, '1', -1000, 1000).name('translation.y');
+  gui.add(settings.translation, '2', -1400, -100).name('translation.z');
  gui.add(settings.rotation, '0', radToDegOptions).name('rotation.x');
  gui.add(settings.rotation, '1', radToDegOptions).name('rotation.y');
  gui.add(settings.rotation, '2', radToDegOptions).name('rotation.z');
-  gui.add(settings.scale, '0', -5, 5).name('scale.x');
-  gui.add(settings.scale, '1', -5, 5).name('scale.y');
-  gui.add(settings.scale, '2', -5, 5).name('scale.z');
</pre>
<p>Let’s also get rid of the grid since we’re no longer in “pixel space”.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">:root {
  --bg-color: #fff;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #000;
  }
}
canvas {
  display: block;  /* make the canvas act like a block   */
  width: 100%;     /* make the canvas fill its container */
  height: 100%;
}
</pre>
<p>And here it is.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-perspective-projection-step-4-perspective.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-perspective-projection-step-4-perspective.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>We’re back to just a matrix multiply on our shader and we’re getting both a field of
view and we’re able to choose our Z space.</p>
<p>Next up, <a href="webgpu-cameras.html">cameras</a>.</p>
<div class="webgpu_bottombar">
<h3>Why did we move the F so far in Z (-120)?</h3>
<p>
In the other samples we had the F at (45, 100, 0) but in the last sample
it's been moved to (-65, 0, -120).  Why did it need to be moved so far
away?
</p>
<p>
The reason is up until this last sample our <code class="notranslate" translate="no">mat4.projection</code> function
made a projection from pixels to clip space.  That means the area we
were displaying kinda of represented pixels.  Using 'pixels' really doesn't
make sense in 3D since it would only represent pixels at a specific distance from the camera.
</p>
<p>
In other words, with our new perspective projection matrix, if we tried to draw with the F with translation at 0,0,0 and rotation 0,0,0 it we'd get this
</p>
<div class="webgpu_center"><img src="resources/f-big-and-wrong-side.svg" style="width: 500px;"></div>
<p>
The F has its top left front corner at the origin. The perspective projection matrix
looks toward negative Z but our F is built in positive Z. The perspective projection matrix has
positive Y up but our F is built with positive Z down.
</p>
<p>
Our new projection only sees what's in the blue frustum. With -zNear = 1 and with a field of view of 100 degrees
then at Z = -1 the frustum is only 2.38 units tall and 2.38 * aspect units wide. At Z = -2000 (-zFar) its 4767 units tall.
Since our F is 150 units big and the view can only see 2.38
units when something is at <code class="notranslate" translate="no">-zNear</code> we need to move it further away from the origin to see all of it.
</p>
<p>
Moving it -120 units in Z moves the F inside the frustum. We also rotated it to be right side up.
</p>
<div class="webgpu_center"><img src="resources/f-right-side.svg" style="width: 500px;"><div>not to scale</div></div>
</div>
<!-- keep this at the bottom of the article -->
<script type="module" src="webgpu-perspective-projection.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-perspective-projection.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-perspective-projection.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-perspective-projection.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-perspective-projection.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-perspective-projection.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-perspective-projection.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-perspective-projection.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-perspective-projection.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Perspective Projection`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>