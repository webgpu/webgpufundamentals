<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-how-it-works.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How WebGPU works">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-how-it-works_en.jpg">

<meta property="og:title" content="WebGPU How It Works">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-how-it-works_en.jpg">
<meta property="og:description" content="How WebGPU works">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU How It Works">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html">
<meta name="twitter:description" content="How WebGPU works">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-how-it-works_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-how-it-works_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html",
      "inLanguage":"en",
      "name":"WebGPU How It Works",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-how-it-works.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU How It Works</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">

<link rel="stylesheet" href="/webgpu/lessons/lang.css">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-how-it-works.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-how-it-works.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-how-it-works.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-how-it-works.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-how-it-works.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-how-it-works.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-how-it-works.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-how-it-works.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub">
  <div>
    <div><a href="https://github.com/webgpu/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div>
  </div>
</div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU How It Works</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Let’s try to explain WebGPU by implementing something similar to what the GPU does
with vertex shaders and fragment shaders but in JavaScript. Hopefully this will give
you an intuitive feeling about what’s really going on.</p>
<p>If you’re familiar with
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a>,
if you squint real hard you can get some idea of how these 2 different kinds of
shader functions work. With <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array.map"><code class="notranslate" translate="no">Array.map</code></a> you provide a function to transform a value.</p>
<p>Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const shader = v =&gt; v * 2;  // double the input
const input = [1, 2, 3, 4];
const output = input.map(shader);   // result [2, 4, 6, 8]
</pre>
<p>Above our “shader” for array.map is just a function that given a number, returns
its double. That’s probably the closest analogy in JavaScript to what “shader”
means. It’s a function that returns or generates values. You don’t call it
directly. Instead, you specify it and then the system calls it for you.</p>
<p>For a GPU vertex shader you don’t map over an input array. Instead, you just
specify a count of how many times you want the function to be called.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function draw(count, vertexShaderFn) {
  const internalBuffer = [];
  for (let i = 0; i &lt; count; ++i) {
    internalBuffer[i] = vertexShaderFn(i);
  }
  console.log(JSON.stringify(internalBuffer));
}
</pre>
<p>One consequence is that unlike <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array.map"><code class="notranslate" translate="no">Array.map</code></a>, we no longer need a source array to do something.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const shader = v =&gt; v * 2;
const count = 4;
draw(count, shader);
// outputs [0, 2, 4, 6]
</pre>
<p>The thing that makes GPU work complicated is that these functions run on a separate
system in your computer, the GPU. This means all the data you create and reference
has to somehow be sent to the GPU and you then need to communicate to the shader
where you put that data and how to access it.</p>
<p>Vertex And Fragment shaders can take data in 6 ways. Uniforms, Attributes, Buffers, Textures, Inter-Stage Variables, Constants.</p>
<ol>
<li>
<p>Uniforms</p>
<p>Uniforms are values that are the same for each iteration of the shader. Think
of them as constant global variables. You can set them before a shader is run
but, while the shader is being used, they remain constant, or to put it
another way, they remain <em>uniform</em>.</p>
<p>Let’s change <code class="notranslate" translate="no">draw</code> to pass uniforms to a shader. To do this we’ll
make an array called <code class="notranslate" translate="no">bindings</code> and use it to pass in the uniforms.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">*function draw(count, vertexShaderFn, bindings) {
  const internalBuffer = [];
  for (let i = 0; i &lt; count; ++i) {
*    internalBuffer[i] = vertexShaderFn(i, bindings);
  }
  console.log(JSON.stringify(internalBuffer));
}
</pre>
<p>And then let’s change our shader to use the uniforms</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vertexShader = (v, bindings) =&gt; {
  const uniforms = bindings[0];
  return v * uniforms.multiplier;
};
const count = 4;
const uniforms1 = {multiplier: 3};
const uniforms2 = {multiplier: 5};
const bindings1 = [uniforms1];
const bindings2 = [uniforms2];
draw(count, vertexShader, bindings1);
// outputs [0, 3, 6, 9]
draw(count, vertexShader, bindings2);
// outputs [0, 5, 10, 15]
</pre>
<p>So, the concept of uniforms hopefully seems pretty straight forward. The
indirection through <code class="notranslate" translate="no">bindings</code> is there because this is “similar” to how things
are done in WebGPU. Like was mentioned above, we access the things, in this case
the uniforms, by location/index. Here they are found in <code class="notranslate" translate="no">bindings[0]</code>.</p>
</li>
<li>
<p>Attributes (vertex shaders only)</p>
<p>Attributes provide per shader iteration data. In <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array.map"><code class="notranslate" translate="no">Array.map</code></a> above,
the value <code class="notranslate" translate="no">v</code> was pulled from <code class="notranslate" translate="no">input</code> and automatically provided
to the function. This is very similar to an attribute in a shader.</p>
<p>The difference is, we are not mapping over the input, instead,
because we are just counting, we need to tell WebGPU
about these inputs and how to get data out of them.</p>
<p>Imagine we updated <code class="notranslate" translate="no">draw</code> like this.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">*function draw(count, vertexShaderFn, bindings, attribsSpec) {
  const internalBuffer = [];
  for (let i = 0; i &lt; count; ++i) {
*    const attribs = getAttribs(attribsSpec, i);
*    internalBuffer[i] = vertexShaderFn(i, bindings, attribs);
  }
  console.log(JSON.stringify(internalBuffer));
}

+function getAttribs(attribs, ndx) {
+  return attribs.map(({source, offset, stride}) =&gt; source[ndx * stride + offset]);
+}
</pre>
<p>Then we could call it like this.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer1 = [0, 1, 2, 3, 4, 5, 6, 7];
const buffer2 = [11, 22, 33, 44];
const attribsSpec = [
  { source: buffer1, offset: 0, stride: 2, },
  { source: buffer1, offset: 1, stride: 2, },
  { source: buffer2, offset: 0, stride: 1, },
];
const vertexShader = (v, bindings, attribs) =&gt; (attribs[0] + attribs[1]) * attribs[2];
const bindings = [];
const count = 4;
draw(count, vertexShader, bindings, attribsSpec);
// outputs [11, 110, 297, 572]
</pre>
<p>As you can see above, <code class="notranslate" translate="no">getAttribs</code> uses <code class="notranslate" translate="no">offset</code>, and <code class="notranslate" translate="no">stride</code> to
compute indices into the corresponding <code class="notranslate" translate="no">source</code> buffer and pulls out values.
The pulled out values are then sent to the shader. On each iteration
<code class="notranslate" translate="no">attribs</code> will be different.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no"> iteration |  attribs
 ----------+-------------
     0     | [0, 1, 11]
     1     | [2, 3, 22]
     2     | [4, 5, 33]
     3     | [6, 7, 44]
</pre>
</li>
<li>
<p>Raw Buffers</p>
<p>Buffers are effectively arrays, again for our analogy let’s make version
of <code class="notranslate" translate="no">draw</code> that uses buffers. We’ll pass these buffers via <code class="notranslate" translate="no">bindings</code>
like we did with uniforms.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer1 = [0, 1, 2, 3, 4, 5, 6, 7];
const buffer2 = [11, 22, 33, 44];
const attribsSpec = [];
const bindings = [
  buffer1,
  buffer2,
];
const vertexShader = (ndx, bindings, attribs) =&gt; 
    (bindings[0][ndx * 2] + bindings[0][ndx * 2 + 1]) * bindings[1][ndx];
const count = 4;
draw(count, vertexShader, bindings, attribsSpec);
// outputs [11, 110, 297, 572]
</pre>
<p>Here we got the same result as we did with attributes except this time,
instead of the system pulling the values out of the buffers for us, we
calculated our own indices into the bound buffers. This is more flexible than
attributes since we basically have random access to the arrays. But, it’s
potentially slower for that same reason. Given the way attributes worked the
GPU knows the values will be accessed in order which it can use to optimize.
For example, in order access is usually cache friendly. When we calculate our
own indices the GPU has no idea which part of a buffer we’re going to access
until we actually try to access it.</p>
</li>
<li>
<p>Textures</p>
<p>Textures are 1d, 2d, or 3d arrays of data. Of course, we could implement
our own 2d or 3d arrays using buffers. What’s special about textures
is they can be sampled. Sampling means that we can ask the GPU to compute
a value between the values we supply. We’ll cover that this means in
<a href="webgpu-textures.html">the article on textures</a>. For now, let’s make
a JavaScript analogy again.</p>
<p>First we’ll create a function <code class="notranslate" translate="no">textureSample</code> that <em>samples</em> an array
between values.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function textureSample(texture, ndx) {
  const startNdx = ndx | 0;  // round down to an int
  const fraction = ndx % 1;  // get the fractional part between indices
  const start = texture[startNdx];
  const end = texture[startNdx + 1];
  return start + (end - start) * fraction;  // compute value between start and end
}
</pre>
<p>A function something like that already exists on the GPU.</p>
<p>Now let’s use that in a shader.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const texture = [10, 20, 30, 40, 50, 60, 70, 80];
const attribsSpec = [];
const bindings = [
  texture,
];
const vertexShader = (ndx, bindings, attribs) =&gt;
    textureSample(bindings[0], ndx * 1.75);
const count = 4;
draw(count, vertexShader, bindings, attribsSpec);
// outputs [10, 27.5, 45, 62.5]
</pre>
<p>When <code class="notranslate" translate="no">ndx</code> is <code class="notranslate" translate="no">3</code> we’ll pass in <code class="notranslate" translate="no">3 * 1.75</code> or <code class="notranslate" translate="no">5.25</code> into <code class="notranslate" translate="no">textureSample</code>.
That will compute a <code class="notranslate" translate="no">startNdx</code> of <code class="notranslate" translate="no">5</code>. So we’ll pull out indices <code class="notranslate" translate="no">5</code> and <code class="notranslate" translate="no">6</code>
which are <code class="notranslate" translate="no">60</code> and <code class="notranslate" translate="no">70</code>. <code class="notranslate" translate="no">fraction</code> becomes <code class="notranslate" translate="no">0.25</code>, so we’ll get
<code class="notranslate" translate="no">60 + (70 - 60) * 0.25</code> which is <code class="notranslate" translate="no">62.5</code>.</p>
<p>Looking at the code above we could write <code class="notranslate" translate="no">textureSample</code> ourselves in our shader
function. We could manually pull out the 2 values and interpolate between them.
The reason the GPU has this special functionality is it can do it much faster
and, depending on the settings, it may read as many as sixteen 4-float values
to produce one 4-float value for us. That would be a lot of work to do manually.</p>
</li>
<li>
<p>Inter-Stage Variables (fragment shaders only)</p>
<p>Inter-Stage Variables are outputs from a vertex shader to a fragment shader. As was mentioned
above, a vertex shader outputs positions that are used to draw/rasterize points,
lines, and triangles.</p>
<p>Let’s imagine we’re drawing a line. Let’s say our vertex shader was run
twice, the first time it output the equivalent of <code class="notranslate" translate="no">5,0</code> and the second time
the equivalent of <code class="notranslate" translate="no">25,4</code>. Given those 2 points the GPU will draw a line from
<code class="notranslate" translate="no">5,0</code> to <code class="notranslate" translate="no">25,4</code> exclusive. To do this it will call our fragment shader 20
times, once for each of the pixels on that line. Each time it calls our
fragment shader it’s up to us to decide what color to return.</p>
<p>Let’s assume we have pair of functions that help us draw a line between
2 points. The first function computes how many pixel’s we need to draw and some
values to help draw them. The second takes that info plus a pixel number
and gives us a pixel position. Example:</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const line = calcLine([10, 10], [13, 13]);
for (let i = 0; i &lt; line.numPixels; ++i) {
  const p = calcLinePoint(line, i);
  console.log(p);
}
// prints
// 10,10
// 11,11
// 12,12
</pre>
<p>Note: How <code class="notranslate" translate="no">calcLine</code> and <code class="notranslate" translate="no">calcLinePoint</code> work are unimportant, what’s
important is that they do work and let the loop above provide
the pixel positions for a line. <strong>Though if you’re curious, see the live
code example near the bottom of the article.</strong></p>
<p>So, let’s change our vertex shader so it outputs 2 values per iteration. We could do that in many ways. Here’s one.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer1 = [5, 0, 25, 4];
const attribsSpec = [
  {source: buffer1, offset: 0, stride: 2},
  {source: buffer1, offset: 1, stride: 2},
];
const bindings = [];
const dest = new Array(2);
const vertexShader = (ndx, bindings, attribs) =&gt; [attribs[0], attribs[1]];
const count = 2;
draw(count, vertexShader, bindings, attribsSpec);
// outputs [[5, 0], [25, 4]]
</pre>
<p>Now let’s write some code that loops over points 2 at a time and
calls <code class="notranslate" translate="no">rasterizeLines</code> to rasterize a line.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function rasterizeLines(dest, destWidth, inputs, fragShaderFn, bindings) {
  for (let ndx = 0; ndx &lt; inputs.length - 1; ndx += 2) {
    const p0 = inputs[ndx    ];
    const p1 = inputs[ndx + 1];
    const line = calcLine(p0, p1);
    for (let i = 0; i &lt; line.numPixels; ++i) {
      const p = calcLinePoint(line, i);
      const offset = p[1] * destWidth + p[0];  // y * width + x
      dest[offset] = fragShaderFn(bindings);
    }
  }
}
</pre>
<p>We can update <code class="notranslate" translate="no">draw</code> to use that code like this</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function draw(count, vertexShaderFn, bindings, attribsSpec) {
+function draw(dest, destWidth,
+              count, vertexShaderFn, fragmentShaderFn,
+              bindings, attribsSpec,
+) {
  const internalBuffer = [];
  for (let i = 0; i &lt; count; ++i) {
    const attribs = getAttribs(attribsSpec, i);
    internalBuffer[i] = vertexShaderFn(i, bindings, attribs);
  }
-  console.log(JSON.stringify(internalBuffer));
+  rasterizeLines(dest, destWidth, internalBuffer,
+                 fragmentShaderFn, bindings);
}
</pre>
<p>Now we’re actually using <code class="notranslate" translate="no">internalBuffer</code> 😃!</p>
<p>Let’s update the code that calls <code class="notranslate" translate="no">draw</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer1 = [5, 0, 25, 4];
const attribsSpec = [
  {source: buffer1, offset: 0, stride: 2},
  {source: buffer1, offset: 1, stride: 2},
];
const bindings = [];
const vertexShader = (ndx, bindings, attribs) =&gt; [attribs[0], attribs[1]];
const count = 2;
-draw(count, vertexShader, bindings, attribsSpec);

+const width = 30;
+const height = 5;
+const pixels = new Array(width * height).fill(0);
+const fragShader = (bindings) =&gt; 6;

*draw(
*   pixels, width,
*   count, vertexShader, fragShader,
*   bindings, attribsSpec);
</pre>
<p>If we print <code class="notranslate" translate="no">pixels</code> as a rectangle where <code class="notranslate" translate="no">0</code> becomes <code class="notranslate" translate="no">.</code> we’d get this</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">.....666......................
........66666.................
.............66666............
..................66666.......
.......................66.....
</pre>
<p>Unfortunately, our fragment shader gets no input that changes each iteration so
there is no way to output anything different for each pixel. This is where
inter-stage variables come in. Let’s change our first shader to output an extra value.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const buffer1 = [5, 0, 25, 4];
+const buffer2 = [9, 3];
const attribsSpec = [
  {source: buffer1, offset: 0, stride: 2},
  {source: buffer1, offset: 1, stride: 2},
+  {source: buffer2, offset: 0, stride: 1},
];
const bindings = [];
const dest = new Array(2);
const vertexShader = (ndx, bindings, attribs) =&gt; 
-    [attribs[0], attribs[1]];
+    [[attribs[0], attribs[1]], [attribs[2]]];

...
</pre>
<p>If we changed nothing else, after the loop inside <code class="notranslate" translate="no">draw</code>, <code class="notranslate" translate="no">internalBuffer</code> would have these values</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no"> [ 
   [[ 5, 0], [9]],
   [[25, 4], [3]],
 ]
</pre>
<p>We can easily compute a value from 0.0 to 1.0 that represents how far along
the line we are. We can use this to interpolate the extra value we just
added.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function rasterizeLines(dest, destWidth, inputs, fragShaderFn, bindings) {
  for(let ndx = 0; ndx &lt; inputs.length - 1; ndx += 2) {
-    const p0 = inputs[ndx    ];
-    const p1 = inputs[ndx + 1];
+    const p0 = inputs[ndx    ][0];
+    const p1 = inputs[ndx + 1][0];
+    const v0 = inputs[ndx    ].slice(1);  // everything but the first value
+    const v1 = inputs[ndx + 1].slice(1);
    const line = calcLine(p0, p1);
    for (let i = 0; i &lt; line.numPixels; ++i) {
      const p = calcLinePoint(line, i);
+      const t = i / line.numPixels;
+      const interStageVariables = interpolateArrays(v0, v1, t);
      const offset = p[1] * destWidth + p[0];  // y * width + x
-      dest[offset] = fragShaderFn(bindings);
+      dest[offset] = fragShaderFn(bindings, interStageVariables);
    }
  }
}

+// interpolateArrays([[1,2]], [[3,4]], 0.25) =&gt; [[1.5, 2.5]]
+function interpolateArrays(v0, v1, t) {
+  return v0.map((array0, ndx) =&gt; {
+    const array1 = v1[ndx];
+    return interpolateValues(array0, array1, t);
+  });
+}

+// interpolateValues([1,2], [3,4], 0.25) =&gt; [1.5, 2.5]
+function interpolateValues(array0, array1, t) {
+  return array0.map((a, ndx) =&gt; {
+    const b = array1[ndx];
+    return a + (b - a) * t;
+  });
+}
</pre>
<p>Now we can use those inter-stage variables in our fragment shader</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const fragShader = (bindings) =&gt; 6;
+const fragShader = (bindings, interStageVariables) =&gt; 
+    interStageVariables[0] | 0; // convert to int
</pre>
<p>If we ran it now we’d see results like this</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">.....988......................
........87776.................
.............66655............
..................54443.......
.......................33.....
</pre>
<p>The first iteration of the vertex shader output <code class="notranslate" translate="no">[[5,0], [9]]</code> and
the 2nd iteration output <code class="notranslate" translate="no">[[25,4], [3]]</code> and you can see,
as the fragment shader was called, the 2nd value of each of those
was interpolated between the two values.</p>
<p>We could make another function <code class="notranslate" translate="no">mapTriangle</code> that given 3 points
rasterized a triangle calling the fragment shader function for each
point inside the triangle. It would interpolate the inter-stage variables
from 3 points instead of 2.</p>
</li>
</ol>
<p>Here are all the examples above running live in case you find it
useful to play around with them to understand them.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-javascript-analogies.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-javascript-analogies.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>What happens in the JavaScript above is an analogy. The details
of how inter-stage variables are actually interpolated, how lines are drawn, how
buffers are accessed, how textures are sampled, uniforms, attributes specified,
etc… are different in WebGPU, but the concepts are very similar so
I hope this JavaScript analogy provided some help in getting a mental
model of what’s happening.</p>
<p>Why is it this way? Well, if you look at <code class="notranslate" translate="no">draw</code> and <code class="notranslate" translate="no">rasterizeLines</code>
you might notice that each iteration is entirely independent of
the other iterations. Another way to say this, you could process
each iteration in any order. Instead of 0, 1, 2, 3, 4 you could
process them 3, 1, 4, 0, 2 and you’d get the exact same result.
The fact that they are independent means each iteration can be
run in parallel by a different processor. Modern 2021 top end
GPUs have 10000 or more processors. That means up to 10000 things can be
run in parallel. That is where the power of using the GPU comes from.
By following these patterns the system can massively parallelize
the work.</p>
<p>The biggest limitations are:</p>
<ol>
<li>
<p>A shader function can only reference
its inputs (attributes, buffers, textures, uniforms, inter-stage variables).</p>
</li>
<li>
<p>A shader can not allocate memory.</p>
</li>
<li>
<p>A shader has to be careful if it references things it writes to, the thing it’s
generating values for.</p>
<p>When you think about it this makes sense. Imagine <code class="notranslate" translate="no">fragShader</code>
above tried to reference <code class="notranslate" translate="no">dest</code> directly. That would mean when
trying to parallelize things it would be impossible to coordinate.
Which iteration would go first? If the 3rd iteration referenced <code class="notranslate" translate="no">dest[0]</code>
then the 0th iteration would need to run first but if the 0th iteration
referenced <code class="notranslate" translate="no">dest[3]</code> then the 3rd iteration would need to run first.</p>
<p>Designing around this limitation also happens with CPUs and multiple
thread or processes but in GPU land, with up to 10000 processors running
at once, it takes special coordination. We’ll try to cover some of the
techniques in other articles.</p>
</li>
</ol>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-how-it-works.html" selected="">English
    </option><option value="/webgpu/lessons/es/webgpu-how-it-works.html">Spanish
    </option><option value="/webgpu/lessons/ja/webgpu-how-it-works.html">日本語
    </option><option value="/webgpu/lessons/ko/webgpu-how-it-works.html">한국어
    </option><option value="/webgpu/lessons/ru/webgpu-how-it-works.html">Русский
    </option><option value="/webgpu/lessons/tr/webgpu-how-it-works.html">Türkçe
    </option><option value="/webgpu/lessons/uk/webgpu-how-it-works.html">Українська
    </option><option value="/webgpu/lessons/zh_cn/webgpu-how-it-works.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
  <li>Textures</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Loading Images</a></li>
<li><a href="/webgpu/lessons/webgpu-textures-external-video.html">Using Video</a></li>
<li><a href="/webgpu/lessons/webgpu-cube-maps.html">Cube Maps</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-textures.html">Storage Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-multisampling.html">Multisampling / MSAA</a></li>
        </ul>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-transparency.html">Transparency and Blending</a></li>
<li><a href="/webgpu/lessons/webgpu-bind-group-layouts.html">Bind Group Layouts</a></li>
<li><a href="/webgpu/lessons/webgpu-copying-data.html">Copying Data</a></li>
<li><a href="/webgpu/lessons/webgpu-limits-and-features.html">Optional Features and Limits</a></li>
<li><a href="/webgpu/lessons/webgpu-timing.html">Timing Performance</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
<li><a href="/webgpu/lessons/webgpu-compatibility-mode.html">Compatibility Mode</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgpu/lessons/webgpu-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html">Large Clip Space Triangle</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-environment-maps.html">Environment maps</a></li>
<li><a href="/webgpu/lessons/webgpu-skybox.html">Skyboxes</a></li>
        </ul>
  <li>Post Processing</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-post-processing.html">Post Processing</a></li>
        </ul>
        </ul>
  <li>Compute Shaders</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-compute-shaders.html">Compute Shader Basics</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram.html">Image Histogram</a></li>
<li><a href="/webgpu/lessons/webgpu-compute-shaders-histogram-part-2.html">Image Histogram Part 2</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgpu/lessons/webgpu-multiple-canvases.html">Multiple Canvases</a></li>
<li><a href="/webgpu/lessons/webgpu-points.html">Points</a></li>
<li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-optimization.html">Speed and Optimization</a></li>
<li><a href="/webgpu/lessons/webgpu-debugging.html">Debugging and Errors</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
<li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/webgpu/webgpufundamentals">github</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
  <li><a href="https://webgpureport.org">WebGPUReport.org</a></li>
  <li><a href="https://web3dsurvey.com/webgpu">Web3DSurvey.com</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
<div>
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
   <a href="https://github.com/webgpu/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
</div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU How It Works`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js" type="module"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-92BFT5PE4H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-92BFT5PE4H');
</script>






</body></html>